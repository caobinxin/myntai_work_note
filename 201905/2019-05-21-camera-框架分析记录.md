# camera 框架分析记录

## 1.参考资料准备

url: https://www.cnblogs.com/younghao/p/5337058.html

https://www.jianshu.com/p/1332d3864f7c



vim 格式化

https://blog.csdn.net/qachenzude/article/details/25511875

## 2.framework分析

### 2.1 Camera.java

/home/colby/android_system_os/haier/frameworks/base/core/java/android/hardware/Camera.java

```java
public static Camera open() {
        int numberOfCameras = getNumberOfCameras();
        CameraInfo cameraInfo = new CameraInfo();
        for (int i = 0; i < numberOfCameras; i++) {
            getCameraInfo(i, cameraInfo);
            if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
                return new Camera(i);
            }
        }
        return null;
    }
```

- getNumberOfCameras为native方法，实现在android_hardware_Camera.cpp中； 

- CameraInfo是Camera定义的静态内部类，包含facing、orientation、canDisableShutterSound；  

- getCameraInfo内部调用native方法_getCameraInfo获取摄像头信息；  

- open()默认启动的是后置摄像头（CAMERA_FACING_BACK）。

```java
/*Camera构造器的核心实现在cameraInitNormal中，cameraInitNormal调用cameraInitVersion，并传入参数cameraId和CAMERA_HAL_API_VERSION_NORMAL_CONNECT，后者代表HAL的版本。*/
Camera(int cameraId) {
        int err = cameraInitNormal(cameraId);
    }

private int cameraInitNormal(int cameraId) {
    //private static final int CAMERA_HAL_API_VERSION_NORMAL_CONNECT = -2;
        return cameraInitVersion(cameraId, CAMERA_HAL_API_VERSION_NORMAL_CONNECT);
    }


private int cameraInitVersion(int cameraId, int halVersion) {
        mShutterCallback = null;
        mRawImageCallback = null;
        mJpegCallback = null;
        mPreviewCallback = null;
        mPostviewCallback = null;
        mUsingPreviewAllocation = false;
        mZoomListener = null;

        Looper looper;
        if ((looper = Looper.myLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else {
            mEventHandler = null;
        }

        return native_setup(new WeakReference<Camera>(this), cameraId, halVersion,
                ActivityThread.currentOpPackageName());
    }

//cameraInitNormal调用本地方法native_setup()，由此进入到android_hardware_Camera.cpp中
private native final int native_setup(Object camera_this, int cameraId, int halVersion,
                                           String packageName);
```

### 2.2 jni 分析

haier/frameworks/base/core/jni/android_hardware_Camera.cpp

```c++
static const JNINativeMethod camMethods[] = {
    { "native_setup",                  
    "(Ljava/lang/Object;IILjava/lang/String;)I",
    (void*)android_hardware_Camera_native_setup },
}

static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz,
    jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName)
{
    //应用层的包名
    const char16_t *rawClientName = reinterpret_cast<const char16_t*>(env->GetStringChars(clientPackageName, NULL));    
    
    jsize rawClientNameLen = env->GetStringLength(clientPackageName);
    String16 clientName(rawClientName, rawClientNameLen);
    env->ReleaseStringChars(clientPackageName,reinterpret_cast<const jchar*>(rawClientName));
    
    sp<Camera> camera;
    if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) {
        // Default path: hal version is don't care, do normal camera connect.
        camera = Camera::connect(cameraId, clientName,
                Camera::USE_CALLING_UID, Camera::USE_CALLING_PID);
    } 
}
```

Camera::connect()位于Camera.cpp中，由此进入到Library层。

### 2.3 Library层分析

frameworks/av/camera/Camera.cpp

```c++
sp<Camera> Camera::connect(int cameraId, const String16& clientPackageName,
        int clientUid, int clientPid)                         
{
    //typedef CameraBase<TCam>         CameraBaseT;//被重新定义了,而Camera 继承了　CameraBase<Camera>
    return CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);
}
```

frameworks/av/camera/CameraBase.cpp

CameraBase实际上又继承了IBinder的DeathRecipient内部类，DeathRecipient虚拟继承自RefBase。RefBase是Android中的引用计数基础类，其中定义了incStrong、decStrong、incWeak和decWeak等涉及sp/wp的指针操作函数，当然这扯远了。

/home/colby/android_system_os/haier/frameworks/av/include/camera/CameraBase.h

```c++
typedef typename TCamTraits::TCamListener       TCamListener;                     
typedef typename TCamTraits::TCamUser           TCamUser;
typedef typename TCamTraits::TCamCallbacks      TCamCallbacks;
typedef typename TCamTraits::TCamConnectService TCamConnectService;

typedef CameraBase<TCam>         CameraBaseT;//被重新定义了

//CameraBase是个模板
template <typename TCam, typename TCamTraits = CameraTraits<TCam> >
class CameraBase : public IBinder::DeathRecipient
{

}

template <typename TCam>
struct CameraTraits {                                                                                                                                                                                          
};
//CameraBase 的　TCamTraits　默认类型是　CameraTraits模板，

//CameraBase.cpp
template class CameraBase<Camera>;

```



```c++
//frameworks/av/include/camera/Camera.h
// Camera 继承了　CameraBase<Camera> 也同时继承了BnCameraClient
class Camera :public CameraBase<Camera>,public ::android::hardware::BnCameraClient
{
	friend class        CameraBase;
}


template <>
struct CameraTraits<Camera>{
    typedef CameraListener                     TCamListener;
    typedef ::android::hardware::ICamera       TCamUser;
    typedef ::android::hardware::ICameraClient TCamCallbacks;
    typedef ::android::binder::Status(::android::hardware::ICameraService::*TCamConnectService)
        (const sp<::android::hardware::ICameraClient>&,
        int, const String16&, int, int,
        /*out*/
        sp<::android::hardware::ICamera>*);
    static TCamConnectService     fnConnectService; 
};
```

继续分析CameraBase.cpp

回到Camera::connect()的实现上，其中，new TCam(cameraId)生成BnCameraClient对象，BnCameraClient定义在ICameraClient.h文件中，继承自模板类BnInterface。getCameraService()方法返回CameraService的服务代理BpCameraService，BpCameraService同样继承自模板类BnInterface。然后通过Binder通信发送CONNECT命令，当BnCameraService收到CONNECT命令后调用CameraService的connect()成员函数来做相应的处理。

```c++
#define LOG_TAG "CHAOZHUO_COLBY_CameraBase"//改变了tag

template <typename TCam, typename TCamTraits>
sp<TCam> CameraBase<TCam, TCamTraits>::connect(int cameraId,const String16& clientPackageName,int clientUid, int clientPid){

	//Tcam = Camera　; Camera 继承了　CameraBase<Camera> 也同时继承了BnCameraClient
	sp<TCam> c = new TCam(cameraId);//BnCameraClient　类型
	
	//::android::hardware::ICameraClient = TCamCallbacks
	sp<TCamCallbacks> cl = c;//ICameraClient  类型        
    
    const sp<::android::hardware::ICameraService> cs = getCameraService();//BpCameraService 类型　2.3.1 分析
    
    if (cs != nullptr) {
        TCamConnectService fnConnectService = TCamTraits::fnConnectService;
        ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid, clientPid, /*out*/ &c->mCamera);//在2.3.２中进行分析
    }
    if (ret.isOk() && c->mCamera != nullptr) {
        IInterface::asBinder(c->mCamera)->linkToDeath(c);
        c->mStatus = NO_ERROR;
    } else {
        ALOGW("An error occurred while connecting to camera %d: %s", cameraId,
                (cs != nullptr) ? "Service not available" : ret.toString8().string());
        c.clear();
    }
    return c;
}


```

#### BnCameraClient

注：connect()函数在BpCameraService和BnCameraService的父类ICameraService中声明为纯虚函数，在BpCameraService和CameraService中分别给出了实现，BpCameraService作为代理类，提供接口给客户端，真正实现在BnCameraService的子类CameraService中。

```c++
class BnCameraClient: public BnInterface<ICameraClient>
{
public:
    virtual status_t    onTransact( uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
};
```

#### BpCameraService

```c++
class BpCameraService: public BpInterface<ICameraService>
{
public:
    BpCameraService(const sp<IBinder>& impl)
        : BpInterface<ICameraService>(impl)
    {
    }
    ……
}
```

#### 2.3.1 getCameraService分析

```c++
//CameraBase.cpp
template <typename TCam, typename TCamTraits>
const sp<::android::hardware::ICameraService> CameraBase<TCam, TCamTraits>::getCameraService()
{
    
    sp<IServiceManager> sm = defaultServiceManager();
    
    do {
        //const char* kCameraServiceName = "media.camera";
            binder = sm->getService(String16(kCameraServiceName));
            if (binder != 0) {
                break;
            }
            ALOGW("CameraService not published, waiting...");
            usleep(kCameraServicePollDelay);
        } while(true);
    
    if (gDeathNotifier == NULL) {      
            gDeathNotifier = new DeathNotifier();
        }
        binder->linkToDeath(gDeathNotifier);
        gCameraService = interface_cast<::android::hardware::ICameraService>(binder);
    return gCameraService;//这个就是ibinder借口，这个就可以通信了
}
```



#### 2.3.2 fnConnectService分析

Camera.cpp

```c++
CameraTraits<Camera>::TCamConnectService CameraTraits<Camera>::fnConnectService =         
        &::android::hardware::ICameraService::connect;//这里是一个地址
```

haier$ vim ./out/target/product/x86_64/obj/SHARED_LIBRARIES/libcamera_client_intermediates/aidl-generated/include/android/hardware/ICameraService.h

在out目录下我们可以推断出他是自动生成的ICameraService.h

现在在回过头来，看CameraBase.cpp

```c++
if (cs != nullptr) {
    
    	//TCamConnectService 是个函数指针　TCamTraits = CameraTraits<Camera>
        TCamConnectService fnConnectService = TCamTraits::fnConnectService;                                                                                                                                    
        ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid,
                                               clientPid, /*out*/ &c->mCamera);
    	/*翻译过来就是　cs->connect(,,,,)*/
    }

//CameraBase.h
typedef typename TCamTraits::TCamConnectService TCamConnectService;

//Camera.h
//函数指针的依据
typedef　
::android::binder::Status(::android::hardware::ICameraService::*TCamConnectService)
    (const sp<::android::hardware::ICameraClient>&,
        int, const String16&, int, int,
        /*out*/
        sp<::android::hardware::ICamera>*);
```

vim out/target/product/x86_64/obj/SHARED_LIBRARIES/libcamera_client_intermediates/aidl-generated/src/aidl/android/hardware/ICameraService.cpp

connect 函数中的一句代码，由于，是aidl自动生成的，函数名太长，这里是自动进行binder通讯的，这个函数追到这里就不追了。

```c++
//connect [android::hardware::BpCameraService]
connect{
    _aidl_ret_status = remote()->transact(ICameraService::CONNECT, _aidl_data, &_aidl_reply);
}

```

从这里发出，接收也在这个文件里：这里不写函数名了直接贴代码

```c++
//onTransact [android::hardware::BnCameraService]
BnCameraService::onTransact{
    case Call::CONNECT:
    	//调用这里的connect函数
		::android::binder::Status _aidl_status(connect(in_client, in_cameraId, in_opPackageName, in_clientUid, in_clientPid, &_aidl_return));
}
```

这个connect是在CameraService.cpp中调用的

### 2.4 服务的分析CameraService.cpp

```shell
haier/frameworks/av$ vim ./services/camera/libcameraservice/CameraService.cpp
haier/frameworks/av$ vim ./services/camera/libcameraservice/CameraService.h
```

#### 2.4.1 继承关系

```c++
class CameraService :
    public BinderService<CameraService>,
    public ::android::hardware::BnCameraService,
    public IBinder::DeathRecipient,
    public camera_module_callbacks_t
{

}
```

#### 2.4.2 connect函数

```c++
//connect [android::CameraService]
Status CameraService::connect(
        const sp<ICameraClient>& cameraClient,
        int cameraId,
        const String16& clientPackageName,
        int clientUid,
        int clientPid,
        /*out*/
        sp<ICamera>* device) {

    ATRACE_CALL();
    Status ret = Status::ok();
    String8 id = String8::format("%d", cameraId);
    sp<Client> client = nullptr;
    //connectHelper 在2.4.3中分析
    ret = connectHelper<ICameraClient,Client>(cameraClient, id,
            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1,
            /*legacyMode*/ false, /*shimUpdateOnly*/ false,
            /*out*/client);

    if(!ret.isOk()) {
        logRejected(id, getCallingPid(), String8(clientPackageName),
                ret.toString8());
        return ret;
    }

    *device = client;
    return ret;
}

```

最后，BpCamera实例是通过CameraService::connect()函数返回的。CameraService::connect()实现的核心是调用connectHelperLocked()函数根据HAL不同API的版本创建不同的client实例（早期版本中好像没有connectHelperLocked()这个函数，但功能基本相似）。

#### 2.4.3 connectHelper

```c++
CameraService::connectHelper(){
    
    if(!(ret = makeClient(this, cameraCb, clientPackageName, id, facing, clientPid,
                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,                                                                                                                 
                /*out*/&tmp)).isOk()) {
            return ret;
        }
    
    client->initialize(mModule);
}
```



```c++
status_t CameraClient::initialize(CameraModule *module) {


    mHardware = new CameraHardwareInterface(camera_device_name);
    res = mHardware->initialize(module);
    
    mHardware->setCallbacks(notifyCallback,             
            dataCallback,
            dataCallbackTimestamp,
            (void *)(uintptr_t)mCameraId);

}

```

```c++
//device1/CameraHardwareInterface.h:120　
status_t initialize(CameraModule *module)
    {   
        ALOGI("Opening camera %s", mName.string());
        camera_info info;
        status_t res = module->getCameraInfo(atoi(mName.string()), &info);
        if (res != OK) {
            return res;
        }   

        int rc = OK; 
        if (module->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_3 &&
            info.device_version > CAMERA_DEVICE_API_VERSION_1_0) {
            // Open higher version camera device as HAL1.0 device.
            ALOGI("CHAOZHUO_COLBY　在获得hw_device_t 时　，用的是openLegacy接口") ;                                                                                                                            
            rc = module->openLegacy(mName.string(),
                                     CAMERA_DEVICE_API_VERSION_1_0,
                                     (hw_device_t **)&mDevice);
        } else {
            ALOGI("CHAOZHUO_COLBY　在获得hw_device_t 时　，用的是open 接口") ;
            rc = module->open(mName.string(), (hw_device_t **)&mDevice);
            //mDevice 所有的操作都在这里
        }   
        if (rc != OK) {
            ALOGE("Could not open camera %s: %d", mName.string(), rc);
            return rc; 
        }   
        initHalPreviewWindow();
        return rc; 
    } 
```

使用hal的函数将通过这种方式使用：**mDevice->ops->**



上述函数中，主要注意以下流程：

1. 加粗的代码CameraHardwareInterface新建了了一个Camera硬件接口，当然，camera_device_name为摄像头设备名；  
2. mHardware->initialize(&module->common)调用底层硬件的初始化方法；  
3. mHardware->setCallbacks将CamerService处的回调函数注册到HAL处。

## 3.hal层分析

从这里开始分析

```c++
mHardware = new CameraHardwareInterface(camera_device_name);
    res = mHardware->initialize(module);
```

CameraHardwareInterface.h

```c++

```



```c++

```



### 3.1  找到hal层

CameraService.cpp

```c++
void CameraService::onFirstRef()
{
    camera_module_t *rawModule;
    int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,
            (const hw_module_t **)&rawModule);
    mModule = new CameraModule(rawModule);
    err = mModule->init();
}
```

### 3.2 camera_module_t

```c++
typedef struct camera_module {
    hw_module_t common;
    int (*get_number_of_cameras)(void);
    int (*get_camera_info)(int camera_id, struct camera_info *info);
    int (*set_callbacks)(const camera_module_callbacks_t *callbacks);
    void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops);
    int (*open_legacy)(const struct hw_module_t* module, const char* id,
            uint32_t halVersion, struct hw_device_t** device);
    int (*set_torch_mode)(const char* camera_id, bool enabled);
    int (*init)();
	void* reserved[5];
} camera_module_t;
```

### 3.3 hal层头

CameraHal.cpp

```c++
camera_module_t HAL_MODULE_INFO_SYM = {               
    common: {
         tag:           HARDWARE_MODULE_TAG,
         version_major: 1,
         version_minor: 0,
         id:            CAMERA_HARDWARE_MODULE_ID,
         name:          "Camera Module",
         author:        "The Android Open Source Project",
         methods:       &android::CameraFactory::mCameraModuleMethods,
         dso:           NULL,
         reserved:      {0},
    },  
    get_number_of_cameras:  android::CameraFactory::get_number_of_cameras,
    get_camera_info:        android::CameraFactory::get_camera_info,
};
```

CameraFactory.cpp

```c++
struct hw_module_methods_t CameraFactory::mCameraModuleMethods = {
    open: CameraFactory::device_open
};

int CameraFactory::device_open(const hw_module_t* module,
                                       const char* name,
                                       hw_device_t** device)
{
    int camera_id = atoi(name);
    return gCameraFactory.cameraDeviceOpen(module, camera_id, device);                                         
}

int CameraFactory::cameraDeviceOpen(const hw_module_t* module,int camera_id, hw_device_t** device)
{

    *device = NULL;

    if (!mCamera[camera_id]) {
        mCamera[camera_id] = new CameraHardware(module, mCameraDevices[camera_id]);
    }
    return mCamera[camera_id]->connectCamera(device);
}

status_t CameraHardware::connectCamera(hw_device_t** device)                  
{

    *device = &common;//找到了
    return NO_ERROR;
}
```





### 3.4 jni层的调用

```c++
//然而并不是在　这里调用的
//而是在 CameraHardwareInterface::initialize 中调用的，在上面有

int CameraModule::open(const char* id, struct hw_device_t** device) {            
    int res;
    ATRACE_BEGIN("camera_module->open");
    res = filterOpenErrorCode(mModule->common.methods->open(&mModule->common, id, device));
    ATRACE_END();
    return res;
}
```

### 3.5 hal 层方法集合

/home/colby/android_system_os/haier/hardware/libhardware/include/hardware/camera.h

```c++
typedef struct camera_device_ops {
    int (*set_preview_window)(struct camera_device *,
            struct preview_stream_ops *window);

    void (*set_callbacks)(struct camera_device *,
            camera_notify_callback notify_cb,
            camera_data_callback data_cb,
            camera_data_timestamp_callback data_cb_timestamp,
            camera_request_memory get_memory,
            void *user);

    void (*enable_msg_type)(struct camera_device *, int32_t msg_type);

    void (*disable_msg_type)(struct camera_device *, int32_t msg_type);

    int (*msg_type_enabled)(struct camera_device *, int32_t msg_type);

    int (*start_preview)(struct camera_device *);

    void (*stop_preview)(struct camera_device *);
    
    int (*preview_enabled)(struct camera_device *);
    
    int (*store_meta_data_in_buffers)(struct camera_device *, int enable);
    
    int (*start_recording)(struct camera_device *);
    
    void (*stop_recording)(struct camera_device *);
    
    int (*recording_enabled)(struct camera_device *);

    void (*release_recording_frame)(struct camera_device *,
                    const void *opaque);


    int (*auto_focus)(struct camera_device *);


    int (*cancel_auto_focus)(struct camera_device *);


    int (*take_picture)(struct camera_device *);


    int (*cancel_picture)(struct camera_device *);
                                                                                           
    int (*set_parameters)(struct camera_device *, const char *parms);
      char *(*get_parameters)(struct camera_device *);

    void (*put_parameters)(struct camera_device *, char *);

    int (*send_command)(struct camera_device *,
                int32_t cmd, int32_t arg1, int32_t arg2);

    void (*release)(struct camera_device *);

    int (*dump)(struct camera_device *, int fd);
} camera_device_ops_t;


typedef struct camera_device {                                                             
    hw_device_t common;//找到common就能找到　　camera_device_ops_t　了
    camera_device_ops_t *ops;
    void *priv;
} camera_device_t;
```

## 4. 带着问题分析：

### 4.1  getLegacyParameters

描述：Java层调用这个函数haier/frameworks/base/core/java/android/hardware/camera2/CameraManager.java

```java
public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId)
            throws CameraAccessException {
    String parameters = cameraService.getLegacyParameters(id);
}
```



这里猜测是调用hal层的 CameraHardware.cpp

```c++
camera_device_ops_t CameraHardware::mDeviceOps = {
    CameraHardware::set_preview_window,
    CameraHardware::set_callbacks,
    CameraHardware::enable_msg_type,
    CameraHardware::disable_msg_type,
    CameraHardware::msg_type_enabled,
    CameraHardware::start_preview,
    CameraHardware::stop_preview,
    CameraHardware::preview_enabled,
    CameraHardware::store_meta_data_in_buffers,
    CameraHardware::start_recording,
    CameraHardware::stop_recording,                                                                                   
    CameraHardware::recording_enabled,
    CameraHardware::release_recording_frame,
    CameraHardware::auto_focus,
    CameraHardware::cancel_auto_focus,
    CameraHardware::take_picture,
    CameraHardware::cancel_picture,
    CameraHardware::set_parameters,
    CameraHardware::get_parameters,//猜测调用这个函数
    CameraHardware::put_parameters,
    CameraHardware::send_command,
    CameraHardware::release,
    CameraHardware::dump
};
```

```c++
char* CameraHardware::get_parameters(struct camera_device* dev)                                                       
{
    CameraHardware* ec = reinterpret_cast<CameraHardware*>(dev->priv);
    if (ec == NULL) {
        ALOGE("%s: Unexpected NULL camera device", __FUNCTION__);
        return NULL;
    }
    return ec->getParameters();
}

char* CameraHardware::getParameters()
{   
    ALOGD("CHAOZHUO_COLBY CameraHardware::getParameters");
    String8 params;      
    {
        Mutex::Autolock lock(mLock);
        params = mParameters.flatten();//最主要的是这个
    }
    
    char* ret_str = reinterpret_cast<char*>(malloc(sizeof(char) * (params.length()+1)));
    memset(ret_str, 0, params.length()+1);
    if (ret_str != NULL) {    
        strncpy(ret_str, params.string(), params.length()+1);
        return ret_str;
    }
    
    ALOGE("%s: Unable to allocate string for %s", __FUNCTION__, params.string());
    /* Apparently, we can't return NULL fron this routine. */
    return &lNoParam;    
}
```

现在是追击，这个参数mParameters是从那来的，是从底层读取的还是从上层传递过来的：

```c++
CameraHardware::CameraHardware(const hw_module_t* module, char* devLocation) :
mParameters(),{
    ALOGD("CHAOZHUO_COLBY mParameters: 0.0 构造函数中 此时为空") ;
    
    /* Common header */
    common.tag = HARDWARE_DEVICE_TAG;
    common.version = 0;
    common.module = const_cast<hw_module_t*>(module);
    common.close = CameraHardware::close;

    /* camera_device fields. */
    ops = &mDeviceOps;
    priv = this;

    // Power on camera
    PowerOn();

    // Init default parameters
    initDefaultParameters();// 在构造CameraHardware的时候就会默认调用这个

}

void CameraHardware::initDefaultParameters()
{
    CameraParameters p;
    ALOGD("CHAOZHUO_COLBY mParameters: 0.1 设置默认的 参数，这里首先填充的是p") ;
    p.set(CameraParameters::KEY_SUPPORTED_ANTIBANDING,"auto");
    p.set(CameraParameters::KEY_ANTIBANDING,"auto");
    ...
      
    ALOGD("CHAOZHUO_COLBY mParameters: 0.2 默认p 的内容是: %s\n", p) ;
    if (setParameters(p.flatten()) != NO_ERROR) {                   
        ALOGE("CameraHardware::initDefaultParameters: Failed to set default parameters.");
    }
}

status_t CameraHardware::setParameters(const char* parms)
{
    ALOGD("CHAOZHUO_COLBY mParameters: 0.3 将新的params 保存在 mParameters 中 ") ;               mParameters = params;
}
```

现在关系很明确，是谁构造的CameraHardware对象呢?

现在我们要清楚一点**CameraHardware 是继承了 camera_device **

```c++
class CameraHardware : public camera_device {
    
}
typedef struct camera_device {                                                             
    hw_device_t common;
    camera_device_ops_t *ops;
    void *priv;
} camera_device_t;
```

从上面的关系中，我们就不难发现，当我们jni能找到 hw_device_t common;也就能找到 我们的 ops，也就能找到我们的CameraHardware

接下来就在 jni层中进行查找：



从日志中分析可知：我们的摄像头是没有 camera.power_file 这个文件的

```c++
//CameraHardware.cpp
#define CAMERA_POWER_FILE  "camera.power_file"
bool CameraHardware::PowerOn() {
	mCameraPowerFile = new char[PROPERTY_VALUE_MAX];
    if (!property_get(CAMERA_POWER_FILE, mCameraPowerFile, "")) {
        ALOGD("CameraHardware::PowerOn: no power_file set");//相机0 在这是对的，相机1在这就是有问题的
        delete [] mCameraPowerFile;
        mCameraPowerFile = 0; 
        return true;
    }
    
    ...
}
```



**初步定位是 VIDIOC_ENUM_FMT ioctl有问题,并没有放回对应摄像机的内参**





## 5. 调试记录

### 5.1 脚本

```shell
cd ~/android_system_os/haier;source ./build/envsetup.sh;lunch android_x86_64-userdebug;make camera.x86

adb connect 192.168.1.45;adb root ; adb push out/target/product/x86_64/system/lib64/hw/camera.x86.so /system/lib64/hw/camera.x86.so

adb disconnect;adb connect 192.168.1.45;adb shell logcat | grep camera > ~/logcat.hair

adb disconnect;adb connect 192.168.1.45;adb shell stop ; sleep 2s; adb shell start
```



### 5.2  一个坑人的操作

在编译的时候，会自动打patch，导致新的修改会被丢弃

目录：/home/colby/android_system_os/haier/packages/apps/chaozhuo/CZApplyPatches/x86

修改方案：将对应的patch包，重新命名，让其找不到，

hardware_libcamera.patch 改为 hardware_libcamera_patch



### 5.3 摄像头参数

前置摄像头：

```shell
parameters=antibanding=auto;antibanding-values=auto;effect=none;effect-values=none;exposure-compensation=6;exposure-compensation-step=0.5;flash-mode=off;flash-mode-values=off;focal-length=4;focus-mode=fixed;focus-mode-values=fixed;horizontal-view-angle=90;jpeg-quality=85;jpeg-thumbnail-size-values=640x480,0x0;max-video-continuous-zoom=0;max-zoom=100;picture-format=jpeg;picture-format-values=jpeg;picture-size=0x0;picture-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;preferred-preview-size-for-video=640x480;preview-format=yuv422sp;preview-format-values=yuv422i-yuyv,yuv422sp,yuv420sp,yuv420p;preview-fps-range-values=;preview-frame-rate=0;preview-frame-rate-values=;preview-size=0x0;preview-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;rotation=0;rotation-values=0;scene-mode=auto;scene-mode-values=auto;smooth-zoom-supported=false;vertical-view-angle=90;video-frame-format=yuv420p;video-size=0x0;video-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;whitebalance=auto;whitebalance-values=auto;zoom=0;zoom-ratios=100;zoom-supported=false
```

后置摄像头：

## 6. 从头在分析一遍

### 6.1 app所在进程

![](2019-05-21-camera-框架分析记录.assets/2019-05-24 15-33-45 的屏幕截图.png)



![](/home/colby/work/myntai_work_note/201905/2019-05-21-camera-框架分析记录.assets/2019-05-24 15-34-41 的屏幕截图.png)

#### 6.1.1 java

/home/colby/android_system_os/haier/development/samples/ApiDemos/src/com/example/android/apis/graphics/CameraPreview.java

```java
// 1. 步
//activity 才开始创建    
protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Hide the window title.
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);

        // Create a RelativeLayout container that will hold a SurfaceView,
        // and set it as the content of our activity.
        mPreview = new Preview(this);//为了配合相机，生成preview类的实例化对象，用来负责在显示屏上执行绘画操作
        setContentView(mPreview);

        // Find the total number of cameras available
        numberOfCameras = Camera.getNumberOfCameras();//public native static

        // Find the ID of the default camera
        CameraInfo cameraInfo = new CameraInfo();
            for (int i = 0; i < numberOfCameras; i++) {
                Camera.getCameraInfo(i, cameraInfo);
                if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
                    defaultCameraId = i;//这才是这个for的真实目的，找到默认的后置摄像头
                }
            }
    }

// 3. 步
//activity可以在前台可见了
@Override
    protected void onResume() {
        super.onResume();

        // Open the default i.e. the first rear facing camera.
        mCamera = Camera.open();//这个时候打开的摄像头
        cameraCurrentlyLocked = defaultCameraId;//后置摄像头
        mPreview.setCamera(mCamera);
    }
```



- 分析 Preview对象

```java
// 1. 1 步
class Preview extends ViewGroup implements SurfaceHolder.Callback {
    Preview(Context context) {
        super(context);

        //SurfaceView 在系统视图层次结构中，为应用程序提供了专用的绘图空间（surface）。
        //在专用绘图空间中实施的所有绘图作业都在后台被处理，应用程序不必等到surface生成或者绘图作业完成的时候
        mSurfaceView = new SurfaceView(context);
        addView(mSurfaceView);

        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        mHolder = mSurfaceView.getHolder();
        mHolder.addCallback(this);
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }
    
    // 2.  步
    //当surface 对象生成后，会自动回调这个方法surfaceCreated
    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, acquire the camera and tell it where
        // to draw.
        try {
            //如果 该方法回调的时机，早于 activity的 onResume，mCamera为空，
            if (mCamera != null) {
                mCamera.setPreviewDisplay(holder);
            }
        } catch (IOException exception) {
            Log.e(TAG, "IOException caused by setPreviewDisplay()", exception);
        }
    }
    
    // 5. 步
    //当surface的属性发生改变的时候，将会调用 surfaceChanged()方法，并且画面的尺寸信息将作为参数传入其中。
    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
        // Now that the size is known, set up the camera parameters and begin
        // the preview.
        Camera.Parameters parameters = mCamera.getParameters();
        parameters.setPreviewSize(mPreviewSize.width, mPreviewSize.height);
        requestLayout();

        mCamera.setParameters(parameters);//根据实际的surface的信息，来设置相机的参数,并设置
        mCamera.startPreview();//开始预览
    }
    
    // 4. 步
    public void setCamera(Camera camera) {
        mCamera = camera;
        if (mCamera != null) {
            //拿到支持的预览的值
            //最后调用到 private native final String native_getParameters方法
            mSupportedPreviewSizes = mCamera.getParameters().getSupportedPreviewSizes();
            requestLayout();
        }
    }
    
    //当 surface销毁的时候，将调用这个 停止预览
    public void surfaceDestroyed(SurfaceHolder holder) {
        // Surface will be destroyed when we return, so stop the preview.
        if (mCamera != null) {
            mCamera.stopPreview();//最终会调用到（native） _stopPreview();
        }
    }
}
```

注意：

- 这里分析的时候，要始终考虑 activity和surface的生命周期的事，才能看的懂
- 这里暂时不贴Camera.java中的内容,6.1.2直接从他们所对应的jni开始分析

总结：

1. mCamera = Camera.open()
2. mCamera.startPreview()
3. mCamera.stopPreview();
4. 其中夹杂这 mCamera.getParameters()和mCamera.setParameters(parameters)
5. 在这些调用中，我暂时还没有看到关于相机跨进程通讯的借口IBinder，
6. 暂时猜测是 app->Camera.java -> native方法 -jni-> c++ 代码 -> IBinder借口（这些都是在一个进程中完成）

#### 6.1.2 jni

这里主要分析Camera.java的open函数

/home/colby/android_system_os/haier/frameworks/base/core/java/android/hardware/Camera.java

```shell
/home/colby/android_system_os/haier/frameworks/base/core/java/android/hardware/Camera.java
```

```java
// 1. mCamera = Camera.open() 主线程进来的

// 2.
public static Camera open() {
        int numberOfCameras = getNumberOfCameras();
        CameraInfo cameraInfo = new CameraInfo();
        for (int i = 0; i < numberOfCameras; i++) {
            getCameraInfo(i, cameraInfo);
            if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
                return new Camera(i);//这里new一个后置摄像头
            }
        }
        return null;
    }

// 3.
Camera(int cameraId) {
        int err = cameraInitNormal(cameraId);//
        if (checkInitErrors(err)) {
            if (err == -EACCES) {
                throw new RuntimeException("Fail to connect to camera service");
            } else if (err == -ENODEV) {
                throw new RuntimeException("Camera initialization failed");
            }
            // Should never hit this.
            throw new RuntimeException("Unknown camera error");
        }
    }
// 4. 
private int cameraInitNormal(int cameraId) {
    // CAMERA_HAL_API_VERSION_NORMAL_CONNECT = -2;
        return cameraInitVersion(cameraId, CAMERA_HAL_API_VERSION_NORMAL_CONNECT);
    }
// 5. 
private int cameraInitVersion(int cameraId = 后置摄像头, int halVersion = -2) {
        mShutterCallback = null;
        mRawImageCallback = null;
        mJpegCallback = null;
        mPreviewCallback = null;
        mPostviewCallback = null;
        mUsingPreviewAllocation = false;
        mZoomListener = null;

        Looper looper;
        if ((looper = Looper.myLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else {
            mEventHandler = null;
        }

        return native_setup(new WeakReference<Camera>(this), cameraId, halVersion,
                ActivityThread.currentOpPackageName());
    }

// 6. 
private native final int native_setup(Object camera_this, int cameraId, int halVersion,
                                           String packageName);
```

从这里开始，就进入c++ 层了

此时打点分析：

线程： 主线程

函数参数： 后置摄像头， hal层的版本号为 -2, app的包的名字

##### 6.1.2.1 jni 文件整体分析

base/core/jni/android_hardware_Camera.cpp分析

```c++
int register_android_hardware_Camera(JNIEnv *env)
{
    field fields_to_find[] = {
        { "android/hardware/Camera", "mNativeContext",   "J", &fields.context },
        { "android/hardware/Camera$CameraInfo", "facing",   "I", &fields.facing },
        { "android/hardware/Camera$CameraInfo", "orientation",   "I", &fields.orientation },
        { "android/hardware/Camera$CameraInfo", "canDisableShutterSound",   "Z",
          &fields.canDisableShutterSound },
        { "android/hardware/Camera$Face", "rect", "Landroid/graphics/Rect;", &fields.face_rect },
        { "android/hardware/Camera$Face", "leftEye", "Landroid/graphics/Point;", &fields.face_left_eye},
        { "android/hardware/Camera$Face", "rightEye", "Landroid/graphics/Point;", &fields.face_right_eye},
        { "android/hardware/Camera$Face", "mouth", "Landroid/graphics/Point;", &fields.face_mouth},
        { "android/hardware/Camera$Face", "score", "I", &fields.face_score },
        { "android/hardware/Camera$Face", "id", "I", &fields.face_id},
        { "android/graphics/Rect", "left", "I", &fields.rect_left },
        { "android/graphics/Rect", "top", "I", &fields.rect_top },
        { "android/graphics/Rect", "right", "I", &fields.rect_right },
        { "android/graphics/Rect", "bottom", "I", &fields.rect_bottom },
        { "android/graphics/Point", "x", "I", &fields.point_x},
        { "android/graphics/Point", "y", "I", &fields.point_y},
    };
    
    find_fields(env, fields_to_find, NELEM(fields_to_find));

    jclass clazz = FindClassOrDie(env, "android/hardware/Camera"); 
    fields.post_event = GetStaticMethodIDOrDie(env, clazz, "postEventFromNative",
                                               "(Ljava/lang/Object;IIILjava/lang/Object;)V");

    clazz = FindClassOrDie(env, "android/graphics/Rect");
    fields.rect_constructor = GetMethodIDOrDie(env, clazz, "<init>", "()V");

    clazz = FindClassOrDie(env, "android/hardware/Camera$Face");
    fields.face_constructor = GetMethodIDOrDie(env, clazz, "<init>", "()V");

    clazz = env->FindClass("android/graphics/Point");
    fields.point_constructor = env->GetMethodID(clazz, "<init>", "()V");
    if (fields.point_constructor == NULL) {
        ALOGE("Can't find android/graphics/Point()");
        return -1;
    }    
    
    // Register native functions 
    return RegisterMethodsOrDie(env, "android/hardware/Camera", camMethods, NELEM(camMethods));                                                                                                                
}
```

这里抛出一个疑问，我们在java中要用c的函数，都是要去加载so库的，但是我找了Camera.java中没有发现有加载库的地方，今天就来探个究竟

```c++
// 1.
void AndroidRuntime::start(...){
    /*
     * Register android functions.
     */
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }
}

// 2. 
/*
 * Register android native functions with the VM.
 */
/*static*/ int AndroidRuntime::startReg(JNIEnv* env){
    if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) < 0) {           
        env->PopLocalFrame(NULL);
        return -1;
    }
}

//数组
static const RegJNIRec gRegJNI[] = {
    ...
    REG_JNI(register_android_hardware_Camera),
    ...
};


// 1. 另外一种加载的时机，就是surface flinger's DdmConnection 加载的
/**
 * Used by surface flinger's DdmConnection to register native methods from
 * the framework.
 */                       
extern "C" jint registerFrameworkNatives(JNIEnv* env) {
    return register_jni_procs(gRegJNI, NELEM(gRegJNI), env);
}
```

从这段分析可以看出来，我们系统层面用的jni库在 AndroidRuntime::start() 就已经给我们准备好了。不用单独加载了。



##### 6.1.2.2 native_setup 分析

继续分析 native_setup的执行流程：

回忆一下此时，线程处于主线程, 函数参数： 后置摄像头， hal层的版本号为 -2, app的包的名字

```c++
static const JNINativeMethod camMethods[] = {
    { "native_setup",
    "(Ljava/lang/Object;IILjava/lang/String;)I",
    (void*)android_hardware_Camera_native_setup },
}

//1.  主要是连接 camera service
// connect to camera service
static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz,
    jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName)
{
    sp<Camera> camera;
    // CAMERA_HAL_API_VERSION_NORMAL_CONNECT = -2
    if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) {
        // Default path: hal version is don't care, do normal camera connect.
        camera = Camera::connect(cameraId, clientName,
                Camera::USE_CALLING_UID, Camera::USE_CALLING_PID);
    }
}


//2.
sp<Camera> Camera::connect(int cameraId, const String16& clientPackageName,
        int clientUid, int clientPid)
{
    return CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);
}

//3.
template <typename TCam, typename TCamTraits>
sp<TCam> CameraBase<TCam, TCamTraits>::connect(int cameraId,
                                               const String16& clientPackageName,
                                               int clientUid, int clientPid)
{
    //TCam 是Camera类
    sp<TCam> c = new TCam(cameraId); //对应第4步
    const sp<::android::hardware::ICameraService> cs = getCameraService();// 对应第6步
    
    if (cs != nullptr) {
        TCamConnectService fnConnectService = TCamTraits::fnConnectService;
        ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid,
                                               clientPid, /*out*/ &c->mCamera);//对应7步
    }
}

// 4.
Camera::Camera(int cameraId)
    : CameraBase(cameraId)
{
}  
// 5.
template <typename TCam, typename TCamTraits>
CameraBase<TCam, TCamTraits>::CameraBase(int cameraId) :                     
    mStatus(UNKNOWN_ERROR),   
    mCameraId(cameraId)
{   
}

// 6.
// establish binder interface to camera service
template <typename TCam, typename TCamTraits>
const sp<::android::hardware::ICameraService> CameraBase<TCam, TCamTraits>::getCameraService()
{
 		sp<IServiceManager> sm = defaultServiceManager();
        sp<IBinder> binder;
        do {
            //kCameraServiceName="media.camera"
            //很开心，这里我们已经拿到了 跨进程通讯的Binder接口
            binder = sm->getService(String16(kCameraServiceName));//从这里我们可以看到我们去获得了这个服务
            if (binder != 0) {
                break;
            }
            ALOGW("CameraService not published, waiting...");
            usleep(kCameraServicePollDelay);
        } while(true);
        if (gDeathNotifier == NULL) {
            gDeathNotifier = new DeathNotifier();
        }
        binder->linkToDeath(gDeathNotifier);
        gCameraService = interface_cast<::android::hardware::ICameraService>(binder); 
    
    return gCameraService;//从这里我们就得出一个结论，c的服务只能有c来直接获得，java只能通过jni借助c来获得系统服务
}

//给函数指针赋值
CameraTraits<Camera>::TCamConnectService CameraTraits<Camera>::fnConnectService =
        &::android::hardware::ICameraService::connect;

//7. ICameraService->connect,这儿就是Ibiner通讯的封装了
out$ vim ./target/product/x86_64/obj/SHARED_LIBRARIES/libcamera_client_intermediates/aidl-generated/src/aidl/android/hardware/ICameraService.cpp
//这个文件是自动生成的，这里简单分析

BpCameraService::connect(){
	_aidl_ret_status = remote()->transact(ICameraService::CONNECT, _aidl_data, &_aidl_reply);
	//注意，这里，我们的主线程就会 暂停等待了，此时就要借助我们的binder驱动来通讯了
}
```

### 6.2 跨进程了

此时我们分析到，app的主进程已经暂停，binder驱动将我们的数据传递到 CameraService，并且从线程池中拿了一个线程，来执行我们接下来的connect任务

**线程池中拿一个线程**

#### 6.2.1 服务注册和启动

从上面的分析中，我们很明确，我们找的服务叫做 media.camera

##### 6.2.1.1 启动

frameworks/av/camera/cameraserver$ cat cameraserver.rc

```shell
service cameraserver /system/bin/cameraserver
    class main
    user cameraserver
    group audio camera input drmrpc
    ioprio rt 4
    writepid /dev/cpuset/camera-daemon/tasks /dev/stune/top-app/tasks
```

该目录下面的Android.mk文件可以好好分析一下

```makefile
LOCAL_PATH:= $(call my-dir)

ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
$(warning Target has integrated cameraserver into mediaserver. This is weakening security measures introduced in 7.0)
else
include $(CLEAR_VARS)

LOCAL_SRC_FILES:= \
	main_cameraserver.cpp

LOCAL_SHARED_LIBRARIES := \
	libcameraservice \#需要用到 这个so
	libcutils \
	libutils \
	libbinder \
	libcamera_client#需要用到 这个so 
#??? libcameraservice.so libcamera_client.so 都做了些啥事，在那处理的

LOCAL_MODULE:= cameraserver # 这个是个二进制可执行文件
LOCAL_32_BIT_ONLY := true

LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter

LOCAL_INIT_RC := cameraserver.rc #拷贝 rc文件到什么地方，就不知道了

include $(BUILD_EXECUTABLE)
endif
```



##### 6.2.1.2 服务注册

frameworks/av/camera/cameraserver$ cat main_cameraserver.cpp

```c++
int main(int argc __unused, char** argv __unused)
{
    signal(SIGPIPE, SIG_IGN);
    sp<ProcessState> proc(ProcessState::self());
    sp<IServiceManager> sm = defaultServiceManager();
    ALOGI("ServiceManager: %p", sm.get());
    CameraService::instantiate();//其实是在这里注册的
    ProcessState::self()->startThreadPool();//这个就是那个线程池
    IPCThreadState::self()->joinThreadPool();
}
```

找了好久CameraService::instantiate()中就没有这个函数的实现，那说明在他的父类中的

这里就来首先揭秘libcameraservice.so在那进行编译的

```shell
frameworks$ grep -inR "libcameraservice" --include=Android.mk
av/services/camera/libcameraservice/Android.mk:99:LOCAL_MODULE:= libcameraservice
```

```c++
//首先要明白这个继承关系 BinderService
class CameraService :
    public BinderService<CameraService>,
    public ::android::hardware::BnCameraService,
    public IBinder::DeathRecipient,
    public camera_module_callbacks_t
{

}
//看看BinderService 中有没有 instantiate 函数，
```

```shell
frameworks$ find -name BinderService.h
./native/include/binder/BinderService.h
```

```c++
template<typename SERVICE>
class BinderService
{
public:
    // 2.
    static status_t publish(bool allowIsolated = false) {
        sp<IServiceManager> sm(defaultServiceManager());
        return sm->addService(
            //SERVICE就是CameraService，这里我们在看CameraService的getServiceName()
                String16(SERVICE::getServiceName()),
                new SERVICE(), allowIsolated);
    }   

    static void publishAndJoinThreadPool(bool allowIsolated = false) {
        publish(allowIsolated);
        joinThreadPool();
    }   

    // 1.
    static void instantiate() { publish(); } // 哎居然有，     
    
    static status_t shutdown() { return NO_ERROR; }

private:
    static void joinThreadPool() {
        sp<ProcessState> ps(ProcessState::self());
        ps->startThreadPool();
        ps->giveThreadPoolName();
        IPCThreadState::self()->joinThreadPool();
    }   
};
```

```shell
frameworks/av/services/camera/libcameraservice$ grep -inR "getServiceName"
CameraService.h:95:    static char const* getServiceName() { return "media.camera"; }
```

**此时，我们可以得出结论了，我们在app端主线程找的服务就是这个服务了，**

#### 6.2.2 connect分析

当客户端调用 remote->transact，服务端对应的会调用ontransact()

```c++
//1. 在自动生成的ICameraService.cpp文件中
BnCameraService::onTransact(){ 
    case Call::CONNECT:
		connect(in_client, in_cameraId, in_opPackageName, in_clientUid, in_clientPid, &_aidl_return);
}


//2. 
// ./services/camera/libcameraservice/CameraService.cpp
Status CameraService::connect(
        const sp<ICameraClient>& cameraClient,
        int cameraId,
        const String16& clientPackageName,
        int clientUid,
        int clientPid,
        /*out*/
        sp<ICamera>* device) {

    ATRACE_CALL();
    Status ret = Status::ok();
    String8 id = String8::format("%d", cameraId);
    sp<Client> client = nullptr;
    ret = connectHelper<ICameraClient,Client>(cameraClient, id,
            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1,
            /*legacyMode*/ false, /*shimUpdateOnly*/ false,
            /*out*/client);

    if(!ret.isOk()) {
        logRejected(id, getCallingPid(), String8(clientPackageName),
                ret.toString8());          
        return ret; 
    }    

    *device = client;
    return ret; 
}
```





