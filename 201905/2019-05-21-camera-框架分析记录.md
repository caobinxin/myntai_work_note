# camera 框架分析记录

## 1.参考资料准备

url: https://www.cnblogs.com/younghao/p/5337058.html

https://www.jianshu.com/p/1332d3864f7c



vim 格式化

https://blog.csdn.net/qachenzude/article/details/25511875

## 2.framework分析

### 2.1 Camera.java

/home/colby/android_system_os/haier/frameworks/base/core/java/android/hardware/Camera.java

```java
public static Camera open() {
        int numberOfCameras = getNumberOfCameras();
        CameraInfo cameraInfo = new CameraInfo();
        for (int i = 0; i < numberOfCameras; i++) {
            getCameraInfo(i, cameraInfo);
            if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) {
                return new Camera(i);
            }
        }
        return null;
    }
```

- getNumberOfCameras为native方法，实现在android_hardware_Camera.cpp中； 

- CameraInfo是Camera定义的静态内部类，包含facing、orientation、canDisableShutterSound；  

- getCameraInfo内部调用native方法_getCameraInfo获取摄像头信息；  

- open()默认启动的是后置摄像头（CAMERA_FACING_BACK）。

```java
/*Camera构造器的核心实现在cameraInitNormal中，cameraInitNormal调用cameraInitVersion，并传入参数cameraId和CAMERA_HAL_API_VERSION_NORMAL_CONNECT，后者代表HAL的版本。*/
Camera(int cameraId) {
        int err = cameraInitNormal(cameraId);
    }

private int cameraInitNormal(int cameraId) {
    //private static final int CAMERA_HAL_API_VERSION_NORMAL_CONNECT = -2;
        return cameraInitVersion(cameraId, CAMERA_HAL_API_VERSION_NORMAL_CONNECT);
    }


private int cameraInitVersion(int cameraId, int halVersion) {
        mShutterCallback = null;
        mRawImageCallback = null;
        mJpegCallback = null;
        mPreviewCallback = null;
        mPostviewCallback = null;
        mUsingPreviewAllocation = false;
        mZoomListener = null;

        Looper looper;
        if ((looper = Looper.myLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else {
            mEventHandler = null;
        }

        return native_setup(new WeakReference<Camera>(this), cameraId, halVersion,
                ActivityThread.currentOpPackageName());
    }

//cameraInitNormal调用本地方法native_setup()，由此进入到android_hardware_Camera.cpp中
private native final int native_setup(Object camera_this, int cameraId, int halVersion,
                                           String packageName);
```

### 2.2 jni 分析

haier/frameworks/base/core/jni/android_hardware_Camera.cpp

```c++
static const JNINativeMethod camMethods[] = {
    { "native_setup",                  
    "(Ljava/lang/Object;IILjava/lang/String;)I",
    (void*)android_hardware_Camera_native_setup },
}

static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz,
    jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName)
{
    //应用层的包名
    const char16_t *rawClientName = reinterpret_cast<const char16_t*>(env->GetStringChars(clientPackageName, NULL));    
    
    jsize rawClientNameLen = env->GetStringLength(clientPackageName);
    String16 clientName(rawClientName, rawClientNameLen);
    env->ReleaseStringChars(clientPackageName,reinterpret_cast<const jchar*>(rawClientName));
    
    sp<Camera> camera;
    if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) {
        // Default path: hal version is don't care, do normal camera connect.
        camera = Camera::connect(cameraId, clientName,
                Camera::USE_CALLING_UID, Camera::USE_CALLING_PID);
    } 
}
```

Camera::connect()位于Camera.cpp中，由此进入到Library层。

### 2.3 Library层分析

frameworks/av/camera/Camera.cpp

```c++
sp<Camera> Camera::connect(int cameraId, const String16& clientPackageName,
        int clientUid, int clientPid)                         
{
    //typedef CameraBase<TCam>         CameraBaseT;//被重新定义了,而Camera 继承了　CameraBase<Camera>
    return CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid);
}
```

frameworks/av/camera/CameraBase.cpp

CameraBase实际上又继承了IBinder的DeathRecipient内部类，DeathRecipient虚拟继承自RefBase。RefBase是Android中的引用计数基础类，其中定义了incStrong、decStrong、incWeak和decWeak等涉及sp/wp的指针操作函数，当然这扯远了。

/home/colby/android_system_os/haier/frameworks/av/include/camera/CameraBase.h

```c++
typedef typename TCamTraits::TCamListener       TCamListener;                     
typedef typename TCamTraits::TCamUser           TCamUser;
typedef typename TCamTraits::TCamCallbacks      TCamCallbacks;
typedef typename TCamTraits::TCamConnectService TCamConnectService;

typedef CameraBase<TCam>         CameraBaseT;//被重新定义了

//CameraBase是个模板
template <typename TCam, typename TCamTraits = CameraTraits<TCam> >
class CameraBase : public IBinder::DeathRecipient
{

}

template <typename TCam>
struct CameraTraits {                                                                                                                                                                                          
};
//CameraBase 的　TCamTraits　默认类型是　CameraTraits模板，

//CameraBase.cpp
template class CameraBase<Camera>;

```



```c++
//frameworks/av/include/camera/Camera.h
// Camera 继承了　CameraBase<Camera> 也同时继承了BnCameraClient
class Camera :public CameraBase<Camera>,public ::android::hardware::BnCameraClient
{
	friend class        CameraBase;
}


template <>
struct CameraTraits<Camera>{
    typedef CameraListener                     TCamListener;
    typedef ::android::hardware::ICamera       TCamUser;
    typedef ::android::hardware::ICameraClient TCamCallbacks;
    typedef ::android::binder::Status(::android::hardware::ICameraService::*TCamConnectService)
        (const sp<::android::hardware::ICameraClient>&,
        int, const String16&, int, int,
        /*out*/
        sp<::android::hardware::ICamera>*);
    static TCamConnectService     fnConnectService; 
};
```

继续分析CameraBase.cpp

回到Camera::connect()的实现上，其中，new TCam(cameraId)生成BnCameraClient对象，BnCameraClient定义在ICameraClient.h文件中，继承自模板类BnInterface。getCameraService()方法返回CameraService的服务代理BpCameraService，BpCameraService同样继承自模板类BnInterface。然后通过Binder通信发送CONNECT命令，当BnCameraService收到CONNECT命令后调用CameraService的connect()成员函数来做相应的处理。

```c++
#define LOG_TAG "CHAOZHUO_COLBY_CameraBase"//改变了tag

template <typename TCam, typename TCamTraits>
sp<TCam> CameraBase<TCam, TCamTraits>::connect(int cameraId,const String16& clientPackageName,int clientUid, int clientPid){

	//Tcam = Camera　; Camera 继承了　CameraBase<Camera> 也同时继承了BnCameraClient
	sp<TCam> c = new TCam(cameraId);//BnCameraClient　类型
	
	//::android::hardware::ICameraClient = TCamCallbacks
	sp<TCamCallbacks> cl = c;//ICameraClient  类型        
    
    const sp<::android::hardware::ICameraService> cs = getCameraService();//BpCameraService 类型　2.3.1 分析
    
    if (cs != nullptr) {
        TCamConnectService fnConnectService = TCamTraits::fnConnectService;
        ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid, clientPid, /*out*/ &c->mCamera);//在2.3.２中进行分析
    }
    if (ret.isOk() && c->mCamera != nullptr) {
        IInterface::asBinder(c->mCamera)->linkToDeath(c);
        c->mStatus = NO_ERROR;
    } else {
        ALOGW("An error occurred while connecting to camera %d: %s", cameraId,
                (cs != nullptr) ? "Service not available" : ret.toString8().string());
        c.clear();
    }
    return c;
}


```

#### BnCameraClient

注：connect()函数在BpCameraService和BnCameraService的父类ICameraService中声明为纯虚函数，在BpCameraService和CameraService中分别给出了实现，BpCameraService作为代理类，提供接口给客户端，真正实现在BnCameraService的子类CameraService中。

```c++
class BnCameraClient: public BnInterface<ICameraClient>
{
public:
    virtual status_t    onTransact( uint32_t code,
                                    const Parcel& data,
                                    Parcel* reply,
                                    uint32_t flags = 0);
};
```

#### BpCameraService

```c++
class BpCameraService: public BpInterface<ICameraService>
{
public:
    BpCameraService(const sp<IBinder>& impl)
        : BpInterface<ICameraService>(impl)
    {
    }
    ……
}
```

#### 2.3.1 getCameraService分析

```c++
//CameraBase.cpp
template <typename TCam, typename TCamTraits>
const sp<::android::hardware::ICameraService> CameraBase<TCam, TCamTraits>::getCameraService()
{
    
    sp<IServiceManager> sm = defaultServiceManager();
    
    do {
        //const char* kCameraServiceName = "media.camera";
            binder = sm->getService(String16(kCameraServiceName));
            if (binder != 0) {
                break;
            }
            ALOGW("CameraService not published, waiting...");
            usleep(kCameraServicePollDelay);
        } while(true);
    
    if (gDeathNotifier == NULL) {      
            gDeathNotifier = new DeathNotifier();
        }
        binder->linkToDeath(gDeathNotifier);
        gCameraService = interface_cast<::android::hardware::ICameraService>(binder);
    return gCameraService;//这个就是ibinder借口，这个就可以通信了
}
```



#### 2.3.2 fnConnectService分析

Camera.cpp

```c++
CameraTraits<Camera>::TCamConnectService CameraTraits<Camera>::fnConnectService =         
        &::android::hardware::ICameraService::connect;//这里是一个地址
```

haier$ vim ./out/target/product/x86_64/obj/SHARED_LIBRARIES/libcamera_client_intermediates/aidl-generated/include/android/hardware/ICameraService.h

在out目录下我们可以推断出他是自动生成的ICameraService.h

现在在回过头来，看CameraBase.cpp

```c++
if (cs != nullptr) {
    
    	//TCamConnectService 是个函数指针　TCamTraits = CameraTraits<Camera>
        TCamConnectService fnConnectService = TCamTraits::fnConnectService;                                                                                                                                    
        ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid,
                                               clientPid, /*out*/ &c->mCamera);
    	/*翻译过来就是　cs->connect(,,,,)*/
    }

//CameraBase.h
typedef typename TCamTraits::TCamConnectService TCamConnectService;

//Camera.h
//函数指针的依据
typedef　
::android::binder::Status(::android::hardware::ICameraService::*TCamConnectService)
    (const sp<::android::hardware::ICameraClient>&,
        int, const String16&, int, int,
        /*out*/
        sp<::android::hardware::ICamera>*);
```

vim out/target/product/x86_64/obj/SHARED_LIBRARIES/libcamera_client_intermediates/aidl-generated/src/aidl/android/hardware/ICameraService.cpp

connect 函数中的一句代码，由于，是aidl自动生成的，函数名太长，这里是自动进行binder通讯的，这个函数追到这里就不追了。

```c++
//connect [android::hardware::BpCameraService]
connect{
    _aidl_ret_status = remote()->transact(ICameraService::CONNECT, _aidl_data, &_aidl_reply);
}

```

从这里发出，接收也在这个文件里：这里不写函数名了直接贴代码

```c++
//onTransact [android::hardware::BnCameraService]
BnCameraService::onTransact{
    case Call::CONNECT:
    	//调用这里的connect函数
		::android::binder::Status _aidl_status(connect(in_client, in_cameraId, in_opPackageName, in_clientUid, in_clientPid, &_aidl_return));
}
```

这个connect是在CameraService.cpp中调用的

### 2.4 服务的分析CameraService.cpp

```shell
haier/frameworks/av$ vim ./services/camera/libcameraservice/CameraService.cpp
haier/frameworks/av$ vim ./services/camera/libcameraservice/CameraService.h
```

#### 2.4.1 继承关系

```c++
class CameraService :
    public BinderService<CameraService>,
    public ::android::hardware::BnCameraService,
    public IBinder::DeathRecipient,
    public camera_module_callbacks_t
{

}
```

#### 2.4.2 connect函数

```c++
//connect [android::CameraService]
Status CameraService::connect(
        const sp<ICameraClient>& cameraClient,
        int cameraId,
        const String16& clientPackageName,
        int clientUid,
        int clientPid,
        /*out*/
        sp<ICamera>* device) {

    ATRACE_CALL();
    Status ret = Status::ok();
    String8 id = String8::format("%d", cameraId);
    sp<Client> client = nullptr;
    //connectHelper 在2.4.3中分析
    ret = connectHelper<ICameraClient,Client>(cameraClient, id,
            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1,
            /*legacyMode*/ false, /*shimUpdateOnly*/ false,
            /*out*/client);

    if(!ret.isOk()) {
        logRejected(id, getCallingPid(), String8(clientPackageName),
                ret.toString8());
        return ret;
    }

    *device = client;
    return ret;
}

```

最后，BpCamera实例是通过CameraService::connect()函数返回的。CameraService::connect()实现的核心是调用connectHelperLocked()函数根据HAL不同API的版本创建不同的client实例（早期版本中好像没有connectHelperLocked()这个函数，但功能基本相似）。

#### 2.4.3 connectHelper

```c++
CameraService::connectHelper(){
    
    if(!(ret = makeClient(this, cameraCb, clientPackageName, id, facing, clientPid,
                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,                                                                                                                 
                /*out*/&tmp)).isOk()) {
            return ret;
        }
    
    client->initialize(mModule);
}
```



```c++
status_t CameraClient::initialize(CameraModule *module) {


    mHardware = new CameraHardwareInterface(camera_device_name);
    res = mHardware->initialize(module);
    
    mHardware->setCallbacks(notifyCallback,             
            dataCallback,
            dataCallbackTimestamp,
            (void *)(uintptr_t)mCameraId);

}

```

```c++
//device1/CameraHardwareInterface.h:120　
status_t initialize(CameraModule *module)
    {   
        ALOGI("Opening camera %s", mName.string());
        camera_info info;
        status_t res = module->getCameraInfo(atoi(mName.string()), &info);
        if (res != OK) {
            return res;
        }   

        int rc = OK; 
        if (module->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_3 &&
            info.device_version > CAMERA_DEVICE_API_VERSION_1_0) {
            // Open higher version camera device as HAL1.0 device.
            ALOGI("CHAOZHUO_COLBY　在获得hw_device_t 时　，用的是openLegacy接口") ;                                                                                                                            
            rc = module->openLegacy(mName.string(),
                                     CAMERA_DEVICE_API_VERSION_1_0,
                                     (hw_device_t **)&mDevice);
        } else {
            ALOGI("CHAOZHUO_COLBY　在获得hw_device_t 时　，用的是open 接口") ;
            rc = module->open(mName.string(), (hw_device_t **)&mDevice);
            //mDevice 所有的操作都在这里
        }   
        if (rc != OK) {
            ALOGE("Could not open camera %s: %d", mName.string(), rc);
            return rc; 
        }   
        initHalPreviewWindow();
        return rc; 
    } 
```

使用hal的函数将通过这种方式使用：**mDevice->ops->**



上述函数中，主要注意以下流程：

1. 加粗的代码CameraHardwareInterface新建了了一个Camera硬件接口，当然，camera_device_name为摄像头设备名；  
2. mHardware->initialize(&module->common)调用底层硬件的初始化方法；  
3. mHardware->setCallbacks将CamerService处的回调函数注册到HAL处。

## 3.hal层分析

从这里开始分析

```c++
mHardware = new CameraHardwareInterface(camera_device_name);
    res = mHardware->initialize(module);
```

CameraHardwareInterface.h

```c++

```



```c++

```



### 3.1  找到hal层

CameraService.cpp

```c++
void CameraService::onFirstRef()
{
    camera_module_t *rawModule;
    int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,
            (const hw_module_t **)&rawModule);
    mModule = new CameraModule(rawModule);
    err = mModule->init();
}
```

### 3.2 camera_module_t

```c++
typedef struct camera_module {
    hw_module_t common;
    int (*get_number_of_cameras)(void);
    int (*get_camera_info)(int camera_id, struct camera_info *info);
    int (*set_callbacks)(const camera_module_callbacks_t *callbacks);
    void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops);
    int (*open_legacy)(const struct hw_module_t* module, const char* id,
            uint32_t halVersion, struct hw_device_t** device);
    int (*set_torch_mode)(const char* camera_id, bool enabled);
    int (*init)();
	void* reserved[5];
} camera_module_t;
```

### 3.3 hal层头

CameraHal.cpp

```c++
camera_module_t HAL_MODULE_INFO_SYM = {               
    common: {
         tag:           HARDWARE_MODULE_TAG,
         version_major: 1,
         version_minor: 0,
         id:            CAMERA_HARDWARE_MODULE_ID,
         name:          "Camera Module",
         author:        "The Android Open Source Project",
         methods:       &android::CameraFactory::mCameraModuleMethods,
         dso:           NULL,
         reserved:      {0},
    },  
    get_number_of_cameras:  android::CameraFactory::get_number_of_cameras,
    get_camera_info:        android::CameraFactory::get_camera_info,
};
```

CameraFactory.cpp

```c++
struct hw_module_methods_t CameraFactory::mCameraModuleMethods = {
    open: CameraFactory::device_open
};

int CameraFactory::device_open(const hw_module_t* module,
                                       const char* name,
                                       hw_device_t** device)
{
    int camera_id = atoi(name);
    return gCameraFactory.cameraDeviceOpen(module, camera_id, device);                                         
}

int CameraFactory::cameraDeviceOpen(const hw_module_t* module,int camera_id, hw_device_t** device)
{

    *device = NULL;

    if (!mCamera[camera_id]) {
        mCamera[camera_id] = new CameraHardware(module, mCameraDevices[camera_id]);
    }
    return mCamera[camera_id]->connectCamera(device);
}

status_t CameraHardware::connectCamera(hw_device_t** device)                  
{

    *device = &common;//找到了
    return NO_ERROR;
}
```





### 3.4 jni层的调用

```c++
//然而并不是在　这里调用的
//而是在 CameraHardwareInterface::initialize 中调用的，在上面有

int CameraModule::open(const char* id, struct hw_device_t** device) {            
    int res;
    ATRACE_BEGIN("camera_module->open");
    res = filterOpenErrorCode(mModule->common.methods->open(&mModule->common, id, device));
    ATRACE_END();
    return res;
}
```

### 3.5 hal 层方法集合

/home/colby/android_system_os/haier/hardware/libhardware/include/hardware/camera.h

```c++
typedef struct camera_device_ops {
    int (*set_preview_window)(struct camera_device *,
            struct preview_stream_ops *window);

    void (*set_callbacks)(struct camera_device *,
            camera_notify_callback notify_cb,
            camera_data_callback data_cb,
            camera_data_timestamp_callback data_cb_timestamp,
            camera_request_memory get_memory,
            void *user);

    void (*enable_msg_type)(struct camera_device *, int32_t msg_type);

    void (*disable_msg_type)(struct camera_device *, int32_t msg_type);

    int (*msg_type_enabled)(struct camera_device *, int32_t msg_type);

    int (*start_preview)(struct camera_device *);

    void (*stop_preview)(struct camera_device *);
    
    int (*preview_enabled)(struct camera_device *);
    
    int (*store_meta_data_in_buffers)(struct camera_device *, int enable);
    
    int (*start_recording)(struct camera_device *);
    
    void (*stop_recording)(struct camera_device *);
    
    int (*recording_enabled)(struct camera_device *);

    void (*release_recording_frame)(struct camera_device *,
                    const void *opaque);


    int (*auto_focus)(struct camera_device *);


    int (*cancel_auto_focus)(struct camera_device *);


    int (*take_picture)(struct camera_device *);


    int (*cancel_picture)(struct camera_device *);
                                                                                           
    int (*set_parameters)(struct camera_device *, const char *parms);
      char *(*get_parameters)(struct camera_device *);

    void (*put_parameters)(struct camera_device *, char *);

    int (*send_command)(struct camera_device *,
                int32_t cmd, int32_t arg1, int32_t arg2);

    void (*release)(struct camera_device *);

    int (*dump)(struct camera_device *, int fd);
} camera_device_ops_t;


typedef struct camera_device {                                                             
    hw_device_t common;//找到common就能找到　　camera_device_ops_t　了
    camera_device_ops_t *ops;
    void *priv;
} camera_device_t;
```

## 4. 带着问题分析：

### 4.1  getLegacyParameters

描述：Java层调用这个函数haier/frameworks/base/core/java/android/hardware/camera2/CameraManager.java

```java
public CameraCharacteristics getCameraCharacteristics(@NonNull String cameraId)
            throws CameraAccessException {
    String parameters = cameraService.getLegacyParameters(id);
}
```



这里猜测是调用hal层的 CameraHardware.cpp

```c++
camera_device_ops_t CameraHardware::mDeviceOps = {
    CameraHardware::set_preview_window,
    CameraHardware::set_callbacks,
    CameraHardware::enable_msg_type,
    CameraHardware::disable_msg_type,
    CameraHardware::msg_type_enabled,
    CameraHardware::start_preview,
    CameraHardware::stop_preview,
    CameraHardware::preview_enabled,
    CameraHardware::store_meta_data_in_buffers,
    CameraHardware::start_recording,
    CameraHardware::stop_recording,                                                                                   
    CameraHardware::recording_enabled,
    CameraHardware::release_recording_frame,
    CameraHardware::auto_focus,
    CameraHardware::cancel_auto_focus,
    CameraHardware::take_picture,
    CameraHardware::cancel_picture,
    CameraHardware::set_parameters,
    CameraHardware::get_parameters,//猜测调用这个函数
    CameraHardware::put_parameters,
    CameraHardware::send_command,
    CameraHardware::release,
    CameraHardware::dump
};
```

```c++
char* CameraHardware::get_parameters(struct camera_device* dev)                                                       
{
    CameraHardware* ec = reinterpret_cast<CameraHardware*>(dev->priv);
    if (ec == NULL) {
        ALOGE("%s: Unexpected NULL camera device", __FUNCTION__);
        return NULL;
    }
    return ec->getParameters();
}

char* CameraHardware::getParameters()
{   
    ALOGD("CHAOZHUO_COLBY CameraHardware::getParameters");
    String8 params;      
    {
        Mutex::Autolock lock(mLock);
        params = mParameters.flatten();//最主要的是这个
    }
    
    char* ret_str = reinterpret_cast<char*>(malloc(sizeof(char) * (params.length()+1)));
    memset(ret_str, 0, params.length()+1);
    if (ret_str != NULL) {    
        strncpy(ret_str, params.string(), params.length()+1);
        return ret_str;
    }
    
    ALOGE("%s: Unable to allocate string for %s", __FUNCTION__, params.string());
    /* Apparently, we can't return NULL fron this routine. */
    return &lNoParam;    
}
```

现在是追击，这个参数mParameters是从那来的，是从底层读取的还是从上层传递过来的：

```c++
CameraHardware::CameraHardware(const hw_module_t* module, char* devLocation) :
mParameters(),{
    ALOGD("CHAOZHUO_COLBY mParameters: 0.0 构造函数中 此时为空") ;
    
    /* Common header */
    common.tag = HARDWARE_DEVICE_TAG;
    common.version = 0;
    common.module = const_cast<hw_module_t*>(module);
    common.close = CameraHardware::close;

    /* camera_device fields. */
    ops = &mDeviceOps;
    priv = this;

    // Power on camera
    PowerOn();

    // Init default parameters
    initDefaultParameters();// 在构造CameraHardware的时候就会默认调用这个

}

void CameraHardware::initDefaultParameters()
{
    CameraParameters p;
    ALOGD("CHAOZHUO_COLBY mParameters: 0.1 设置默认的 参数，这里首先填充的是p") ;
    p.set(CameraParameters::KEY_SUPPORTED_ANTIBANDING,"auto");
    p.set(CameraParameters::KEY_ANTIBANDING,"auto");
    ...
      
    ALOGD("CHAOZHUO_COLBY mParameters: 0.2 默认p 的内容是: %s\n", p) ;
    if (setParameters(p.flatten()) != NO_ERROR) {                   
        ALOGE("CameraHardware::initDefaultParameters: Failed to set default parameters.");
    }
}

status_t CameraHardware::setParameters(const char* parms)
{
    ALOGD("CHAOZHUO_COLBY mParameters: 0.3 将新的params 保存在 mParameters 中 ") ;               mParameters = params;
}
```

现在关系很明确，是谁构造的CameraHardware对象呢?

现在我们要清楚一点**CameraHardware 是继承了 camera_device **

```c++
class CameraHardware : public camera_device {
    
}
typedef struct camera_device {                                                             
    hw_device_t common;
    camera_device_ops_t *ops;
    void *priv;
} camera_device_t;
```

从上面的关系中，我们就不难发现，当我们jni能找到 hw_device_t common;也就能找到 我们的 ops，也就能找到我们的CameraHardware

接下来就在 jni层中进行查找：



从日志中分析可知：我们的摄像头是没有 camera.power_file 这个文件的

```c++
//CameraHardware.cpp
#define CAMERA_POWER_FILE  "camera.power_file"
bool CameraHardware::PowerOn() {
	mCameraPowerFile = new char[PROPERTY_VALUE_MAX];
    if (!property_get(CAMERA_POWER_FILE, mCameraPowerFile, "")) {
        ALOGD("CameraHardware::PowerOn: no power_file set");//相机0 在这是对的，相机1在这就是有问题的
        delete [] mCameraPowerFile;
        mCameraPowerFile = 0; 
        return true;
    }
    
    ...
}
```

初步定位是 VIDIOC_ENUM_FMT ioctl有问题



## 5. 调试记录

### 5.1 脚本

```shell
cd ~/android_system_os/haier;source ./build/envsetup.sh;lunch android_x86_64-userdebug;make camera.x86

adb connect 192.168.1.45;adb root ; adb push out/target/product/x86_64/system/lib64/hw/camera.x86.so /system/lib64/hw/camera.x86.so

adb disconnect;adb connect 192.168.1.45;adb shell logcat | grep camera > ~/logcat.hair

adb disconnect;adb connect 192.168.1.45;adb shell stop ; sleep 2s; adb shell start
```



### 5.2  一个坑人的操作

在编译的时候，会自动打patch，导致新的修改会被丢弃

目录：/home/colby/android_system_os/haier/packages/apps/chaozhuo/CZApplyPatches/x86

修改方案：将对应的patch包，重新命名，让其找不到，

hardware_libcamera.patch 改为 hardware_libcamera_patch



### 5.3 摄像头参数

前置摄像头：

```shell
parameters=antibanding=auto;antibanding-values=auto;effect=none;effect-values=none;exposure-compensation=6;exposure-compensation-step=0.5;flash-mode=off;flash-mode-values=off;focal-length=4;focus-mode=fixed;focus-mode-values=fixed;horizontal-view-angle=90;jpeg-quality=85;jpeg-thumbnail-size-values=640x480,0x0;max-video-continuous-zoom=0;max-zoom=100;picture-format=jpeg;picture-format-values=jpeg;picture-size=0x0;picture-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;preferred-preview-size-for-video=640x480;preview-format=yuv422sp;preview-format-values=yuv422i-yuyv,yuv422sp,yuv420sp,yuv420p;preview-fps-range-values=;preview-frame-rate=0;preview-frame-rate-values=;preview-size=0x0;preview-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;rotation=0;rotation-values=0;scene-mode=auto;scene-mode-values=auto;smooth-zoom-supported=false;vertical-view-angle=90;video-frame-format=yuv420p;video-size=0x0;video-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320;whitebalance=auto;whitebalance-values=auto;zoom=0;zoom-ratios=100;zoom-supported=false
```

后置摄像头：

