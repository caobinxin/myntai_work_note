# hid 设备追踪记录

## 1. event 事件追踪

文件：hid-multitouch.c 

```c
static struct hid_driver mt_driver = {
    .name = "hid-multitouch",
    .id_table = mt_devices,
    .probe = mt_probe,
    .remove = mt_remove,
    .input_mapping = mt_input_mapping,
    .input_mapped = mt_input_mapped,
    .input_configured = mt_input_configured,
    .feature_mapping = mt_feature_mapping,                                                                                                                                                                         
    .usage_table = mt_grabbed_usages,
    .event = mt_event,
    .report = mt_report,
#ifdef CONFIG_PM_OFF
    .reset_resume = mt_reset_resume,
    .resume = mt_resume,
#endif
};

```

```c
static int mt_event(struct hid_device *hid, struct hid_field *field,                                                                                                                                               
                struct hid_usage *usage, __s32 value)
{
    struct mt_device *td = hid_get_drvdata(hid);

    if (field->report->id == td->mt_report_id)
        return mt_touch_event(hid, field, usage, value);

    return 0;
}

```

```c
static int mt_touch_event(struct hid_device *hid, struct hid_field *field,
                struct hid_usage *usage, __s32 value)
{
    /* we will handle the hidinput part later, now remains hiddev */
    if (hid->claimed & HID_CLAIMED_HIDDEV && hid->hiddev_hid_event)
        hid->hiddev_hid_event(hid, field, usage, value);
                                                                                                                                                                                                                   
    return 1;
}
```



找到hiddev_hid_event 的赋值的地方

```c
struct hid_device {                         /* device report descriptor */
    ...
        /* hiddev event handler */
    int (*hiddev_connect)(struct hid_device *, unsigned int);
    void (*hiddev_disconnect)(struct hid_device *);
    void (*hiddev_hid_event) (struct hid_device *, struct hid_field *field,          
                  struct hid_usage *, __s32);
    void (*hiddev_report_event) (struct hid_device *, struct hid_report *);
}
```



### 1.1 hid_device

谁创建的 hid_device 又是谁注册的hid_device

i2c-hid.c

```c
struct i2c_hid {
    struct i2c_client   *client;    /* i2c client */
    struct hid_device   *hid;   /* pointer to corresponding HID dev */     
}


static int i2c_hid_probe(struct i2c_client *client,
             const struct i2c_device_id *dev_id)
{
    int ret;
    struct i2c_hid *ihid;
    struct hid_device *hid;  
    
    ihid = kzalloc(sizeof(struct i2c_hid), GFP_KERNEL); 
    
    i2c_set_clientdata(client, ihid);//把ihid放到i2c_client->dev->driver_data 中
    
    ret = i2c_hid_init_irq(client); //上报数据的中断就是在这里处理的
    
    hid = hid_allocate_device();  
    
    ihid->hid = hid;
    
    ret = hid_add_device(hid);
    
    hid->driver_data = client;//在hid设备的driver_data　中记录了client                          
    hid->ll_driver = &i2c_hid_ll_driver;
    hid->dev.parent = &client->dev;
    hid->bus = BUS_I2C;
    hid->version = le16_to_cpu(ihid->hdesc.bcdVersion);
    hid->vendor = le16_to_cpu(ihid->hdesc.wVendorID);
    hid->product = le16_to_cpu(ihid->hdesc.wProductID);

}


//中断注册
static int i2c_hid_init_irq(struct i2c_client *client)
{
    struct i2c_hid *ihid = i2c_get_clientdata(client);
    unsigned long irqflags = 0;
    int ret;

    dev_dbg(&client->dev, "Requesting IRQ: %d\n", client->irq);

    if (!irq_get_trigger_type(client->irq))
        irqflags = IRQF_TRIGGER_LOW;

    ret = request_threaded_irq(client->irq, NULL, i2c_hid_irq,                                                                                                                                                     
                   irqflags | IRQF_ONESHOT, client->name, ihid);
    if (ret < 0) {
        dev_warn(&client->dev,
            "Could not register for %s interrupt, irq = %d,"
            " ret = %d\n",
            client->name, client->irq, ret);

        return ret;
    }

    return 0;
}


//中断处理程序
static irqreturn_t i2c_hid_irq(int irq, void *dev_id)                          
{
    struct i2c_hid *ihid = dev_id;
    printk(KERN_DEBUG"[chaozhuo] %s :  i2c_hid_get_input in...\n", __func__) ;

    if (test_bit(I2C_HID_READ_PENDING, &ihid->flags))
        return IRQ_HANDLED;

    printk(KERN_DEBUG"[chaozhuo] %s :  i2c_hid_get_input . before\n", __func__) ;
    i2c_hid_get_input(ihid);　//应该是在这上报的数据　而不是在hiddev_hid_event　中上报的，这里不在追　hiddev_hid_event函数，开始追　i2c_hid_get_input

    return IRQ_HANDLED;
}


struct hid_ll_driver i2c_hid_ll_driver = {
    .parse = i2c_hid_parse,
    .start = i2c_hid_start,
    .stop = i2c_hid_stop,
    .open = i2c_hid_open,
    .close = i2c_hid_close,
    .power = i2c_hid_power,
    .output_report = i2c_hid_output_report,
    .raw_request = i2c_hid_raw_request,
};

```



hid-core.c

```c
struct hid_device *hid_allocate_device(void)                                                                                                                                                                       
{
    struct hid_device *hdev;
    int ret = -ENOMEM;
    
    hdev = kzalloc(sizeof(*hdev), GFP_KERNEL);
    if (hdev == NULL)
        return ERR_PTR(ret);

    device_initialize(&hdev->dev);
    hdev->dev.release = hid_device_release;
    hdev->dev.bus = &hid_bus_type;
    device_enable_async_suspend(&hdev->dev);

    hid_close_report(hdev);

    init_waitqueue_head(&hdev->debug_wait);
    INIT_LIST_HEAD(&hdev->debug_list);
    spin_lock_init(&hdev->debug_list_lock);
    sema_init(&hdev->driver_input_lock, 1);
    mutex_init(&hdev->ll_open_lock);

    return hdev;
}
EXPORT_SYMBOL_GPL(hid_allocate_device);

```



### 1.2 i2c_hid_get_input

上报事件一般　是在中断中进行上报的

重点追i2c_hid_get_input　函数

```c
static void i2c_hid_get_input(struct i2c_hid *ihid){
    int ret, ret_size;
    int size = le16_to_cpu(ihid->hdesc.wMaxInputLength);

    ret = i2c_master_recv(ihid->client, ihid->inbuf, size);
    
    ret_size = ihid->inbuf[0] | ihid->inbuf[1] << 8;

    if (test_bit(I2C_HID_STARTED, &ihid->flags))
        hid_input_report(ihid->hid, HID_INPUT_REPORT, ihid->inbuf + 2,
                ret_size - 2, 1);

    return;
}

```



hid-core.c

```c
int hid_input_report(struct hid_device *hid, int type, u8 *data, int size, int interrupt)
{
	struct hid_report_enum *report_enum;
    struct hid_driver *hdrv;
    struct hid_report *report;
    int ret = 0; 
    
    report = hid_get_report(report_enum, data);
    
        if (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {                                                                                                                      
        //由于raw_event是空的，所以这里不会走　这里暂时做记录
        ret = hdrv->raw_event(hid, report, data, size);
        if (ret < 0)
            goto unlock;
    }       
	
    ret = hid_report_raw_event(hid, type, data, size, interrupt);
}



int hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,int interrupt)
｛
    struct hid_report_enum *report_enum = hid->report_enum + type;
    struct hid_report *report;
    struct hid_driver *hdrv;
    unsigned int a;
    int rsize, csize = size;                                                                                                                                                                                       
    u8 *cdata = data;
    int ret = 0;

	report = hid_get_report(report_enum, data);

	if (hid->claimed != HID_CLAIMED_HIDRAW && report->maxfield) {
        for (a = 0; a < report->maxfield; a++)
            hid_input_field(hid, report->field[a], cdata, interrupt);
        hdrv = hid->driver;
        if (hdrv && hdrv->report)
            hdrv->report(hid, report);　//这个是重点
    }

｝
```

回顾　hid_driver:　　hid-multitouch.c

```c
static struct hid_driver mt_driver = {
    .name = "hid-multitouch",
    .id_table = mt_devices,
    .probe = mt_probe,
    .remove = mt_remove,
    .input_mapping = mt_input_mapping,
    .input_mapped = mt_input_mapped,
    .input_configured = mt_input_configured,
    .feature_mapping = mt_feature_mapping,
    .usage_table = mt_grabbed_usages,
    .event = mt_event,                                                                                                                                                                                             
    .report = mt_report,
#ifdef CONFIG_PM_OFF
    .reset_resume = mt_reset_resume,
    .resume = mt_resume,
#endif
};

```

所以这里需要分析　mt_report

### 1.3 mt_report

hid-multitouch.c

```c
static void mt_report(struct hid_device *hid, struct hid_report *report)                   {
    struct mt_device *td = hid_get_drvdata(hid);
    struct hid_field *field = report->field[0];

    if (!(hid->claimed & HID_CLAIMED_INPUT))
        return;

    if (report->id == td->mt_report_id)
        return mt_touch_report(hid, report);//这个就是上报的地方

    if (field && field->hidinput && field->hidinput->input)
        input_sync(field->hidinput->input);//上报完同步一下
}


static void mt_touch_report(struct hid_device *hid, struct hid_report *report)
｛
    struct mt_device *td = hid_get_drvdata(hid);
    struct hid_field *field;                                                                                                                                                                                       
    unsigned count;
    int r, n;

｝
```

暂时在这里先告一段落，没有啥最终的结论



## 2. hid设备和input设备如何关联

hid-multitouch.c

```c
static struct hid_driver mt_driver = {
    .name = "hid-multitouch",
    .id_table = mt_devices,
    .probe = mt_probe,
    .remove = mt_remove,
    .input_mapping = mt_input_mapping,
    .input_mapped = mt_input_mapped,
    .input_configured = mt_input_configured,
    .feature_mapping = mt_feature_mapping,
    .usage_table = mt_grabbed_usages,
    .event = mt_event,
    .report = mt_report,
#ifdef CONFIG_PM_OFF
    .reset_resume = mt_reset_resume,
    .resume = mt_resume,
#endif
};                                                                                                                                                                                                                 
module_hid_driver(mt_driver);





static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
{
    int ret, i;                                                                                                                                                                                                    
    struct mt_device *td;
    struct mt_class *mtclass = mt_classes; /* MT_CLS_DEFAULT */
    
    td = devm_kzalloc(&hdev->dev, sizeof(struct mt_device), GFP_KERNEL);
    
    td->mtclass = *mtclass;
    td->inputmode = -1;
    td->maxcontact_report_id = -1;
    td->inputmode_value = MT_INPUTMODE_TOUCHSCREEN;
    td->cc_index = -1;
    td->mt_report_id = -1;
    
    hid_set_drvdata(hdev, td);//hdev->dev->driver_data = td
    
    td->fields = devm_kzalloc(&hdev->dev, sizeof(struct mt_fields),
                  GFP_KERNEL);
    
    ret = hid_parse(hdev);
    
#define HID_CONNECT_DEFAULT \ (HID_CONNECT_HIDINPUT|HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV|HID_CONNECT_FF)
    
    ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT); //重点
    mt_set_maxcontacts(hdev);
    mt_set_input_mode(hdev);
    
    devm_kfree(&hdev->dev, td->fields);
}


int hid_hw_start(struct hid_device *hdev, unsigned int connect_mask)                                                                                                                                               
{   
    int error; 

    error = hdev->ll_driver->start(hdev);
    
    
        error = hid_connect(hdev, connect_mask);//重点
        if (error) {
            hdev->ll_driver->stop(hdev);
            return error;
        }
    }   

    return 0;
}   

int hid_connect(struct hid_device *hdev, unsigned int connect_mask)
{
    if ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,
                connect_mask & HID_CONNECT_HIDINPUT_FORCE))
        hdev->claimed |= HID_CLAIMED_INPUT;
    
    ret = device_create_file(&hdev->dev, &dev_attr_country);
}

//hidinput_connect 重点分析这个，这个里面注册了一个input设备
int hidinput_connect(struct hid_device *hid, unsigned int force)
{
    struct hid_driver *drv = hid->driver;
    struct hid_report *report; 
    struct hid_input *next, *hidinput = NULL;                                                                                                                                                                      
    int i, k;
    
    hidinput = hidinput_match(report);
    hidinput_configure_usages(hidinput, report);
    input_register_device(hidinput->input);
    hidinput->registered = true;

}

```

先暂时分析到这，储备input的知识和i2c驱动的知识后，在来探个究竟

#### 2.1 小结

1. i2c设备加载　－》　i2c-hid.c　对应的驱动
2. i2c-hid.c 中有注册了hid_dev设备　－》　hid-multitouch.c
3. hid-multitouch.c　中有注册了　input_dev设备　－》　驱动没找到



## 3. 资料查询

### 3.1 input框架

