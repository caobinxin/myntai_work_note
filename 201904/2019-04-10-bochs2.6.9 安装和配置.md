# bochs2.6.9 安装和配置

## 1.参照资料

https://blog.csdn.net/chprain/article/details/79328673

https://www.jianshu.com/p/db3a62564b47

https://www.cnblogs.com/y724107196/p/4019586.html

https://blog.csdn.net/m0_37946085/article/details/82920664

https://blog.csdn.net/xiaoyi39/article/details/81094747

## 2. 下载并安装

### 2.1 准备

*Bochs 需要在 X11 环境下运行，因此你的 Linux 系统必须已经安装了X Window 系统才能使用Bochs。*

*因为 Bochs 是用C++写的，所以这里要安装GNU gcc/g++编译器。*
 *安装命令如下：*

```
sudo apt-get install build-essential 
sudo apt-get install g++ 
```

### 2.2 具体安装步骤:

1.先去[https://sourceforge.net/projects/bochs/files/](https://link.jianshu.com?t=https://sourceforge.net/projects/bochs/files/)
 下载 bochs-2.6.9.tar.gz

https://sourceforge.net/projects/bochs/files/bochs/2.6.9/

2.解压下载的源代码：

```
sudo tar zxvf bochs-2.6.9.tar.gz
```

3.进入bochs-2.6.9目录，运行configure脚本，它会测试你的机器，C/C++编译器以及一些库，用来判断何种配置适合于你的机器。运行：

```
sudo ./configure --enable-debugger --enable-disasm
```

（这两个是用来开启调试和反汇编功能）

配置出错：参照https://blog.csdn.net/geeker_12/article/details/11409009

“ERROR: X windows gui was selected, but X windows libraries were not found.

```shell
sudo apt-get install libx11-dev xserver-xorg-dev xorg-dev
```



4.第3步正确运行后，会产生一个Makefile文件，然后：

```
sudo make 
```

5.安装：

```
sudo make install 
```

至此，bochs安装已经结束。

------

### 2.3 编译安装过程中可能遇到的错误：

错误1：

> checking for default gui on this platform... x11
>
> ERROR: X windows gui was selected, but X windows libraries were not
>  found.

解决办法1：

```
sudo apt-get install xorg-dev  
```

错误2：

> ERROR: pkg-config was not found, or unable to access the gtk+-2.0
>  package.

解决办法2：

```
sudo apt-get install libgtk2.0-dev  
```

错误3：

> symbols: DSO missing  from command line collect2: error: ld returned 1 exit status

解决方法3：

在Makefile的LIBS中添加如下内容 ：

```
-lz -lrt -lm -lpthread 
```

------

错误４：

```shell
x.cc:42:10: fatal error: X11/extensions/Xrandr.h: 没有那个文件或目录
 #include <X11/extensions/Xrandr.h>
```





成功安装完成后能在命令行终端中输入 bochs 看到 bochs ：



安装完成后

------

## 3. 运行简单的Linux

先制作软盘

编译以后的 bochs2.6.9 文件夹下会有一个 bximage 可执行文件,在终端运行：

按步骤先做一个软盘：

制作软盘

![](2019-04-10-bochs2.6.9 安装和配置.assets/bochs-bximage-floppy0.png)

![](2019-04-10-bochs2.6.9 安装和配置.assets/chengyang_img_size.png)



然后写入一个系统镜像,镜像文件可以去下载

[http://www.oldlinux.org/Linux.old/images/bootroot-0.11](https://link.jianshu.com?t=http://www.oldlinux.org/Linux.old/images/bootroot-0.11)

这个是linux0.11的镜像文件

然后在终端执行命令把镜像写入我们制作的软盘:

```
dd if=/home/jack/Downloads/bootroot-0.11 of=a.img 
```

if 是下载的镜像所在的位置 ，of 是你软盘所在的路径。

写入镜像

![](2019-04-10-bochs2.6.9 安装和配置.assets/写入镜像.png)



接下来是处理配置文件:
 通过 *ls - a* 能看到原始的 .bochsrc 来参考，不过是全英文的（_!!一点都不友善）。

新建一个配置文件：

.cybochsrc 配置文件

```shell
memory: guest=256,host=128
romimage: file=/usr/local/share/bochs/BIOS-bochs-latest
floppya: 1_44=chenyang.img, status=inserted
ata0: enabled=1,ioaddr1=0x1f0, ioaddr2=0x3f0,irq=14
boot: floppy
log: bochslog.txt
mouse: enabled=0
```

要能在 Bochs 中运行一个操作系统，至少需要以下一些资源或信息：

- Bochs执行文件

- BIOS映像文件（通常称为BIOS-bochs-latest）

- VGA BIOS映像文件（例如VGABIOS-lgpl-latest）

- 至少一个引导启动磁盘映像文件（软盘，硬盘或CDROM的映像文件）
   我的配置如下:



  配置

在命令行终端输入：

```
./bochs -f ./.cybochsrc
```

记得自己改文件位置，不要复制粘帖。

然后会出现运行界面

![](2019-04-10-bochs2.6.9 安装和配置.assets/启动指定配置的虚拟机.png)

按完6回车 会出现

快成功

虽然是黑屏，当你在命令行终端输入c回车后，世界还是很美好的。

成功

![](2019-04-10-bochs2.6.9 安装和配置.assets/成功运行虚拟机.png)

## 4. 运行简单汇编

```assembly
org 0x7c00 ;汇编地址从0x7c00开始
;我们知道BIOS固件(BIOS ROM)会把我们的程序加载到0x7c00物理地址处开始执行.

mov ax,0xb800  ;显存段地址
mov ds,ax

xor bx,bx
mov byte [bx],'h'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'e'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'l'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'l'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'o'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],','  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx

mov byte [bx],'w'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'o'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'r'  ;字符
inc bx
mov byte [bx],2   ;字符属性
inc bx
mov byte [bx],'d'  ;字符
inc bx
mov byte [bx],2   ;字符属性
; $当前汇编地址
jmp $

; $$ 开始汇编地址 ,为了确保512字节对齐
; 因为我们要写入主引导扇区才能运行
;主引导扇区最后两个字符为0x55,0xaa
;times 重复多少次 比如:times 10 db 1 ;重复10次 db 1
times  510-($-$$) db 0
db 0x55,0xaa

```





## 5. 运行自己写的os

格式话fat12

![](2019-04-10-bochs2.6.9 安装和配置.assets/格式化为fat12格式.png)

```shell
sudo mount -t vfat -o loop boot.img /mnt/boot/
```

![](2019-04-10-bochs2.6.9 安装和配置.assets/写入boot_img.png)

https://www.cnblogs.com/pacoson/p/4816614.html

https://blog.csdn.net/czg13548930186/article/details/78608034





```shell
 2099  dd if=/dev/zero of=boot.img bs=512 count=2880
 2102  sudo losetup /dev/loop9 boot.img
 2103  sudo mkdosfs -F 12 /dev/loop9
 2104  dd if=../OS-Physical-Platform/LegacyBootLoader/boot.bin of=boot.img bs=512 count=1 conv=notrunc
 2106  sudo mount /dev/loop9 /mnt/boot/ -t msdos -o "fat=12"
 2109  bochs -f .osbochsrc

```

## 6. 第二次编译安装bochs 遇到的坑

### 6.1 将cpp 文件改为cc

这里我首先没有用官网压缩包的源码去编译，而是用的我在github中保存的code.　第一次解压后的代码，上传上去的。

在编译的时候，不断提示我找不到*.cc文件，让我一个个去改。由于我之前也编译安装过bochs，感觉也没有如此麻烦。

抱着这个怀疑的态度：　我有从官网上下载了压缩包：

结果发现，里面基本都是　cc文件，而没有cpp文件，所以这里基本不用去收到该文件的后缀名字。

**所以每次安装的时候，还是从官方去下载，最为保险：**

### 6.2 编译

由于在编译的时候，直接用的是　make，　发现报大量　html 中的　这个那个符号没有定义：

后来发现：　用 sudo make 就灭有问题了

### 6.3 配置文件

这个是启动的时候，-f 指定的配置文件

```shell
romimage: file=/usr/local/share/bochs/BIOS-bochs-latest
```

要单独找到　BIOS-bochs-latest　所在的路径，　填在上面

```shell
floppya: 1_44=linux0_1.img, status=inserted
```

linux0_1.img　就是我们要启动的镜像

### 6.4 在编译之前的配置文件

```shell
sudo ./configure --with-x11 --with-wx --enable-debugger --enable-disasm --enable-all-optimizations --enable-readline --enable-long-phy-address --enable-ltdl-install --enable-idle-hack --enable-plugins --enable-a20-pin --enable-x86-64 --enable-smp --enable-cpu-level=6 --enable-large-ramfile --enable-repeat-speedups --enable-fast-function-calls  --enable-handlers-chaining  --enable-trace-linking --enable-configurable-msrs --enable-show-ips --enable-cpp --enable-debugger-gui --enable-iodebug --enable-logging --enable-assert-checks --enable-fpu --enable-vmx=2 --enable-svm --enable-3dnow --enable-alignment-check  --enable-monitor-mwait --enable-avx  --enable-evex --enable-x86-debugger --enable-pci --enable-usb --enable-voodoo
```

```shell
sudo make;

		cp misc/bximage.cpp misc/bximage.cc
 2040  cp ./iodev/hdimage/hdimage.cpp ./iodev/hdimage/hdimage.cc

 2042  cp iodev/hdimage/vmware3.cpp iodev/hdimage/vmware3.cc

 2044  cp iodev/hdimage/vmware4.cpp iodev/hdimage/vmware4.cc

 2046  cp iodev/hdimage/vpc-img.cpp iodev/hdimage/vpc-img.cc

 2048  cp iodev/hdimage/vbox.cpp iodev/hdimage/vbox.cc
 
 
sudo make install
```

这里直接使用的是　cp 而不是 mv

### 6.5 bochs源码还是有问题：

当我　按照6.4中的配置，　去配置编译安装，运行的时候，还是会报错：

dlopen failed for module 'usb_uhci' (libbx_usb_uhci.so): file not found



从网上找的资料说，这个新版本的bochs中自己存在的bug,所以代码的版本还是不对。

根据网友的记录，参考链接：https://blog.csdn.net/Asdfffy/article/details/84035543

下载代码：找到了版本号 有问题的童鞋们用这个版本吧

```shell
svn checkout -r r13534 http://svn.code.sf.net/p/bochs/code/trunk/bochs bochs
```

经过cbx本人的测试，确实是可以的。

------



**题外话：**

如果你看到这篇博文,那么我猜你很可能是<一个64位操作系统的设计与实现>的读者之一.在刚要起步的时候就遇到小坑. 不知道你什么感觉,我是有点难受的 = =|||

我的运行环境: Ubuntu 18.04, bochs 2.6.9

我的 bochs 是当前最新(发布时间 2017-04-09)的源码编译来的,出错的原因很奇葩... 官方提供的下载包里'usb_uhci'插件存在无法解析的符号,而且这个问题在三年前的 2.6.8 版本中就出现过了,解决的方法很简单,使用 SVN 获取最新的 bochs 版本然后编译安装即可.

```shell
svn co http://svn.code.sf.net/p/bochs/code/trunk/bochs bochs
```

拉取过程中可能会报错中断,只需要根据提示进入拉取的 bochs 目录下,执行  "svn cleanup" 命令解除锁后退回上一级目录再次拉取即可.



**这里要不直接从官网下载　2.6.8 的版本吧：**