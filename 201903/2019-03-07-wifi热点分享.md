# wifi热点分享

FireNow-Nougat/packages/apps/Settings/src/com/android/settings/wifi$ vim WifiApDialog.java +128



wifi 密码所在的文件在

rk3399_firefly_box:/data/misc/wifi # cat wpa_supplicant.conf



wifi热点所在的文件

```sh
rk3399_firefly_box:/data/misc/wifi # cat hostapd.conf
interface=wlan0
driver=nl80211
ctrl_interface=/data/misc/wifi/hostapd
ssid=wifiredian
channel=11
ieee80211n=1
hw_mode=g
ignore_broadcast_ssid=0
wowlan_triggers=any
wpa=2
rsn_pairwise=CCMP
wpa_psk=4972d609b51b68988d1e501ee0e230a47df3633370454e5efa50b26afc94b78d
rk3399_firefly_box:/data/misc/wifi # 


rk3399_firefly_box:/data/misc/wifi # cat softap.conf                           

wifiredian	123456789

rk3399_firefly_box:/data/misc/wifi # 
```







## 1. 分析

```sh


```



```java

```



```xml


```

1.根据中文去找对应大key－>value

packages/apps/Settings/res$ vim values-zh-rCN/strings.xml +819

```java
<string name="wifi_tether_checkbox_text" msgid="1847167643625779136">"便携式WLAN热点"</string>
```

思路：根据界面的子去找对应的 key->value,然后在深入分析。

packages/apps/Settings/res/xml$ vim tether_prefs.xml +25

```xml
<SwitchPreference
        android:key="enable_wifi_ap"
        android:title="@string/wifi_tether_checkbox_text" />
```

vim TetherSettings.java +179

```java
private static final String ENABLE_WIFI_AP = "enable_wifi_ap";

mEnableWifiAp =
                (SwitchPreference) findPreference(ENABLE_WIFI_AP);

mWifiApEnabler = new WifiApEnabler(activity, mDataSaverBackend, mEnableWifiAp); 
```

```sh
FireNow-Nougat/packages/apps/Settings/src/com/android/settings$ grep -inR WifiApEnabler
wifi/WifiApEnabler.java:35:public class WifiApEnabler {
wifi/WifiApEnabler.java:75:    public WifiApEnabler(Context context, DataSaverBackend dataSaverBackend,
TetherSettings.java:46:import com.android.settings.wifi.WifiApEnabler;
TetherSettings.java:76:    private WifiApEnabler mWifiApEnabler;
TetherSettings.java:179:            mWifiApEnabler = new WifiApEnabler(activity, mDataSaverBackend, mEnableWifiAp);
TetherSettings.java:364:        if (mWifiApEnabler != null) {
TetherSettings.java:366:            mWifiApEnabler.resume();
TetherSettings.java:382:        if (mWifiApEnabler != null) {
TetherSettings.java:384:            mWifiApEnabler.pause();
colby@colby-myntai:~/androidos/bottom_layer_work/FireNow-Nougat/packages/apps/Settings/src/com/android/settings$ vim TetherSettings.java +179

```







现在重点分析TetherSettings.java文件



描述：

3399上电开机：

状态：wifi 关闭　wifi热点关闭

操作：手动在settings界面点击　wifi热点共享

函数调用关系如下：

```sh
03-08 15:07:38.126  1888  1888 D TetheringSettings:  onCreate
03-08 15:07:38.147  1888  1888 D TetheringSettings:  onDataSaverChanged
03-08 15:07:38.147  1888  1888 D TetheringSettings: 3.1 mDataSaverEnabled = false
03-08 15:07:38.159  1888  1888 D TetheringSettings: 1. new WifiApEnabler
03-08 15:07:38.162  1888  1888 D TetheringSettings:  initWifiTethering
03-08 15:07:38.162  1888  1888 D TetheringSettings: 1.1 getWifiApConfiguration
03-08 15:07:38.165  1888  1888 D TetheringSettings: 1.3 mWifiConfig != null
03-08 15:07:38.167  1888  1888 D TetheringSettings: 3. onDataSaverChanged
03-08 15:07:38.167  1888  1888 D TetheringSettings:  onDataSaverChanged
03-08 15:07:38.168  1888  1888 D TetheringSettings: 3.1 mDataSaverEnabled = false
03-08 15:07:38.214  1888  1888 D TetheringSettings:  onStart
03-08 15:07:38.226  1888  1888 D TetheringSettings:  注册 WIFI_AP_STATE_CHANGED_ACTION
03-08 15:07:38.231  1888  1888 D TetheringSettings: mEnableWifiAp.setOnPreferenceChangeListener
03-08 15:07:38.233  1888  1888 D TetheringSettings:  updateState
03-08 15:07:38.233  1888  1888 D TetheringSettings:  updateState
03-08 15:07:38.241  1888  1888 D TetheringSettings:  getMetricsCategory
03-08 15:07:38.385  1888  1888 D TetheringSettings:  onReceive
03-08 15:07:38.385  1888  1888 D TetheringSettings:  updateState
03-08 15:07:41.092  1888  1888 D TetheringSettings:  onPreferenceChange
03-08 15:07:41.092  1888  1888 D TetheringSettings:  startTethering
03-08 15:07:41.113  1888  1888 D TetheringSettings: onPreferenceTreeClick
03-08 15:07:41.116  1888  1888 D TetheringSettings:  onTetheringStarted
03-08 15:07:41.117  1888  1888 D TetheringSettings:  updateState
03-08 15:07:42.036  1888  1888 D TetheringSettings:  onReceive
03-08 15:07:42.036  1888  1888 D TetheringSettings:  WIFI_AP_STATE_CHANGED_ACTION
03-08 15:07:42.066  1888  1888 D TetheringSettings:  onReceive
03-08 15:07:42.066  1888  1888 D TetheringSettings:  ACTION_TETHER_STATE_CHANGED
03-08 15:07:42.280  1888  1888 D TetheringSettings:  onReceive
03-08 15:07:42.280  1888  1888 D TetheringSettings:  WIFI_AP_STATE_CHANGED_ACTION
03-08 15:07:42.424  1888  1888 D TetheringSettings:  onReceive
03-08 15:07:42.424  1888  1888 D TetheringSettings:  ACTION_TETHER_STATE_CHANGED




03-08 15:15:45.162  1888  1888 D TetheringSettings:  onPreferenceChange
03-08 15:15:45.162  1888  1888 D TetheringSettings:  startTethering
03-08 15:15:45.181  1888  1888 D TetheringSettings: onPreferenceTreeClick
03-08 15:15:45.183  1888  1888 D TetheringSettings:  onTetheringStarted
03-08 15:15:45.183  1888  1888 D TetheringSettings:  updateState
03-08 15:15:46.137  1888  1888 D TetheringSettings:  onReceive
03-08 15:15:46.137  1888  1888 D TetheringSettings:  WIFI_AP_STATE_CHANGED_ACTION
03-08 15:15:46.391  1888  1888 D TetheringSettings:  onReceive
03-08 15:15:46.391  1888  1888 D TetheringSettings:  WIFI_AP_STATE_CHANGED_ACTION
03-08 15:15:46.488  1888  1888 D TetheringSettings:  onReceive
03-08 15:15:46.488  1888  1888 D TetheringSettings:  ACTION_TETHER_STATE_CHANGED

```



通过调用发现最主要是调用了：

```java
private ConnectivityManager mCm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); 

startTethering(TETHERING_WIFI);
--> mCm.startTethering(choice, true, mStartTetheringCallback, mHandler);
```

```sh
FireNow-Nougat/frameworks$ vim ./base/core/java/android/net/ConnectivityManager.java
```

现在重点分析：ConnectivityManager.java

```java
private final IConnectivityManager mService;
mService = checkNotNull(service, "missing IConnectivityManager");//在1819行


public void startTethering(int type, boolean showProvisioningUi,
            final OnStartTetheringCallback callback, Handler handler) {
        ResultReceiver wrappedCallback = new ResultReceiver(handler) {
            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                if (resultCode == TETHER_ERROR_NO_ERROR) {
                    callback.onTetheringStarted();
                } else {
                    callback.onTetheringFailed();
                }
            }
        };                                                                                                                                                    
        try {
            mService.startTethering(type, wrappedCallback, showProvisioningUi);//走这儿
        } catch (RemoteException e) {
            Log.e(TAG, "Exception trying to start tethering.", e);
            wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, null);
        }
    }


```

```sh
FireNow-Nougat/frameworks/base/services/core/java/com/android/server$ vim ConnectivityService.java
//在这里找到了　startTethering
```

```java
private Tethering mTethering; 
mTethering = new Tethering(mContext, mNetd, statsService, mPolicyManager);

public void startTethering(int type, ResultReceiver receiver,                                                                                             
            boolean showProvisioningUi) {
        ConnectivityManager.enforceTetherChangePermission(mContext);
        if (!isTetheringSupported()) {
            receiver.send(ConnectivityManager.TETHER_ERROR_UNSUPPORTED, null);
            return;
        }
        mTethering.startTethering(type, receiver, showProvisioningUi);//走这儿
    }    

```

```sh
frameworks/base/services/core/java/com/android/server/connectivity$ vim Tethering.java
```

```java
public void startTethering(int type, ResultReceiver receiver,                                                                                             
            boolean showProvisioningUi) {
        if (!isTetherProvisioningRequired()) {
            enableTetheringInternal(type, true, receiver);
            return;
        }

        if (showProvisioningUi) {
            runUiTetherProvisioningAndEnable(type, receiver);//暂时先分析这个　showProvisioningUi　＝＝　ture
        } else {
            runSilentTetherProvisioningAndEnable(type, receiver);
        }
    }    


private void runUiTetherProvisioningAndEnable(int type, ResultReceiver receiver) {                                                                        
        ResultReceiver proxyReceiver = getProxyReceiver(type, receiver);
        sendUiTetherProvisionIntent(type, proxyReceiver);
    }

private void runSilentTetherProvisioningAndEnable(int type, ResultReceiver receiver) {
        ResultReceiver proxyReceiver = getProxyReceiver(type, receiver);                                                                                      
        sendSilentTetherProvisionIntent(type, proxyReceiver);
    }    


private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
        ResultReceiver rr = new ResultReceiver(null) {
            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                // If provisioning is successful, enable tethering, otherwise just send the error.
                if (resultCode == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                    enableTetheringInternal(type, true, receiver);                                                                                            
                } else {
                    sendTetherResult(receiver, resultCode);
                }    
            }
        };

    
    private void enableTetheringInternal(int type, boolean enable, ResultReceiver receiver) {
        boolean isProvisioningRequired = enable && isTetherProvisioningRequired();
        int result;
        switch (type) {
            case ConnectivityManager.TETHERING_WIFI:
                result = setWifiTethering(enable);
                if (isProvisioningRequired && result == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                    scheduleProvisioningRechecks(type);
                }
                sendTetherResult(receiver, result);
                break;
            case ConnectivityManager.TETHERING_USB:
                result = setUsbTethering(enable);
                if (isProvisioningRequired && result == ConnectivityManager.TETHER_ERROR_NO_ERROR) {
                    scheduleProvisioningRechecks(type);
                }
                sendTetherResult(receiver, result);
                break;
            case ConnectivityManager.TETHERING_BLUETOOTH:
                setBluetoothTethering(enable, receiver);
                break;
            default:
                Log.w(TAG, "Invalid tether type.");
                sendTetherResult(receiver, ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE);
        }
    } 
    
    
private int setWifiTethering(final boolean enable) {
        synchronized (mPublicSync) {
            mWifiTetherRequested = enable;
            final WifiManager wifiManager =
                    (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
            if (wifiManager.setWifiApEnabled(null /* use existing wifi config */, enable)) {
                return ConnectivityManager.TETHER_ERROR_NO_ERROR;
            }
            return ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
        }
    }

```



```sh
colby@colby-myntai:~/androidos/bottom_layer_work/FireNow-Nougat/frameworks$ find -name WifiManager.java
./base/wifi/java/android/net/wifi/WifiManager.java
```

```java
IWifiManager mService;

public WifiManager(Context context, IWifiManager service, Looper looper) {
        mContext = context;
        mService = service;                                                                                                                                   
        mLooper = looper;
        mTargetSdkVersion = context.getApplicationInfo().targetSdkVersion;
    }


public boolean setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) {
        try {
            mService.setWifiApEnabled(wifiConfig, enabled);                                                                                                   
            return true;
        } catch (RemoteException e) { 
            throw e.rethrowFromSystemServer();
        }
    }    

```

### 修改思路一

```sh
frameworks$ vim ./opt/net/wifi/service/java/com/android/server/wifi/WifiServiceImpl.java
```

```java
//这里居然找到这个：

public void factoryReset() {
        enforceConnectivityInternalPermission();

        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
            return;
        }

        if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
            // Turn mobile hotspot off
            setWifiApEnabled(null, false);　　－－－》将这里改成　setWifiApEnabled（null, true）; 试试
        }

        if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
            // Enable wifi
            setWifiEnabled(true);                                                                                                                             
            // Delete all Wifi SSIDs
            List<WifiConfiguration> networks = getConfiguredNetworks();
            if (networks != null) {
                for (WifiConfiguration config : networks) {
                    removeNetwork(config.networkId);
                }
                saveConfiguration();
            }
        }
    }


public void setWifiApEnabled(WifiConfiguration wifiConfig, boolean enabled) {                                                                             
        enforceChangePermission();
        ConnectivityManager.enforceTetherChangePermission(mContext);
        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
            throw new SecurityException("DISALLOW_CONFIG_TETHERING is enabled for this user.");
        }
        // null wifiConfig is a meaningful input for CMD_SET_AP
        if (wifiConfig == null || isValid(wifiConfig)) {
            mWifiController.obtainMessage(CMD_SET_AP, enabled ? 1 : 0, 0, wifiConfig).sendToTarget();
        } else {
            Slog.e(TAG, "Invalid WifiConfiguration");
        }
    }    

```



修改后的结果：

```java
public void factoryReset() {
        enforceConnectivityInternalPermission();

        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
            return;
        }

        //colbycao caobinxin 2019-03-08 修改

        /*
        if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
            // Turn mobile hotspot off
            setWifiApEnabled(null, false);
        } */

        Log.d("wifiap", "factory -> setWifiApEnabled(null, true)") ;                                                                                          
        setWifiApEnabled(null, true) ;
        if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
            // Enable wifi
            setWifiEnabled(true);
            // Delete all Wifi SSIDs
            List<WifiConfiguration> networks = getConfiguredNetworks();
            if (networks != null) {
                for (WifiConfiguration config : networks) {
                    removeNetwork(config.networkId);
                }
                saveConfiguration();
            }
        }
    }

```

验证这种修改是不器作用的，有可能加的位置有问题，这个函数压根就没执行。将代码还原

### 修改思路二

vim faramwork/opt/net/wifi/service/java/com/android/server/wifi/WifiService.java

```java
@Override
    public void onBootPhase(int phase) {                                                                                                                      
        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
            mImpl.checkAndStartWifi();
        }   
    }   
```



```sh
rk3399_firefly_box:/ $ logcat | grep WifiService
03-08 18:38:39.974   457   457 I SystemServiceManager: Starting com.android.server.wifi.WifiService
03-08 18:38:40.379   457   457 I WifiService: WifiService starting up with Wi-Fi disabled
03-08 18:38:43.464   457   659 D WifiService: New client listening to asynchronous messages

```

vim WifiServiceImpl.java

```java
    public void checkAndStartWifi() {
        /* Check if wi-fi needs to be enabled */
        boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
        Slog.i(TAG, "WifiService starting up with Wi-Fi " +
                (wifiEnabled ? "enabled" : "disabled"));  //这里显示，wifienabled = false,所以这里是不开启ＷｉＦｉ的

        registerForScanModeChange();
        mContext.registerReceiver(
                new BroadcastReceiver() {
                    @Override
                    public void onReceive(Context context, Intent intent) {
                        if (mSettingsStore.handleAirplaneModeToggled()) {
                            mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
                        }
                        if (mSettingsStore.isAirplaneModeOn()) {
                            Log.d(TAG, "resetting country code because Airplane mode is ON");
                            mCountryCode.airplaneModeEnabled();
                        }
                    }
                },
                new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));

        mContext.registerReceiver(
                new BroadcastReceiver() {
                    @Override
                    public void onReceive(Context context, Intent intent) {
                        String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
                        if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                            Log.d(TAG, "resetting networks because SIM was removed");
                            mWifiStateMachine.resetSimAuthNetworks(false);
                            Log.d(TAG, "resetting country code because SIM is removed");
                            mCountryCode.simCardRemoved();
                        } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                            Log.d(TAG, "resetting networks because SIM was loaded");
                            mWifiStateMachine.resetSimAuthNetworks(true);                                                                                     
                        }
                    }
                },
                new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));

        // Adding optimizations of only receiving broadcasts when wifi is enabled
        // can result in race conditions when apps toggle wifi in the background
        // without active user involvement. Always receive broadcasts.
        registerForBroadcasts();
        registerForPackageOrUserRemoval();
        mInIdleMode = mPowerManager.isDeviceIdleMode();

        mWifiController.start();

        // If we are already disabled (could be due to airplane mode), avoid changing persist
        // state here
        if (wifiEnabled) setWifiEnabled(wifiEnabled);
    }

```

既然开始启动的时候调用了这个，我们可以在这里启动　wifi热点共享

修改代码：

```java
public void checkAndStartWifi() {
    ...
       if (wifiEnabled) setWifiEnabled(wifiEnabled);
                                                                                                                                                              
        //caobinxin colbycao add here 2019-03-11 11:23
        if(true){
        
            setWifiApEnabled(null, true);
        }

}
```

测试结果是　wifi热点是可以打开。而且可以正常的将数据分享出去









## 2. 额外补充

### 1.测试案例

```sh
frameworks$ vim ./base/core/tests/ConnectivityManagerTest/src/com/android/connectivitymanagertest/unit/WifiSoftAPTest.java


```

```java
package com.android.connectivitymanagertest.unit;

import android.content.Context;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;

import android.test.suitebuilder.annotation.LargeTest;
import android.test.AndroidTestCase;

import android.util.Log;

/**
 * Test Wifi soft AP configuration
 */
public class WifiSoftAPTest extends AndroidTestCase {

    private WifiManager mWifiManager;
    private WifiConfiguration mWifiConfig = null;
    private final String TAG = "WifiSoftAPTest";
    private final int DURATION = 10000;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(mWifiManager);
        assertTrue(mWifiManager.setWifiApEnabled(null, true));
        mWifiConfig = mWifiManager.getWifiApConfiguration();
        if (mWifiConfig != null) {
            Log.v(TAG, "mWifiConfig is " + mWifiConfig.toString());
        } else {
            Log.v(TAG, "mWifiConfig is null.");
        }
    }

    @Override
    protected void tearDown() throws Exception {
        Log.v(TAG, "turn off wifi tethering");
        mWifiManager.setWifiApEnabled(null, false);
        super.tearDown();
    }

    // Test case 1: Test the soft AP SSID with letters
    @LargeTest
    public void testApSsidWithAlphabet() {
        WifiConfiguration config = new WifiConfiguration();
        config.SSID = "abcdefghijklmnopqrstuvwxyz";
        config.allowedKeyManagement.set(KeyMgmt.NONE);
        mWifiConfig = config;
        assertTrue(mWifiManager.setWifiApEnabled(mWifiConfig, true));
        try {
            Thread.sleep(DURATION);
        } catch (InterruptedException e) {
            Log.v(TAG, "exception " + e.getStackTrace());
            assertFalse(true);
        }
        assertNotNull(mWifiManager.getWifiApConfiguration());
        assertEquals("wifi AP state is not enabled", WifiManager.WIFI_AP_STATE_ENABLED,
                     mWifiManager.getWifiApState());
    }
}
```

### 2.wifi热点配置加载

```sh
colby@colby-myntai:~/androidos/bottom_layer_work/FireNow-Nougat/frameworks$ vim ./opt/net/wifi/service/java/com/android/server/wifi/WifiApConfigStore.java
```



```java
package com.android.server.wifi;

import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.os.Environment;
import android.util.Log;

import com.android.internal.R;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Provides API for reading/writing soft access point configuration.
 */
public class WifiApConfigStore {

    private static final String TAG = "WifiApConfigStore";

    private static final String DEFAULT_AP_CONFIG_FILE =
            Environment.getDataDirectory() + "/misc/wifi/softap.conf";

    private static final int AP_CONFIG_FILE_VERSION = 2;

    private WifiConfiguration mWifiApConfig = null;

    private ArrayList<Integer> mAllowed2GChannel = null;

    private final Context mContext;
    private final String mApConfigFile;
    private final BackupManagerProxy mBackupManagerProxy;

    WifiApConfigStore(Context context, BackupManagerProxy backupManagerProxy) {
        this(context, backupManagerProxy, DEFAULT_AP_CONFIG_FILE);
    }

    WifiApConfigStore(Context context,
                      BackupManagerProxy backupManagerProxy,
                      String apConfigFile) {
        mContext = context;
        mBackupManagerProxy = backupManagerProxy;
        mApConfigFile = apConfigFile;

        String ap2GChannelListStr = mContext.getResources().getString(
                R.string.config_wifi_framework_sap_2G_channel_list);
        Log.d(TAG, "2G band allowed channels are:" + ap2GChannelListStr);

        if (ap2GChannelListStr != null) {
            mAllowed2GChannel = new ArrayList<Integer>();
            String channelList[] = ap2GChannelListStr.split(",");
            for (String tmp : channelList) {
                mAllowed2GChannel.add(Integer.parseInt(tmp));
            }
        }

        /* Load AP configuration from persistent storage. */
        mWifiApConfig = loadApConfiguration(mApConfigFile);
        if (mWifiApConfig == null) {
            /* Use default configuration. */
            Log.d(TAG, "Fallback to use default AP configuration");
            mWifiApConfig = getDefaultApConfiguration();

            /* Save the default configuration to persistent storage. */
            writeApConfiguration(mApConfigFile, mWifiApConfig);
        }
    }

    /**
     * Return the current soft access point configuration.
     */
    public synchronized WifiConfiguration getApConfiguration() {
        return mWifiApConfig;
    }

    /**
     * Update the current soft access point configuration.
     * Restore to default AP configuration if null is provided.
     * This can be invoked under context of binder threads (WifiManager.setWifiApConfiguration)
     * and WifiStateMachine thread (CMD_START_AP).
     */
    public synchronized void setApConfiguration(WifiConfiguration config) {
        if (config == null) {
            mWifiApConfig = getDefaultApConfiguration();
        } else {
            mWifiApConfig = config;
        }
        writeApConfiguration(mApConfigFile, mWifiApConfig);

        // Stage the backup of the SettingsProvider package which backs this up
        mBackupManagerProxy.notifyDataChanged();
    }

    public ArrayList<Integer> getAllowed2GChannel() {
        return mAllowed2GChannel;
    }

    /**
     * Load AP configuration from persistent storage.
     */
    private static WifiConfiguration loadApConfiguration(final String filename) {
        WifiConfiguration config = null;
        DataInputStream in = null;
        try {
            config = new WifiConfiguration();
            in = new DataInputStream(
                    new BufferedInputStream(new FileInputStream(filename)));

            int version = in.readInt();
            if ((version != 1) && (version != 2)) {
                Log.e(TAG, "Bad version on hotspot configuration file");
                return null;
            }
            config.SSID = in.readUTF();

            if (version >= 2) {
                config.apBand = in.readInt();
                config.apChannel = in.readInt();
            }

            int authType = in.readInt();
            config.allowedKeyManagement.set(authType);
            if (authType != KeyMgmt.NONE) {
                config.preSharedKey = in.readUTF();
            }
        } catch (IOException e) {
            Log.e(TAG, "Error reading hotspot configuration " + e);
            config = null;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    Log.e(TAG, "Error closing hotspot configuration during read" + e);
                }
            }
        }
        return config;
    }

    /**
     * Write AP configuration to persistent storage.
     */
    private static void writeApConfiguration(final String filename,
                                             final WifiConfiguration config) {
        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(
                        new FileOutputStream(filename)))) {
            out.writeInt(AP_CONFIG_FILE_VERSION);
            out.writeUTF(config.SSID);
            out.writeInt(config.apBand);
            out.writeInt(config.apChannel);
            int authType = config.getAuthType();
            out.writeInt(authType);
            if (authType != KeyMgmt.NONE) {
                out.writeUTF(config.preSharedKey);
            }
        } catch (IOException e) {
            Log.e(TAG, "Error writing hotspot configuration" + e);
        }
    }

    /**
     * Generate a default WPA2 based configuration with a random password.
     * We are changing the Wifi Ap configuration storage from secure settings to a
     * flat file accessible only by the system. A WPA2 based default configuration
     * will keep the device secure after the update.
     */
    private WifiConfiguration getDefaultApConfiguration() {
        WifiConfiguration config = new WifiConfiguration();
        config.SSID = mContext.getResources().getString(
                R.string.wifi_tether_configure_ssid_default);
        config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
        String randomUUID = UUID.randomUUID().toString();
        //first 12 chars from xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        config.preSharedKey = randomUUID.substring(0, 8) + randomUUID.substring(9, 13);
        return config;
    }
}
```

## 3. wifi热点的ssid和密码问题

### 3.1 随机产生热点的ssid和固定的密码

vim ./framwork/opt/net/wifi/service/java/com/android/server/wifi/WifiApConfigStore.java

```java
private WifiConfiguration getDefaultApConfiguration() {
        Log.d(TAG, " getDefaultApConfiguration") ;
        WifiConfiguration config = new WifiConfiguration();
        config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
        String randomUUID = UUID.randomUUID().toString();
        config.preSharedKey = "xyzn888888" ;
        //first 12 chars from xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        config.SSID = "reboot_" + randomUUID.substring(0, 8) ;
        Log.d(TAG, "wifiAp->SSID:" + config.SSID + " preSharedKey:" + config.preSharedKey) ;
        return config;
    }   

```

这个代码解决的是　ssid可以通过uuid随机去产生唯一的ssid号；密码也是固定的xyzn888888



### 3.2 ssid和密码进行上报

#### 3.2.1 ssid和密码分开存储

vim ./opt/net/wifi/service/java/com/android/server/wifi/WifiApConfigStore.java 

```java
package com.android.server.wifi;

import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiConfiguration.KeyMgmt;
import android.os.Environment;
import android.util.Log;

import com.android.internal.R;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Provides API for reading/writing soft access point configuration.
 */
public class WifiApConfigStore {

    private static final String TAG = "WifiApConfigStore";

    private static final String DEFAULT_AP_CONFIG_FILE =
            Environment.getDataDirectory() + "/misc/wifi/softap.conf";

	/**
	 * softap.ssid 文件保存　wifiap 的ssid
	 * softap.psk  文件保存  wifiap 的密码
	 * */
    private static final String WIFI_AP_CONFIG_SSID =
            Environment.getDataDirectory() + "/misc/wifi/softap.ssid";
    
	private static final String WIFI_AP_CONFIG_PSK =
            Environment.getDataDirectory() + "/misc/wifi/softap.psk";

    private static final int AP_CONFIG_FILE_VERSION = 2;

    private WifiConfiguration mWifiApConfig = null;

    private ArrayList<Integer> mAllowed2GChannel = null;

    private final Context mContext;
    private final String mApConfigFile;
    private final BackupManagerProxy mBackupManagerProxy;

    WifiApConfigStore(Context context, BackupManagerProxy backupManagerProxy) {
        this(context, backupManagerProxy, DEFAULT_AP_CONFIG_FILE);
    }

    WifiApConfigStore(Context context,
                      BackupManagerProxy backupManagerProxy,
                      String apConfigFile) {
        mContext = context;
        mBackupManagerProxy = backupManagerProxy;
        mApConfigFile = apConfigFile;

        String ap2GChannelListStr = mContext.getResources().getString(
                R.string.config_wifi_framework_sap_2G_channel_list);
        Log.d(TAG, "2G band allowed channels are:" + ap2GChannelListStr);

        if (ap2GChannelListStr != null) {
            mAllowed2GChannel = new ArrayList<Integer>();
            String channelList[] = ap2GChannelListStr.split(",");
            for (String tmp : channelList) {
                mAllowed2GChannel.add(Integer.parseInt(tmp));
            }
        }

        /* Load AP configuration from persistent storage. */
        mWifiApConfig = loadApConfiguration(mApConfigFile);
        if (mWifiApConfig == null) {
            /* Use default configuration. */
            Log.d(TAG, "Fallback to use default AP configuration");
            mWifiApConfig = getDefaultApConfiguration();

            /* Save the default configuration to persistent storage. */
            writeApConfiguration(mApConfigFile, mWifiApConfig);
        }
    }

    /**
     * Return the current soft access point configuration.
     */
    public synchronized WifiConfiguration getApConfiguration() {
        return mWifiApConfig;
    }

    /**
     * Update the current soft access point configuration.
     * Restore to default AP configuration if null is provided.
     * This can be invoked under context of binder threads (WifiManager.setWifiApConfiguration)
     * and WifiStateMachine thread (CMD_START_AP).
     */
    public synchronized void setApConfiguration(WifiConfiguration config) {
        if (config == null) {
            mWifiApConfig = getDefaultApConfiguration();
        } else {
            mWifiApConfig = config;
        }
        writeApConfiguration(mApConfigFile, mWifiApConfig);

        // Stage the backup of the SettingsProvider package which backs this up
        mBackupManagerProxy.notifyDataChanged();
    }

    public ArrayList<Integer> getAllowed2GChannel() {
        return mAllowed2GChannel;
    }

    /**
     * Load AP configuration from persistent storage.
     */
    private static WifiConfiguration loadApConfiguration(final String filename) {
        WifiConfiguration config = null;
        DataInputStream in = null;
        try {
            config = new WifiConfiguration();
            in = new DataInputStream(
                    new BufferedInputStream(new FileInputStream(filename)));

            int version = in.readInt();
            if ((version != 1) && (version != 2)) {
                Log.e(TAG, "Bad version on hotspot configuration file");
                return null;
            }
            config.SSID = in.readUTF();

            if (version >= 2) {
                config.apBand = in.readInt();
                config.apChannel = in.readInt();
            }

            int authType = in.readInt();
            config.allowedKeyManagement.set(authType);
            if (authType != KeyMgmt.NONE) {
                config.preSharedKey = in.readUTF();
            }
        } catch (IOException e) {
            Log.e(TAG, "Error reading hotspot configuration " + e);
            config = null;
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    Log.e(TAG, "Error closing hotspot configuration during read" + e);
                }
            }
        }
        return config;
    }

    /**
     * Write AP configuration to persistent storage.
     */
    private static void writeApConfiguration(final String filename,
                                             final WifiConfiguration config) {
        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(
                        new FileOutputStream(filename)))) {
            out.writeInt(AP_CONFIG_FILE_VERSION);
            out.writeUTF(config.SSID);
            out.writeInt(config.apBand);
            out.writeInt(config.apChannel);
            int authType = config.getAuthType();
            out.writeInt(authType);
            if (authType != KeyMgmt.NONE) {
                out.writeUTF(config.preSharedKey);
            }
        } catch (IOException e) {
            Log.e(TAG, "Error writing hotspot configuration" + e);
        }

		/**
		 *  caobinxin colbycao add here 2019-03-11 14:49
		 *
		 *  分别将ssid 和　密码 保存在不同的文件中，方便解析
		 * */
		writeApConfigurationItem(WIFI_AP_CONFIG_SSID, config.SSID) ;
		if(authType != KeyMgmt.NONE){
			writeApConfigurationItem(WIFI_AP_CONFIG_PSK, config.preSharedKey) ;
		}
    }

	/**
	 * caobinxin  colbycao add here 2019-03-11 14:43
	 * writeApConfigurationItem:写特定的字符到特定的文件
	 *
	 *
	 * */
	private static void writeApConfigurationItem(final String filename, final String str){
        Log.d(TAG, "writing hotspot configuration item: filename:" + filename + "  str:" + str);
        try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(
                        new FileOutputStream(filename)))) {
            out.writeUTF(str);
        } catch (IOException e) {
            Log.e(TAG, "Error writing hotspot configuration item: filename:" + filename + "  str:" + str + " " + e);
        }
	
	}

    /**
     * Generate a default WPA2 based configuration with a random password.
     * We are changing the Wifi Ap configuration storage from secure settings to a
     * flat file accessible only by the system. A WPA2 based default configuration
     * will keep the device secure after the update.
     */

	/* 替换
    private WifiConfiguration getDefaultApConfiguration() {
		Log.d(TAG, " getDefaultApConfiguration") ;
        WifiConfiguration config = new WifiConfiguration();
        config.SSID = mContext.getResources().getString(
                R.string.wifi_tether_configure_ssid_default);
        config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
        String randomUUID = UUID.randomUUID().toString();
        //first 12 chars from xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        config.preSharedKey = randomUUID.substring(0, 8) + randomUUID.substring(9, 13);
		Log.d(TAG, "wifiAp->SSID:" + config.SSID + " preSharedKey:" + config.preSharedKey) ;
        return config;
    }
	*/

	/**
	 * caobinxin colby add here 2019-03-11 13:46
	 * */

    private WifiConfiguration getDefaultApConfiguration() {
		Log.d(TAG, " getDefaultApConfiguration") ;
        WifiConfiguration config = new WifiConfiguration();
        config.allowedKeyManagement.set(KeyMgmt.WPA2_PSK);
        String randomUUID = UUID.randomUUID().toString();
        config.preSharedKey = "xyzn888888" ;
        //first 12 chars from xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        config.SSID = "reboot_" + randomUUID.substring(0, 8) + randomUUID.substring(9, 13) + randomUUID.substring(14, 18);
		Log.d(TAG, "wifiAp->SSID:" + config.SSID + " preSharedKey:" + config.preSharedKey) ;
        return config;
    }
}
```

这是最终修改后的代码：

测试结果：可以将ssid和密码保存在不同的文件中。

#### 3.2.2 上报ssid和pwd

- 由于我们的应用程序不能直接访问/data/misc/wifi/softap.ssid和softap.psk文件，首先将该文件拷贝到/sdcard中。
- 然后在做一个广播接收器，当有人请求时，将这个ssid和psk在以广播的形式发送出去。

```java
// 拷贝到/sdcard 在读
package com.myntai.slightech.testreadwifiapssidpwd;

import android.os.Environment;
import android.util.Log;
import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class ReadWifiApSsidPwd {

    private static final String WIFI_AP_CONFIG_SSID = Environment.getDataDirectory() + "/misc/wifi/softap.ssid";

    private static final String WIFI_AP_CONFIG_PSK = Environment.getDataDirectory() + "/misc/wifi/softap.psk";

    private static final String READ_SSID_FILE = "/sdcard/softap.ssid";
    private static final String READ_PSK_FILE = "/sdcard/softap.psk";

    private static final String TAG = "ReadWifiApSsidPwd";

    public String readSsid() {
        String ret = "";
        cpWifiApItem(WIFI_AP_CONFIG_SSID);
        ret = readItem(READ_SSID_FILE);
        Log.d(TAG, "WifiApSSID = " + ret) ;
        return ret;
    }

    public String readPsk() {
        String ret = "";
        cpWifiApItem(WIFI_AP_CONFIG_PSK);
        ret = readItem(READ_PSK_FILE);
        Log.d(TAG, "WifiApPSK = " + ret) ;
        return ret;
    }

    private void shellExec(String command) throws Exception {
        Process process2 = null;
        DataOutputStream dataOutputStream2 = null;
        try {
            process2 = Runtime.getRuntime().exec("su");
            dataOutputStream2 = new DataOutputStream(process2.getOutputStream());
            dataOutputStream2.writeBytes(command);
            dataOutputStream2.writeBytes("exit\n");
            dataOutputStream2.flush();
            process2.waitFor();
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                if (dataOutputStream2 != null) {
                    dataOutputStream2.close();
                }
                process2.destroy();
            } catch (Exception e) {
                throw e;
            }
        }
    }


    private void cpWifiApItem(String filename) {
        try {
            shellExec("cp " + filename + " /sdcard/ \n");
        } catch (Exception e) {
            Log.e(TAG, "" + e);
        }
    }

    private String readItem(String filename) {
        String ret = "";
        DataInputStream in = null;
        try {
            in = new DataInputStream(new BufferedInputStream(new FileInputStream(filename)));
            ret = in.readUTF();
        } catch (IOException e) {
            Log.e(TAG, "Error reading " + filename + " e=" + e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    Log.e(TAG, "Error closing " +filename+ " during read e=" + e);
                }
            }
        }
        return ret;
    }
}
```

做一个广播接收器：

androidManifest.xml

```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>     

  <application>
      ....
		<receiver
            android:name=".QueryWifiApInfo"
            android:exported="true"
            android:enabled="true">
            <intent-filter>
                <action android:name="com.android.settings.wifiap.request.pass"/>
            </intent-filter>
        </receiver>

    </application>
```



```java
package com.myntai.slightech.testreadwifiapssidpwd;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

public class QueryWifiApInfo extends BroadcastReceiver {

    private static final String TAG = "QueryWifiApInfo";
    private static final String REQUEST_BR = "com.android.settings.wifiap.request.pass";
    private static final String OFFER_BR = "com.android.settings.wifiap.offer.pass";
    @Override
    public void onReceive(Context context, Intent intent) {
        if (REQUEST_BR.equals(intent.getAction())) {
            Log.i(TAG, "onReceive action==" + intent.getAction());

            ReadWifiApSsidPwd readWifiApSsidPwd = new ReadWifiApSsidPwd();
            String ssid = readWifiApSsidPwd.readSsid();
            String password = readWifiApSsidPwd.readPsk();

            Intent intentReturn = new Intent(OFFER_BR);
            intentReturn.putExtra("SSID", ssid);
            intentReturn.putExtra("PASSWORD", password);
            context.sendBroadcast(intentReturn);

            Log.i(TAG, "查询wifiap:" + ssid + " 密码:" + password);
        }
    }
}

```

测试广播接收器：

```sh
adb shell am broadcast -a com.android.settings.wifiap.request.pass
#测试结果一切正常
```

#### 3.2.3 提供的上层接口文档

```sh
#1.发送如下的　action，代表向系统查询wifi热点的SSID 和　密码
com.android.settings.wifiap.request.pass

#2. 系统将查询　ssid 和　密码

#3. 查询结束后，系统将发送如下action的广播，该广播将携带　SSID　PASSWORD
com.android.settings.wifiap.offer.pass

```



