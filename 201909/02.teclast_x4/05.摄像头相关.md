# 1. 问题列表

1. 录像时，相机会断开连接
2. 后置相机，会连接到前置相机
3. 帧率慢，拍照慢

# 2. 问题解决

## 2.1 录像时相机断开：

### 2.1.1 问题定位

堆栈打印方法：

```cpp
// 把这个函数放在 文件的顶部，#include 的下面， 不然会报， namespace的问题 
    
#include <utils/Log.h>
#include <utils/CallStack.h>

void dumping_callstack(){
    android::CallStack stack;                                                  
    stack.update();
    stack.dump(1);
    stack.log("Dumping Stack", ANDROID_LOG_ERROR, "111111");
}

// E Dumping Stack: 111111111111111111111111111111111111111111111#00 pc 000c5999  /system/lib/libstagefright.so 
```

报错：

```shell
D CameraHardware: CameraHardware::getParameters
D CameraHardware: CameraHardware::putParameters
E CameraSource: Video dimension (1280x720) is unsupported
```

错误的原因：

```shell
1. 框架层中，将相机支持的所有分辨率都设置了，但是底层相机不一定支持这么多
2. 所以这里需要厂商去 适配 底层和上层要保持一致
```

台电x4 设备所支持的相机的分辨率为：

```shell
# 这些值是从底层上传上来的
CameraSource: configureCamera
CameraSource: colby........................................
CameraSource: isVideoSizeSupported # 在这个函数中打印出底层信息的
CameraSource:  colby supportedSizes[0] width=176 height=144 
CameraSource:  colby supportedSizes[1] width=240 height=160 
CameraSource:  colby supportedSizes[2] width=320 height=200 
CameraSource:  colby supportedSizes[3] width=320 height=240 
CameraSource:  colby supportedSizes[4] width=352 height=288 
CameraSource:  colby supportedSizes[5] width=432 height=320 
CameraSource:  colby supportedSizes[6] width=480 height=320 
CameraSource:  colby supportedSizes[7] width=1600 height=1200
```

上层相关配置的文件在 CamcorderProfile.java 中

```java
// CamcorderProfile.java
// 上层就是被设置为 1280*720 的了， 而底层相机不支持该分辨率的

	/** 
     * Quality level corresponding to the 720p (1280 x 720) resolution.
     */
    public static final int QUALITY_720P = 5
```



这里先将   Video dimension (1280x720) is unsupported 对应的调用栈打印出来在说：

```c++
// av/media/libstagefright/CameraSource.cpp:374

00 pc 000c5999  /system/lib/libstagefright.so -> CameraSource.cpp:52
01 pc 000c6245  /system/lib/libstagefright.so -> CameraSource.cpp:683
02 pc 000c4b81  /system/lib/libstagefright.so -> CameraSource.cpp:567
03 pc 000c4c5e  /system/lib/libstagefright.so -> CameraSource.cpp:205 -> CameraSource::CreateFromCamera 


04 pc 0015788f  /system/lib/libstagefright.so -> AVFactory.cpp:72 -> AVFactory::CreateCameraSourceFromCamera

05 pc 000574b2  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:1500 -> 
    StagefrightRecorder::setupCameraSource // 在这个地方填充了 w h
    
06 pc 00055db6  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:1465
07 pc 00053fad  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:1742
08 pc 00053d9a  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:812
09 pc 00054f38  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:868
10 pc 0004dc24  /system/lib/libmediaplayerservice.so -> MediaRecorderClient.cpp:240
11 pc 000d6d83  /system/lib/libmedia.so -> IMediaRecorder.cpp:361
12 pc 000d73b1  /system/lib/libmedia.so 
13 pc 000390c6  /system/lib/libbinder.so
14 pc 000480c0  /system/lib/libbinder.so
15 pc 00047acb  /system/lib/libbinder.so
16 pc 0004831f  /system/lib/libbinder.so
17 pc 0006ef3e  /system/lib/libbinder.so
18 pc 00012095  /system/lib/libutils.so 
19 pc 00011883  /system/lib/libutils.so 
20 pc 00086e5f  /system/lib/libc.so 
21 pc 00022f40  /system/lib/libc.so 
22 pc 000207a6  /system/lib/libc.so
```

```c++
// frameworks$ vim av/media/libmediaplayerservice/StagefrightRecorder.cpp +1500

status_t StagefrightRecorder::setupCameraSource(
        sp<CameraSource> *cameraSource) {
       
    Size videoSize;
    videoSize.width = mVideoWidth; // 谁给他赋值为 7200了
    videoSize.height = mVideoHeight;
    if (mCaptureFpsEnable) {
    } else {
        *cameraSource = AVFactory::get()->CreateCameraSourceFromCamera(
                mCamera, mCameraProxy, mCameraId, mClientName, mClientUid, mClientPid,
                videoSize, mFrameRate,
                mPreviewSurface);
    }
........
}

status_t StagefrightRecorder::setVideoSize(int width, int height) {
    ALOGV("setVideoSize: %dx%d", width, height);
    if (width <= 0 || height <= 0) { 
        ALOGE("Invalid video size: %dx%d", width, height);
        return BAD_VALUE;
    }                      
    // Additional check on the dimension will be performed later
    mVideoWidth = width;
    mVideoHeight = height;
    
    // 在这个地方进行回溯

    return OK;
}

//make libmediaplayerservice
```

```shell
V StagefrightRecorder: setVideoSize: 1280x720
00 pc 000525b5  /system/lib/libmediaplayerservice.so -> StagefrightRecorder.cpp:71
01 pc 0004db82  /system/lib/libmediaplayerservice.so -> MediaRecorderClient.cpp:185
02 pc 000d6ff8  /system/lib/libmedia.so -> IMediaRecorder.cpp:442
03 pc 000d73b1  /system/lib/libmedia.so -> IMediaRecorder.cpp:323 -> BnMediaRecorder::onTransact # 到这里就需要跨进程通信了 

04 pc 000390c6  /system/lib/libbinder.so 
05 pc 000480c0  /system/lib/libbinder.so                     
06 pc 00047acb  /system/lib/libbinder.so 
07 pc 0004831f  /system/lib/libbinder.so 
08 pc 0006ef3e  /system/lib/libbinder.so 
09 pc 00012095  /system/lib/libutils.so 
10 pc 00011883  /system/lib/libutils.so 
11 pc 00086e5f  /system/lib/libc.so 
12 pc 00022f40  /system/lib/libc.so
13 pc 000207a6  /system/lib/libc.so
```

```cpp
// IMediaRecorder.cpp

status_t BnMediaRecorder::onTransact(
                                     uint32_t code, const Parcel& data, Parcel* reply,
                                     uint32_t flags)
{
    switch (code) {
            case SET_VIDEO_SIZE: {
            ALOGV("SET_VIDEO_SIZE");
            CHECK_INTERFACE(IMediaRecorder, data, reply);
            int width = data.readInt32();
            int height = data.readInt32();
            reply->writeInt32(setVideoSize(width, height));
            return NO_ERROR;
        } break;
    }
    ...
}

// 这个地方的 onTransact 是在这个地方被调用的：
status_t setVideoSize(int width, int height)
    {
        ALOGV("setVideoSize(%dx%d)", width, height);
        Parcel data, reply;
        data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor());
        data.writeInt32(width);
        data.writeInt32(height);
        remote()->transact(SET_VIDEO_SIZE, data, &reply); // 这里被调用                             // 在这里进行 栈回溯                
        return reply.readInt32();
    }
```

回溯结果：

```c
V IMediaRecorder: setVideoSize(1280x720)
E Dumping Stack: 222222222222#00 pc 000000000012e47b  /system/lib64/libmedia.so -> IMediaRecorder.cpp:39

E Dumping Stack: 222222222222#01 pc 000000000013b5cd  /system/lib64/libmedia.so -> mediarecorder.cpp:322 -> MediaRecorder::setVideoSize
    
E Dumping Stack: 222222222222#02 pc 000000000004d4b9  /system/lib64/libmedia_jni.so -> android_media_MediaRecorder.cpp:288 // 看jni 的调用
    
    
E Dumping Stack: 222222222222#03 pc 0000000000ea254d  /data/dalvik-cache/x86_64/system@framework@boot.oat


```

```c++
// android_media_MediaRecorder.cpp

static void
android_media_MediaRecorder_setVideoSize(JNIEnv *env, jobject thiz, jint width, jint height)                                                                                                                       
{
    // 将这里的强制赋值去掉也没事： 所以这里也不是最关键的
    width = 1600;               
    height = 1200;
    ALOGV("setVideoSize(%d, %d)", width, height);
    sp<MediaRecorder> mr = getMediaRecorder(env, thiz);

    if (width <= 0 || height <= 0) {
        jniThrowException(env, "java/lang/IllegalArgumentException", "invalid video size");
        return;
    }   
    process_media_recorder_call(env, mr->setVideoSize(width, height), "java/lang/RuntimeException", "setVideoSize failed."); // 在这里调用了
}

// 从这里我们可以看出， 这个函数是被java层调用了， java 层对应的函数为 setVideoSize(int, int)
static const JNINativeMethod gMethods[] = {
		{"setVideoSize",         "(II)V",                           (void 									*)android_media_MediaRecorder_setVideoSize},
}

int register_android_media_MediaRecorder(JNIEnv *env)
{
    return AndroidRuntime::registerNativeMethods(env,  
                "android/media/MediaRecorder", gMethods, NELEM(gMethods));
} // 这里是和 MediaRecorder.java 所对应的

// make libmedia_jni
```

```java
// MediaRecorder.java

public native void setVideoSize(int width, int height) throws IllegalStateException;

public void setProfile(CamcorderProfile profile) {
        setOutputFormat(profile.fileFormat);
        setVideoFrameRate(profile.videoFrameRate);
    
    	Log.e(“dump_test”,Log.getStackTraceString(new Throwable()));
    	// 在这个地方打印函数调用栈 // 在这里强制 赋值为了 1600*1200 
    	// 通过测试， 可以不在这里直接改为 1600*1200 保持原样就好。
        setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);// 从这里就要看， profile 文件是被谁设置的？？？                                                                                                                                     
        setVideoEncodingBitRate(profile.videoBitRate);
        setVideoEncoder(profile.videoCodec);
        if (profile.quality >= CamcorderProfile.QUALITY_TIME_LAPSE_LOW &&
             profile.quality <= CamcorderProfile.QUALITY_TIME_LAPSE_QVGA) {
            // Nothing needs to be done. Call to setCaptureRate() enables
            // time lapse video recording.
        } else {
            setAudioEncodingBitRate(profile.audioBitRate);
            setAudioChannels(profile.audioChannels);
            setAudioSamplingRate(profile.audioSampleRate);
            setAudioEncoder(profile.audioCodec);
        }
    }

// 这里我们发现 由原来的设置 w,h 变为设置 profile ，问题已经转变了
```

```shell
 make framework
```

```java
StagefrightRecorder: setVideoSource: 1
 java.lang.Throwable 
    at android.media.MediaRecorder.setProfile(MediaRecorder.java:484)
    at com.android.camera.VideoModule.initializeRecorder(VideoModule.java:1147)
    at com.android.camera.VideoModule.-wrap2(VideoModule.java)
    at com.android.camera.VideoModule$11.onStorageUpdateDone(VideoModule.java:1377)
    at com.android.camera.CameraActivity$20.onPostExecute(CameraActivity.java:2351)
    at com.android.camera.CameraActivity$20.onPostExecute(CameraActivity.java:2346)
    at android.os.AsyncTask.finish(AsyncTask.java:667)
    at android.os.AsyncTask.-wrap1(AsyncTask.java)
    at android.os.AsyncTask$InternalHandler.handleMessage(AsyncTask.java:684)
    at android.os.Handler.dispatchMessage(Handler.java:102)
    at android.os.Looper.loop(Looper.java:154)
    at android.app.ActivityThread.main(ActivityThread.java:6300)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:887)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:777)
```

```java
// 这儿的1147 在 packages/apps/Camera2/src/com/android/camera/VideoModule.java:1147 中

 private void initializeRecorder() {
     ...
     mMediaRecorder.setCamera(camera);
        // CHAOZHUO BEGIN
        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
        // CHOAZHUO END
        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
        mMediaRecorder.setProfile(mProfile); // 这里就要着重分析这个是从那来的                                                                                                                                                                      
        mMediaRecorder.setVideoSize(mProfile.videoFrameWidth, mProfile.videoFrameHeight);
        mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
     ...
 }

// 唯一一个被赋值的位置：
private void readVideoPreferences() {
    ...
    mProfile = CamcorderProfile.get(mCameraId, quality);
    ...
}
```

![](05.摄像头相关.assets/2019-09-23 18-55-26 的屏幕截图.png)

```shell
D CAM_VideoModule: Selected video quality for 'large' is 5                       
D CAM_VideoModule: 1.
D CAM_VideoModule: 5. mMaxVideoDurationInMs=0
D CAM_VideoModule: 7. quality=5
```

```shell
# int quality = SettingsUtil.getVideoQuality(videoQuality, mCameraId); 
# mProfile = CamcorderProfile.get(mCameraId, quality);

# 这里需要搞清楚 quality = 5 是怎么来的，以及 mProfile 的赋值
```

```java
// 先搞清楚 quality 如何来的
// hp-4.19/packages$ vim apps/Camera2/src/com/android/camera/settings/SettingsUtil.java

/** 
     * Determines the video quality for large/medium/small for the given camera.
     * Returns the one matching the given setting. Defaults to 'large' of the
     * qualitySetting does not match either large. medium or small.
     *
     * @param qualitySetting One of 'large', 'medium', 'small'.
     * @param cameraId The ID of the camera for which to get the quality
     *            setting.
     * @return The CamcorderProfile quality setting.
     */
/*
	给定相机确定 大 中 小 视频的质量。返回一个匹配的设置。默认设置large(高)质量是不匹配每一个 large medium small 的。
	@param qualitySetting 下面的其中之一 'large', 'medium', 'small'.
	@param cameraId 要设置的相机的ID
	@return 相机的质量
*/
public static int getVideoQuality(String qualitySetting, int cameraId) {     
        return getSelectedVideoQualities(cameraId).getFromSetting(qualitySetting);
}


static SelectedVideoQualities getSelectedVideoQualities(int cameraId) {
        if (sCachedSelectedVideoQualities.get(cameraId) != null) {
            return sCachedSelectedVideoQualities.get(cameraId);
        }

        // 按降序查看大小，看它们是否受支持，并相应地设置大/中/小。如果根本不支持任何质量，则对getNextSupportedQuality的第一次调用将引发异常。如果只支持一个质量，则所选的三个质量都将相同。
    
        int largeIndex = getNextSupportedVideoQualityIndex(cameraId, -1); // 2
        int mediumIndex = getNextSupportedVideoQualityIndex(cameraId, largeIndex);
        int smallIndex = getNextSupportedVideoQualityIndex(cameraId, mediumIndex);

        SelectedVideoQualities selectedQualities = new SelectedVideoQualities();
        selectedQualities.large = sVideoQualities[largeIndex]; // 5
        selectedQualities.medium = sVideoQualities[mediumIndex];
        selectedQualities.small = sVideoQualities[smallIndex];
        sCachedSelectedVideoQualities.put(cameraId, selectedQualities);
        return selectedQualities;
    }
public static int[] sVideoQualities = new int[] {
            CamcorderProfile.QUALITY_2160P,
            CamcorderProfile.QUALITY_1080P,
            CamcorderProfile.QUALITY_720P, // 5
            CamcorderProfile.QUALITY_480P,
            CamcorderProfile.QUALITY_CIF,
            CamcorderProfile.QUALITY_QVGA,
            CamcorderProfile.QUALITY_QCIF
    };
```

```shell
 largeIndex=2              
 mediumIndex=3
 smallIndex=4
 selectedQualities.larger=5
 selectedQualities.medium=4
 selectedQualities.small=3
 largeIndex=2
 mediumIndex=3
 smallIndex=4
 selectedQualities.larger=5
 selectedQualities.medium=4
 selectedQualities.small=3
```

这里要弄明白 int largeIndex = getNextSupportedVideoQualityIndex(cameraId, -1); // 2 

```java
private static int getNextSupportedVideoQualityIndex(int cameraId, int start) {
        for (int i = start + 1; i < sVideoQualities.length; ++i) {
            if (isVideoQualitySupported(sVideoQualities[i])
                    && CamcorderProfile.hasProfile(cameraId, sVideoQualities[i])) {
                return i; // 这个地方返回了2
            }
        }
        if (start < 0 || start >= sVideoQualities.length) {
            // 这意味这我们没有找到任何一个支持的质量
            throw new IllegalArgumentException("Could not find supported video qualities.");
        }

        // 返回相同的 质量
        return start;
    }
```



```java
// hp-4.19$ vim ./frameworks/base/media/java/android/media/CamcorderProfile.java

public static boolean hasProfile(int cameraId, int quality) {
        return native_has_camcorder_profile(cameraId, quality);
    }
```



```c++
// android_media_MediaProfiles.cpp

{"native_has_camcorder_profile",           "(II)Z",(void *)android_media_MediaProfiles_native_has_camcorder_profile},



static jboolean
android_media_MediaProfiles_native_has_camcorder_profile(JNIEnv* /* env */, jobject /* thiz */,jint id, jint quality)
{
    ALOGV("native_has_camcorder_profile: %d %d", id, quality);
    if (!isCamcorderQualityKnown(quality)) {
        return JNI_FALSE;
    }   

    camcorder_quality q = static_cast<camcorder_quality>(quality); // 这是个强制类型转换
    
    return sProfiles->hasCamcorderProfile(id, q) ? JNI_TRUE : JNI_FALSE; // 看这里为啥是true
}


```

```cpp
// MediaProfiles.cpp
bool MediaProfiles::hasCamcorderProfile(int cameraId, camcorder_quality quality) const     
{
    return (getCamcorderProfileIndex(cameraId, quality) != -1);
}

int MediaProfiles::getCamcorderProfileIndex(int cameraId, camcorder_quality quality) const 
{
    int index = -1;
    for (size_t i = 0, n = mCamcorderProfiles.size(); i < n; ++i) {
        if (mCamcorderProfiles[i]->mCameraId == cameraId &&
            mCamcorderProfiles[i]->mQuality == quality) {
            index = i; // 从这里返回了
            break;
        }
    }
    return index;
}

// make libmedia
```

### 2.1.2 解决

有了2.1.1 的分析和调试，在如下位置修改即可：

```cpp
// frameworks$ vim av/media/libstagefright/CameraSource.cpp

status_t CameraSource::configureCamera(
        CameraParameters* params,
        int32_t width, int32_t height,
        int32_t frameRate) {
    ALOGV("configureCamera");
    Vector<Size> sizes;
    bool isSetVideoSizeSupportedByCamera = true;
    getSupportedVideoSizes(*params, &isSetVideoSizeSupportedByCamera, sizes);
    bool isCameraParamChanged = false;
    if (width != -1 && height != -1) {
        //if (!isVideoSizeSupported(width, height, sizes)) {
        if (!isVideoSizeSupported(1600, 1200, sizes)) {   // 只需要在这个位置改为 和我们硬件匹配的 就可以了   ， 由于上层配置的 为1280 * 720 ,所以录完像之后，属性值就是 1280*720的                              
            dumping_callstack();
            ALOGE("colby Video dimension (%dx%d) is unsupported", width, height);
            return BAD_VALUE; // 这里直接将这个 注释掉，也是可以的，让这个判断 通过
        }
        if (isSetVideoSizeSupportedByCamera) {
            params->setVideoSize(width, height);
        } else {
            params->setPreviewSize(width, height);
        }
        isCameraParamChanged = true;
    }
    ...

}

//make  libstagefright
```

总结：

**修改方案一**

这里优先使用这个， 录像和preview 都固定死

直接 在这里写死  if (!isVideoSizeSupported(1600, 1200, sizes)) 

**修改方案二**

让这个if判断不要返回，错误

```c
if (!isVideoSizeSupported(width, height, sizes)) {                             
            dumping_callstack();
            ALOGE("colby Video dimension (%dx%d) is unsupported", width, height);
           // return BAD_VALUE; // 这里直接将这个 注释掉，也是可以的，让这个判断 通过
        }
```



```c
// android_media_MediaRecorder.cpp

static void
android_media_MediaRecorder_setVideoSize(JNIEnv *env, jobject thiz, jint width, jint height)                                                                                                                       
{
    // 将这里的强制赋值去掉也没事： 所以这里也不是最关键的
    width = 1600;               
    height = 1200;
    ALOGV("setVideoSize(%d, %d)", width, height);
    sp<MediaRecorder> mr = getMediaRecorder(env, thiz);
	...
}
```



这里采用方案二， 直接不让他放回错误即可。

## 2.2 录像前后置摄像头切换问题：

问题描述：

不管切换的是那个摄像头，默认都使用的是前置摄像头

原因：

由于有的设备没有后置摄像头，所以，就将后置相机，也设置为前置相机了。 本来是没有问题的。这里还原回去即可

```shell
1. packages/apps/chaozhuo/CZApplyPatches/x86/hardware_libcamera.patch
```

```cpp
// hardware/libcamera$ vim CameraFactory.cpp
#define DEFAULT_DEVICE_FRONT "/dev/video0" // 前置默认是 0
#define DEFAULT_DEVICE_BACK  "/dev/video1" // 后置默认是 1

// 如果这两个对调后，就会出现 相机 画面镜像的问题。


// make camera.x86 
```

## 2.3 preview 格式不对

问题描述

当我们使用前置摄像头录像的时候， 预览的分辨率是 432x320，正式录像时为1280*720 

### 2.3.1 问题定位

```shell
D CameraHardware: CameraHardware::startPreviewLocked: Init
D V4L2Camera: V4L2Camera::Init
D V4L2Camera: Trying format: (1600 x 1200), Fps: 5 [difArea:1781760, difFps:25, cDifArea:-1, cDifFps:-1]                                                                                                           
D V4L2Camera: Trying format: (1600 x 1200), Fps: 25 [difArea:1781760, difFps:5, cDifArea:1781760, cDifFps:25]
D V4L2Camera: Trying format: (1600 x 1200), Fps: 30 [difArea:1781760, difFps:0, cDifArea:1781760, cDifFps:5]
D V4L2Camera: Selected format: (1600 x 1200), Fps: 30
I V4L2Camera: Cropping from origin: 584x440 - size: 432x320  (offset:1409168)
I V4L2Camera: Actual format: (1600 x 1200), Fps: 5, pixfmt: 'YUYV', bytesperline: 3200
D CameraHardware: CameraHardware::startPreviewLocked: effective size: 432x320
D CameraHardware: CameraHardware::initHeapLocked
D CameraHardware: CameraHardware::initHeapLocked: preview size=432x320
D CameraHardware: CameraHardware::initHeapLocked: picture size=432x320
D CameraHardware: CameraHardware::initHeapLocked: video size=1280x720
D CameraHardware: CameraHardware::initHeapLocked: OK
D CameraHardware: CameraHardware::startPreviewLocked: StartStreaming
```

先从 grep -inR "Actual format:"

```c
// hp-4.19/hardware/libcamera$ vim V4L2Camera.cpp
int V4L2Camera::Init(int width, int height, int fps)
{
    // 1. V4L2Camera::Init width=432 height=320 fps=30
    // 正确的情况下应该传入 1280*720 从这可以有一个切入点
    ALOGD("V4L2Camera::Init width=%d height=%d fps=%d", width, height, fps);
    /* Initialize the capture to the specified width and height */
    static const struct {
        int fmt;            /* PixelFormat */
        int bpp;            /* bytes per pixel */
        int isplanar;       /* If format is planar or not */
        int allowscrop;     /* If we support cropping with this pixel format */
    } pixFmtsOrder[] = {
        {V4L2_PIX_FMT_YUYV,     2,0,1},
        {V4L2_PIX_FMT_YVYU,     2,0,1},
        {V4L2_PIX_FMT_UYVY,     2,0,1},
        {V4L2_PIX_FMT_YYUV,     2,0,1},
        {V4L2_PIX_FMT_SPCA501,  2,0,0},
        {V4L2_PIX_FMT_SPCA505,  2,0,0},
        {V4L2_PIX_FMT_SPCA508,  2,0,0},
        {V4L2_PIX_FMT_YUV420,   0,1,0},
        {V4L2_PIX_FMT_YVU420,   0,1,0},
        {V4L2_PIX_FMT_NV12,     0,1,0},
        {V4L2_PIX_FMT_NV21,     0,1,0},
        {V4L2_PIX_FMT_NV16,     0,1,0},
        {V4L2_PIX_FMT_NV61,     0,1,0},
        {V4L2_PIX_FMT_Y41P,     0,0,0},
        {V4L2_PIX_FMT_SGBRG8,   0,0,0},
        {V4L2_PIX_FMT_SGRBG8,   0,0,0},
        {V4L2_PIX_FMT_SBGGR8,   0,0,0},
        {V4L2_PIX_FMT_SRGGB8,   0,0,0},
        {V4L2_PIX_FMT_BGR24,    3,0,1},
        {V4L2_PIX_FMT_RGB24,    3,0,1},
        {V4L2_PIX_FMT_MJPEG,    0,1,0},
        {V4L2_PIX_FMT_JPEG,     0,1,0},
        {V4L2_PIX_FMT_GREY,     1,0,1},
        {V4L2_PIX_FMT_Y16,      2,0,1},
    };

    int ret;

    // If no formats, break here
    if (m_AllFmts.isEmpty()) {
        ALOGE("No video formats available");
        return -1;
    }

    // Try to get the closest match ...
    SurfaceDesc closest;
    int closestDArea = -1;
    int closestDFps = -1;
    unsigned int i;
    int area = width * height;
    for (i = 0; i < m_AllFmts.size(); i++) {
        SurfaceDesc sd = m_AllFmts[i];

        // Always choose a bigger or equal surface
        if (sd.getWidth() >= width &&
            sd.getHeight() >= height) {

            int difArea = sd.getArea() - area;
            int difFps = my_abs(sd.getFps() - fps);

            ALOGD("Trying format: (%d x %d), Fps: %d [difArea:%d, difFps:%d, cDifArea:%d, cDifFps:%d]",sd.getWidth(),sd.getHeight(),sd.getFps(), difArea, difFps, closestDArea, closestDFps);
            if (closestDArea < 0 ||
                difArea < closestDArea ||
                (difArea == closestDArea && difFps < closestDFps)) {

                // Store approximation
                closestDArea = difArea;
                closestDFps = difFps;

                // And the new surface descriptor
                closest = sd;
            }
        }
    }

    if (closestDArea == -1) {
        ALOGE("Size not available: (%d x %d)",width,height);
        return -1;
    }

    // Selected format: (1600 x 1200), Fps: 30
    ALOGD("Selected format: (%d x %d), Fps: %d",closest.getWidth(),closest.getHeight(),closest.getFps());

    // Check if we will have to crop the captured image
    bool crop = width != closest.getWidth() || height != closest.getHeight();

    // Iterate through pixel formats from best to worst
    ret = -1;
    for (i=0; i < (sizeof(pixFmtsOrder) / sizeof(pixFmtsOrder[0])); i++) {

        // If we will need to crop, make sure to only select formats we can crop...
        if (!crop || pixFmtsOrder[i].allowscrop) {

            memset(&videoIn->format,0,sizeof(videoIn->format));
            videoIn->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
            videoIn->format.fmt.pix.width = closest.getWidth();
            videoIn->format.fmt.pix.height = closest.getHeight();
            videoIn->format.fmt.pix.pixelformat = pixFmtsOrder[i].fmt;

            ret = ioctl(fd, VIDIOC_TRY_FMT, &videoIn->format);
            if (ret >= 0 &&
                videoIn->format.fmt.pix.width ==  (uint)closest.getWidth() &&
                videoIn->format.fmt.pix.height == (uint)closest.getHeight()) {
                break;
            }
        }
    }
    if (ret < 0) {
        ALOGE("Open: VIDIOC_TRY_FMT Failed: %s", strerror(errno));
        return ret;
    }


    /* Set the format */
    memset(&videoIn->format,0,sizeof(videoIn->format));
    videoIn->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    videoIn->format.fmt.pix.width = closest.getWidth();
    videoIn->format.fmt.pix.height = closest.getHeight();
    videoIn->format.fmt.pix.pixelformat = pixFmtsOrder[i].fmt;
    
    // lineNum:226 width=1600 height=1200
ALOGD("lineNum:%d width=%d height=%d ", __LINE__, videoIn->format.fmt.pix.width, videoIn->format.fmt.pix.height);
    ret = ioctl(fd, VIDIOC_S_FMT, &videoIn->format);
    if (ret < 0) {
        ALOGE("Open: VIDIOC_S_FMT Failed: %s", strerror(errno));
        return ret;
    }


    /* Query for the effective video format used */
    memset(&videoIn->format,0,sizeof(videoIn->format));
    videoIn->format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    ret = ioctl(fd, VIDIOC_G_FMT, &videoIn->format);
    if (ret < 0) {
        ALOGE("Open: VIDIOC_G_FMT Failed: %s", strerror(errno));
        return ret;
    }

    /* Note VIDIOC_S_FMT may change width and height. */
    // lineNum:244 width=1600 height=1200 这里传入的和设置的是一致的
ALOGD("lineNum:%d width=%d height=%d ", __LINE__, videoIn->format.fmt.pix.width, videoIn->format.fmt.pix.height);

    /* Buggy driver paranoia. */
    unsigned int min = videoIn->format.fmt.pix.width * 2;
// lineNum:249 bytesperline=3200
ALOGD("lineNum:%d bytesperline=%d", __LINE__, videoIn->format.fmt.pix.bytesperline);
    if (videoIn->format.fmt.pix.bytesperline < min)
        videoIn->format.fmt.pix.bytesperline = min;
    min = videoIn->format.fmt.pix.bytesperline * videoIn->format.fmt.pix.height;
    
// lineNum:253 sizeimage=3840000
ALOGD("lineNum:%d sizeimage=%d", __LINE__, videoIn->format.fmt.pix.sizeimage);
    if (videoIn->format.fmt.pix.sizeimage < min)
        videoIn->format.fmt.pix.sizeimage = min;

    /* Store the pixel formats we will use */
    videoIn->outWidth           = width;
    videoIn->outHeight          = height;
    videoIn->outFrameSize       = width * height << 1; // Calculate the expected output framesize in YUYV
    videoIn->capBytesPerPixel   = pixFmtsOrder[i].bpp;
// lineNum:263 closest.getWidth=1600 width=432
ALOGD("lineNum:%d closest.getWidth=%d width=%d", __LINE__, closest.getWidth(), width);
    
// lineNum:264 closest.getHeight=1200 height=320    
ALOGD("lineNum:%d closest.getHeight=%d height=%d", __LINE__, closest.getHeight(), height);
    /* Now calculate cropping margins, if needed, rounding to even */
    int startX = ((closest.getWidth() - width) >> 1) & (-2);
    int startY = ((closest.getHeight() - height) >> 1) & (-2);

    /* Avoid crashing if the mode found is smaller than the requested */
    if (startX < 0) {
        videoIn->outWidth += startX;
        startX = 0;
    }
    if (startY < 0) {
        videoIn->outHeight += startY;
        startY = 0;
    }

    /* Calculate the starting offset into each captured frame */
    videoIn->capCropOffset = (startX * videoIn->capBytesPerPixel) +
            (videoIn->format.fmt.pix.bytesperline * startY);
    
	// Cropping from origin: 584x440 - size: 432x320  (offset:1409168)
    ALOGI("Cropping from origin: %dx%d - size: %dx%d  (offset:%d)",
        startX,startY,
        videoIn->outWidth,videoIn->outHeight,
        videoIn->capCropOffset);

    /* sets video device frame rate */
    memset(&videoIn->params,0,sizeof(videoIn->params));
    videoIn->params.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    videoIn->params.parm.capture.timeperframe.numerator = 1;
    videoIn->params.parm.capture.timeperframe.denominator = closest.getFps();
    
    // lineNum:293 timeperframe.denominator=30 // 这里设置的是30
ALOGD("lineNum:%d timeperframe.denominator=%d", __LINE__, videoIn->params.parm.capture.timeperframe.denominator);
    /* Set the framerate. If it fails, it wont be fatal */
    if (ioctl(fd,VIDIOC_S_PARM,&videoIn->params) < 0) {
        ALOGE("VIDIOC_S_PARM error: Unable to set %d fps", closest.getFps());
    }

    /* Gets video device defined frame rate (not real - consider it a maximum value) */
    if (ioctl(fd,VIDIOC_G_PARM,&videoIn->params) < 0) {
        ALOGE("VIDIOC_G_PARM - Unable to get timeperframe");
    }

    // 2. 这里就有一个疑问了，我们设置的 fps 是30, 而再次去读的话， fps 为5, 说明就没有设置成功
    // Actual format: (1600 x 1200), Fps: 5, pixfmt: 'YUYV', bytesperline: 3200
    ALOGI("Actual format: (%d x %d), Fps: %d, pixfmt: '%c%c%c%c', bytesperline: %d",
        videoIn->format.fmt.pix.width,
        videoIn->format.fmt.pix.height,
        videoIn->params.parm.capture.timeperframe.denominator,
        videoIn->format.fmt.pix.pixelformat & 0xFF, (videoIn->format.fmt.pix.pixelformat >> 8) & 0xFF,
        (videoIn->format.fmt.pix.pixelformat >> 16) & 0xFF, (videoIn->format.fmt.pix.pixelformat >> 24) & 0xFF,
        videoIn->format.fmt.pix.bytesperline);

    ...

    return 0;
}

// make camera.x86
```

```shell
D CameraHardware: CameraHardware::startPreviewLocked: Init                         
D V4L2Camera: V4L2Camera::Init width=432 height=320 fps=30
D V4L2Camera: Trying format: (1600 x 1200), Fps: 5 [difArea:1781760, difFps:25, cDifArea:-1, cDifFps:-1]
D V4L2Camera: Trying format: (1600 x 1200), Fps: 25 [difArea:1781760, difFps:5, cDifArea:1781760, cDifFps:25]
D V4L2Camera: Trying format: (1600 x 1200), Fps: 30 [difArea:1781760, difFps:0, cDifArea:1781760, cDifFps:5]
D V4L2Camera: Selected format: (1600 x 1200), Fps: 30
D V4L2Camera: lineNum:226 width=1600 height=1200 
D V4L2Camera: lineNum:244 width=1600 height=1200 
D V4L2Camera: lineNum:249 bytesperline=3200
D V4L2Camera: lineNum:253 sizeimage=3840000
D V4L2Camera: lineNum:263 closest.getWidth=1600 width=432
D V4L2Camera: lineNum:264 closest.getHeight=1200 height=320
I V4L2Camera: Cropping from origin: 584x440 - size: 432x320  (offset:1409168)
D V4L2Camera: lineNum:293 timeperframe.denominator=30
I V4L2Camera: Actual format: (1600 x 1200), Fps: 5, pixfmt: 'YUYV', bytesperline: 3200
D CameraHardware: CameraHardware::startPreviewLocked: effective size: 432x320
D CameraHardware: CameraHardware::initHeapLocked
D CameraHardware: CameraHardware::initHeapLocked: preview size=432x320
D CameraHardware: CameraHardware::initHeapLocked: picture size=432x320
D CameraHardware: CameraHardware::initHeapLocked: video size=1600x1200
D CameraHardware: CameraHardware::initHeapLocked: OK
D CameraHardware: CameraHardware::startPreviewLocked: StartStreaming
D CameraHardware: CameraHardware::setPreviewWindow - Negotiating preview format
D CameraHardware: CameraHardware::NegotiatePreviewFormat
D CameraHardware: Trying to set preview window geometry to 432x320
D CameraHardware: CameraHardware::startPreviewLocked: starting PreviewThread
D CameraHardware: CameraHardware::startPreviewLocked: O - this:0x0xea34f180
V CAM_CameraAppUI: onPreviewStarted
```

从上述打印出来的信息来看，暴露出两个问题：

1. 为何传入进来的是 432x320

2. 设置的fps = 30, 在次读的时候为 5

   

这里采用栈回溯， 追明白在那被赋值为 432x320

```shell
#00 pc 00013b9b  /system/lib/hw/camera.x86.so -> Init()
#01 pc 0000a3b2  /system/lib/hw/camera.x86.so -> CameraHardware.cpp:490
#02 pc 0000c384  /system/lib/hw/camera.x86.so -> CameraHardware.cpp:541
#03 pc 0007a01f  /system/lib/libcameraservice.so 
#04 pc 00079de3  /system/lib/libcameraservice.so 
#05 pc 00079d10  /system/lib/libcameraservice.so 
#06 pc 000341a2  /system/lib/libcamera_client.so 
#07 pc 000346a1  /system/lib/libcamera_client.so 
#08 pc 000390c6  /system/lib/libbinder.so 
#09 pc 000480c0  /system/lib/libbinder.so 
#10 pc 00047acb  /system/lib/libbinder.so 
#11 pc 0004831f  /system/lib/libbinder.so 
#12 pc 0006ef3e  /system/lib/libbinder.so 
#13 pc 00012095  /system/lib/libutils.so 
#14 pc 00011883  /system/lib/libutils.so 
#15 pc 00086e5f  /system/lib/libc.so 
#16 pc 00022f40  /system/lib/libc.so 
#17 pc 000207a6  /system/lib/libc.so
```

```shell
CameraHardware::startPreview() ->
CameraHardware::startPreviewLocked() ->
V4L2Camera::Init(int width, int height, int fps) 
```

从上述调用栈中可以看出， width height 是在 startPreviewLocked 赋值的

```c
// CameraHardware.cpp

status_t CameraHardware::startPreviewLocked()
{
    int width, height;

    // If we are recording, use the recording video size instead of the preview size
    // 如果是录像， 用录像 时的视屏大小去替代预览的视屏大小
    if (mRecordingEnabled && mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
        mParameters.getVideoSize(&width, &height);
    } else {
        mParameters.getPreviewSize(&width, &height);// 这里走的是这个分支 取的是 预览的 大小
    }    

    int fps = mParameters.getPreviewFrameRate();

    ALOGD("CameraHardware::startPreviewLocked: Open, %dx%d", width, height);

    status_t ret = camera.Open(mVideoDevice);
    if (ret != NO_ERROR) {
        ALOGE("Failed to initialize Camera");
        return ret; 
    }

    ALOGD("CameraHardware::startPreviewLocked: Init");
    ret = camera.Init(width, height, fps);
    if (ret != NO_ERROR) {
        ALOGE("Failed to setup streaming");                 
        return ret; 
    }    

    /* Retrieve the real size being used */
    camera.getSize(width, height);

    ALOGD("CameraHardware::startPreviewLocked: effective size: %dx%d",width, height);

    // If we are recording, use the recording video size instead of the preview size
    if (mRecordingEnabled && mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
        /* Store it as the video size to use */
ALOGD("%s %d %dx%d", __func__, __LINE__, width, height);
        mParameters.setVideoSize(width, height);
    } else {
        /* Store it as the preview size to use */
        // 这里会再次加载这个分支
ALOGD("%s %d %dx%d", __func__, __LINE__, width, height);
        mParameters.setPreviewSize(width, height);
    }
    ...
}
```

这里具体分析一下，getPreviewSize

```c
// hp-4.19/frameworks$ vim av/camera/CameraParameters.cpp
void CameraParameters::getPreviewSize(int *width, int *height) const
{
    *width = *height = -1; 
    // Get the current string, if it doesn't exist, leave the -1x-1 
    const char *p = get(KEY_PREVIEW_SIZE); // "preview-size"
    if (p == 0)  return;
    parse_pair(p, width, height, 'x');
}

const char *CameraParameters::get(const char *key) const
{
    String8 v = mMap.valueFor(String8(key));
    if (v.length() == 0)
        return 0;
    return v.string();
}


void CameraParameters::setPreviewSize(int width, int height)
{             
    char str[32];
    // 这里应该打一个调用栈 出来
    sprintf(str, "%dx%d", width, height);
    set(KEY_PREVIEW_SIZE, str);
}
// 这里重点追一下，在哪里调用的 setPreviewSize
```





// 480P

```shell
preferred-preview-size-for-video=640x480;preview-format=yuv422sp;preview-format-values=yuv422i-yuyv,yuv422sp,yuv420sp,yuv420p;preview-fps-range=30,30;preview-fps-range-values=(5,5),(25,25),(30,30);preview-frame-rate=30;preview-frame-rate-values=5,25,30;preview-size=432x320;preview-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320,1600x1200;recording-hint=true;rotation=0;rotation-values=0;scene-mode=auto;scene-mode-values=auto;smooth-zoom-supported=false;vertical-view-angle=90;video-frame-format=yuv420p;video-size=1600x1200;video-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320,1600x1200;whitebalance=auto;whitebalance-values=auto;zoom=0;zoom-ratios=100;zoom-supported=false
```



// 720P

```shell
preferred-preview-size-for-video=640x480;
preview-format=yuv422sp;
preview-format-values=yuv422i-yuyv,yuv422sp,yuv420sp,yuv420p;
preview-fps-range=30,30;
preview-fps-range-values=(5,5),(25,25),(30,30);
preview-frame-rate=30;
preview-frame-rate-values=5,25,30;
preview-size=432x320;
preview-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320,1600x1200;
recording-hint=true;
rotation=0;
rotation-values=0;
scene-mode=auto;
scene-mode-values=auto;
smooth-zoom-supported=false;
vertical-view-angle=90;
video-frame-format=yuv420p;
video-size=1600x1200;
video-size-values=176x144,240x160,320x200,320x240,352x288,432x320,480x320,1600x1200;
whitebalance=auto;
whitebalance-values=auto;
zoom=0;
zoom-ratios=100;
zoom-supported=false
```

### 2.3.2 问题解决：

问题初步定位到了， 是因为我们在拿 preview 的w h 的时候，拿的是  getPreviewSize ，应该拿这个 getVideoSize 

```c
status_t CameraHardware::startPreviewLocked()
{
    int width, height;

    // If we are recording, use the recording video size instead of the preview size
    // 如果是录像， 用录像 时的视屏大小去替代预览的视屏大小
    if (mRecordingEnabled && mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
        mParameters.getVideoSize(&width, &height);
    } else {
        // 把这个注销掉
        // mParameters.getPreviewSize(&width, &height);// 这里走的是这个分支 取的是 预览的 大小
		width = 1600;
        height = 1200;
        //mParameters.getVideoSize(&width, &height); // 使用这个， 后面会再次设置这个值，不用担心
    }    
...
}
```

这里直接将， w, h 都直接写死， 不去设置为动态可配置的

## 2.4 preview fps 低

问题 在前置，录像预览中，当我们向底层设置 fps=30, 没有成功，底层设置的是 fps = 5; 这个还需要进一步的去查；

### 2.4.1 问题定位

开启 kernel 中 uvc 相关的 dri log

```shell
echo 0xffff > /sys/module/uvcvideo/parameters/trace //打开
echo 0 > /sys/module/uvcvideo/parameters/trace //关闭
```



```shell
uvcvideo: uvc_v4l2_open                                                                                                                                                                                            
type=1400 audit(1569409239.668:5641): avc: denied { map } for pid=12984 comm="Binder:12984_1" path="/dev/ashmem" dev="tmpfs" ino=10501 scontext=u:r:cameraserver:s0 tcontext=u:object_r:ashmem_device:s0 tclass=chr

uvcvideo: Resuming interface 0
uvcvideo: Resuming interface 1
uvcvideo: Trying format 0x56595559 (YUYV): 1600x1200.
uvcvideo: Using default frame interval 200000.0 us (5.0 fps).
uvcvideo: Trying format 0x56595559 (YUYV): 1600x1200.
uvcvideo: Using default frame interval 200000.0 us (5.0 fps).
uvcvideo: Setting frame interval to 1/30 (333333).
uvcvideo: uvc_v4l2_mmap
uvcvideo: uvc_v4l2_mmap
uvcvideo: uvc_v4l2_mmap
uvcvideo: uvc_v4l2_mmap
uvcvideo: Device requested 3072 B/frame bandwidth.
uvcvideo: Selecting alternate setting 7 (3072 B/frame bandwidth).
uvcvideo: Allocated 5 URB buffers of 32x3072 bytes each.
uvcvideo: frame 1 stats: 0/0/1605 packets, 0/0/1605 pts (early !initial), 1604/1605 scr, last pts/stc/sof 0/8386954/1841
uvcvideo: Frame complete (EOF found).
uvcvideo: Dropping payload (out of sync).
```





# 3. 最终解决：

### 3.1 相机无法连接

相机录像时，无法连接： 注释掉 return BAD_VALUE;

```c
// libstagefright/CameraSource.cpp

status_t CameraSource::configureCamera(
        CameraParameters* params,
        int32_t width, int32_t height,
        int32_t frameRate) {
    
    ...
    if (!isVideoSizeSupported(width, height, sizes)) {
           ALOGE("Video dimension (%dx%d) is unsupported", width, height);
           //return BAD_VALUE; // 
       }
    ...
}
```

### 3.2 preview 和 录像时 分辨率

相机录像和预览分辨率不一致：

```c
// frameworks/base/media/jni/android_media_MediaRecorder.cpp

static void
android_media_MediaRecorder_setVideoSize(JNIEnv *env, jobject thiz, jint width, jint height)
{                     
#define FIX_BEFORE 0
#if FIX_BEFORE
#else
    width = 1600; 
    height = 1200;
#endif
    ALOGV("setVideoSize(%d, %d)", width, height);
    sp<MediaRecorder> mr = getMediaRecorder(env, thiz);

    if (width <= 0 || height <= 0) {
        jniThrowException(env, "java/lang/IllegalArgumentException", "invalid video size");
        return;
    }   
    process_media_recorder_call(env, mr->setVideoSize(width, height), "java/lang/RuntimeException", "setVideoSize failed.");
} // 这里是固定 录像时分辨率的写法
```

```c
// 这里记录将预览写死的改法：
// hardware/libcamera/V4L2Camera.cpp

status_t CameraHardware::startPreviewLocked()
{
    ALOGD("CameraHardware::startPreviewLocked");

    if (mPreviewThread != 0) { 
        ALOGD("CameraHardware::startPreviewLocked: preview already running");
        return NO_ERROR;
    }    

    int width, height;

    // If we are recording, use the recording video size instead of the preview size
    if (mRecordingEnabled && mMsgEnabled & CAMERA_MSG_VIDEO_FRAME) {
        mParameters.getVideoSize(&width, &height);
    } else {

        // CHAOZHUO start 
    
#define FIXED_BEFORE 0                  
#if FIXED_BEFORE
        mParameters.getPreviewSize(&width, &height);
#else
        width = 1600;
        height = 1200;
#endif
        // CHAOZHUO end
    }

    int fps = mParameters.getPreviewFrameRate();


..........

}
```

### 3.3 前后摄像头切换

前后摄像头无法切换：

```c
// hp-4.19/hardware/libcamera/CameraFactory.cpp

+// CHAOZHUO BEGIN
+#define DEFAULT_DEVICE_FRONT "/dev/video0"
+#define DEFAULT_DEVICE_BACK  "/dev/video1"
+// CHAOZHUO END
```

### 3.4 前置有多个设置

当我们设置摄像头的分辨率的时候，会出现很多的选项，由于preview 和 拍照不同，这样，看到的和最后拍的照片画面出现不一致，这里直接将这个设置窗口干掉。

```java
// hp-4.19/packages/apps/Camera2/src/com/android/camera/settings/PictureSizeLoader.java

private List<Size> computeSizesForCamera(CameraDeviceSelector facingSelector) {
        List<Size> sizes;
        int cameraId = SettingsUtil.getCameraId(mCameraDeviceInfo, facingSelector);
        if (cameraId >= 0) {
            if (mCachedOnly) {
                sizes = CameraPictureSizesCacher.getCachedSizesForCamera(cameraId, mContext)
                        .orNull();
            } else {
                // 从这里从 c 层去拿的 相机所支持的参数
                sizes = CameraPictureSizesCacher.getSizesForCamera(cameraId, mContext);
            }

            if (sizes != null) {
                // 这里将相机 底层参数全部清除掉，然后自己写一个，这样，上层就没法在获取了
                // CHAOZHUO-start
                sizes.clear();
                sizes.add(new Size(1600, 1200));
				// CHAOZHUO-end
                sizes = ResolutionUtil
                        .getDisplayableSizesFromSupported(sizes,
                                facingSelector == SettingsUtil.CAMERA_FACING_BACK);
                String blacklisted = GservicesHelper
                        .getBlacklistedResolutionsBack(mContentResolver);
                sizes = ResolutionUtil.filterBlackListedSizes(sizes, blacklisted);
                return sizes;
            }
        }
        return new ArrayList<>(0);
    }
```

