commit 4ff8aedb85ad79baf00c906bb21f8cdac75205a4
Author: caobinxin <caobinxin@phoenixos.com>
Date:   Fri Oct 11 14:50:16 2019 +0800

    [phoenix] temp: uvc camera debug
    
    Signed-off-by: caobinxin <caobinxin@phoenixos.com>

diff --git a/arch/x86/configs/android-x86_64_defconfig b/arch/x86/configs/android-x86_64_defconfig
index aeaddba798e7..3ef807aa64a5 100644
--- a/arch/x86/configs/android-x86_64_defconfig
+++ b/arch/x86/configs/android-x86_64_defconfig
@@ -7662,7 +7662,7 @@ CONFIG_SBITMAP=y
 CONFIG_PRINTK_TIME=y
 CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
 CONFIG_CONSOLE_LOGLEVEL_QUIET=4
-CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=8
 # CONFIG_BOOT_PRINTK_DELAY is not set
 CONFIG_DYNAMIC_DEBUG=y
 
diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
index 778b2d1233c8..6c9e5154b929 100644
--- a/drivers/media/usb/uvc/uvc_driver.c
+++ b/drivers/media/usb/uvc/uvc_driver.c
@@ -407,6 +407,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 	unsigned int interval;
 	unsigned int i, n;
 	u8 ftype;
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 
 	format->type = buffer[2];
 	format->index = buffer[3];
@@ -414,8 +415,10 @@ static int uvc_parse_format(struct uvc_device *dev,
 	switch (buffer[2]) {
 	case UVC_VS_FORMAT_UNCOMPRESSED:
 	case UVC_VS_FORMAT_FRAME_BASED:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		n = buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED ? 27 : 28;
 		if (buflen < n) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
 			       dev->udev->devnum,
@@ -424,13 +427,16 @@ static int uvc_parse_format(struct uvc_device *dev,
 		}
 
 		/* Find the format descriptor from its GUID. */
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		fmtdesc = uvc_format_by_guid(&buffer[5]);
 
 		if (fmtdesc != NULL) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			strlcpy(format->name, fmtdesc->name,
 				sizeof(format->name));
 			format->fcc = fmtdesc->fcc;
 		} else {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_printk(KERN_INFO, "Unknown video format %pUl\n",
 				&buffer[5]);
 			snprintf(format->name, sizeof(format->name), "%pUl\n",
@@ -438,13 +444,16 @@ static int uvc_parse_format(struct uvc_device *dev,
 			format->fcc = 0;
 		}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		format->bpp = buffer[21];
 
 		/* Some devices report a format that doesn't match what they
 		 * really send.
 		 */
 		if (dev->quirks & UVC_QUIRK_FORCE_Y8) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			if (format->fcc == V4L2_PIX_FMT_YUYV) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 				strlcpy(format->name, "Greyscale 8-bit (Y8  )",
 					sizeof(format->name));
 				format->fcc = V4L2_PIX_FMT_GREY;
@@ -454,16 +463,22 @@ static int uvc_parse_format(struct uvc_device *dev,
 		}
 
 		if (buffer[2] == UVC_VS_FORMAT_UNCOMPRESSED) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			ftype = UVC_VS_FRAME_UNCOMPRESSED;
 		} else {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			ftype = UVC_VS_FRAME_FRAME_BASED;
-			if (buffer[27])
+			if (buffer[27]){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 				format->flags = UVC_FMT_FLAG_COMPRESSED;
+			}
 		}
 		break;
 
 	case UVC_VS_FORMAT_MJPEG:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		if (buflen < 11) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
 			       dev->udev->devnum,
@@ -476,10 +491,13 @@ static int uvc_parse_format(struct uvc_device *dev,
 		format->flags = UVC_FMT_FLAG_COMPRESSED;
 		format->bpp = 0;
 		ftype = UVC_VS_FRAME_MJPEG;
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		break;
 
 	case UVC_VS_FORMAT_DV:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		if (buflen < 9) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FORMAT error\n",
 			       dev->udev->devnum,
@@ -489,15 +507,19 @@ static int uvc_parse_format(struct uvc_device *dev,
 
 		switch (buffer[8] & 0x7f) {
 		case 0:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			strlcpy(format->name, "SD-DV", sizeof(format->name));
 			break;
 		case 1:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			strlcpy(format->name, "SDL-DV", sizeof(format->name));
 			break;
 		case 2:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			strlcpy(format->name, "HD-DV", sizeof(format->name));
 			break;
 		default:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d: unknown DV format %u\n",
 			       dev->udev->devnum,
@@ -505,6 +527,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 			return -EINVAL;
 		}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		strlcat(format->name, buffer[8] & (1 << 7) ? " 60Hz" : " 50Hz",
 			sizeof(format->name));
 
@@ -521,12 +544,14 @@ static int uvc_parse_format(struct uvc_device *dev,
 		frame->dwFrameInterval = *intervals;
 		*(*intervals)++ = 1;
 		format->nframes = 1;
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		break;
 
 	case UVC_VS_FORMAT_MPEG2TS:
 	case UVC_VS_FORMAT_STREAM_BASED:
 		/* Not supported yet. */
 	default:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 		       "interface %d unsupported format %u\n",
 		       dev->udev->devnum, alts->desc.bInterfaceNumber,
@@ -539,40 +564,48 @@ static int uvc_parse_format(struct uvc_device *dev,
 	buflen -= buffer[0];
 	buffer += buffer[0];
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 	/* Parse the frame descriptors. Only uncompressed, MJPEG and frame
 	 * based formats have frame descriptors.
 	 */
 	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
 	       buffer[2] == ftype) {
+printk(KERN_ERR"%s %d format->nframes=%d\n", __func__, __LINE__, format->nframes);
 		frame = &format->frame[format->nframes];
-		if (ftype != UVC_VS_FRAME_FRAME_BASED)
+		if (ftype != UVC_VS_FRAME_FRAME_BASED){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			n = buflen > 25 ? buffer[25] : 0;
-		else
+		}else{
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			n = buflen > 21 ? buffer[21] : 0;
-
-		n = n ? n : 3;
+		}
+printk("n=%d\n", n);
+		n = n ? n : 3;printk("n=%d\n", n);
 
 		if (buflen < 26 + 4*n) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d FRAME error\n", dev->udev->devnum,
 			       alts->desc.bInterfaceNumber);
 			return -EINVAL;
 		}
 
-		frame->bFrameIndex = buffer[3];
-		frame->bmCapabilities = buffer[4];
+		frame->bFrameIndex = buffer[3]; 						printk("frame->bFrameIndex=%d\n", frame->bFrameIndex);
+		frame->bmCapabilities = buffer[4]; 						printk("frame->bmCapabilities=%d\n", frame->bmCapabilities);
 		frame->wWidth = get_unaligned_le16(&buffer[5])
 			      * width_multiplier;
-		frame->wHeight = get_unaligned_le16(&buffer[7]);
+		frame->wHeight = get_unaligned_le16(&buffer[7]); 		printk("frame->wHeight=%d\n", frame->wHeight);
 		frame->dwMinBitRate = get_unaligned_le32(&buffer[9]);
 		frame->dwMaxBitRate = get_unaligned_le32(&buffer[13]);
 		if (ftype != UVC_VS_FRAME_FRAME_BASED) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			frame->dwMaxVideoFrameBufferSize =
 				get_unaligned_le32(&buffer[17]);
 			frame->dwDefaultFrameInterval =
-				get_unaligned_le32(&buffer[21]);
-			frame->bFrameIntervalType = buffer[25];
+				get_unaligned_le32(&buffer[21]); 				printk("frame->dwDefaultFrameInterval=%d\n", frame->dwDefaultFrameInterval);
+			frame->bFrameIntervalType = buffer[25]; 			printk("frame->bFrameIntervalType=%d\n", frame->bFrameIntervalType);
 		} else {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			frame->dwMaxVideoFrameBufferSize = 0;
 			frame->dwDefaultFrameInterval =
 				get_unaligned_le32(&buffer[17]);
@@ -580,6 +613,7 @@ static int uvc_parse_format(struct uvc_device *dev,
 		}
 		frame->dwFrameInterval = *intervals;
 
+printk(KERN_ERR"%s %d frame->dwFrameInterval=%d\n", __func__, __LINE__,*frame->dwFrameInterval );
 		/* Several UVC chipsets screw up dwMaxVideoFrameBufferSize
 		 * completely. Observed behaviours range from setting the
 		 * value to 1.1x the actual frame size to hardwiring the
@@ -588,9 +622,11 @@ static int uvc_parse_format(struct uvc_device *dev,
 		 * uncompressed formats this can be fixed by computing the
 		 * value from the frame size.
 		 */
-		if (!(format->flags & UVC_FMT_FLAG_COMPRESSED))
+		if (!(format->flags & UVC_FMT_FLAG_COMPRESSED)){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			frame->dwMaxVideoFrameBufferSize = format->bpp
 				* frame->wWidth * frame->wHeight / 8;
+			}
 
 		/* Some bogus devices report dwMinFrameInterval equal to
 		 * dwMaxFrameInterval and have dwFrameIntervalStep set to
@@ -598,8 +634,10 @@ static int uvc_parse_format(struct uvc_device *dev,
 		 * some other divisions by zero that could happen.
 		 */
 		for (i = 0; i < n; ++i) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			interval = get_unaligned_le32(&buffer[26+4*i]);
-			*(*intervals)++ = interval ? interval : 1;
+			*(*intervals)++ = interval ? interval : 1; 					
+			
 		}
 
 		/* Make sure that the default frame interval stays between
@@ -610,8 +648,14 @@ static int uvc_parse_format(struct uvc_device *dev,
 			min(frame->dwFrameInterval[n],
 			    max(frame->dwFrameInterval[0],
 				frame->dwDefaultFrameInterval));
+printk(KERN_ERR"%s %d frame->dwFrameInterval[%d]=%d frame->dwFrameInterval[0]=%d frame->dwDefaultFrameInterval=%d \n", __func__, __LINE__,n,
+		frame->dwFrameInterval[n],
+		frame->dwFrameInterval[0],
+		frame->dwDefaultFrameInterval
+		);
 
 		if (dev->quirks & UVC_QUIRK_RESTRICT_FRAME_RATE) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			frame->bFrameIntervalType = 1;
 			frame->dwFrameInterval[0] =
 				frame->dwDefaultFrameInterval;
@@ -623,19 +667,23 @@ static int uvc_parse_format(struct uvc_device *dev,
 			(100000000/frame->dwDefaultFrameInterval)%10);
 
 		format->nframes++;
+printk(KERN_ERR"%s %d format->nframes=%d\n", __func__, __LINE__, format->nframes);
 		buflen -= buffer[0];
 		buffer += buffer[0];
 	}
 
 	if (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
 	    buffer[2] == UVC_VS_STILL_IMAGE_FRAME) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		buflen -= buffer[0];
 		buffer += buffer[0];
 	}
 
 	if (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE &&
 	    buffer[2] == UVC_VS_COLORFORMAT) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		if (buflen < 6) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			       "interface %d COLORFORMAT error\n",
 			       dev->udev->devnum,
@@ -644,11 +692,13 @@ static int uvc_parse_format(struct uvc_device *dev,
 		}
 
 		format->colorspace = uvc_colorspace(buffer[3]);
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 
 		buflen -= buffer[0];
 		buffer += buffer[0];
 	}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 	return buffer - start;
 }
 
@@ -667,8 +717,11 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	u16 psize;
 	int ret = -EINVAL;
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
+
 	if (intf->cur_altsetting->desc.bInterfaceSubClass
 		!= UVC_SC_VIDEOSTREAMING) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d interface %d isn't a "
 			"video streaming interface\n", dev->udev->devnum,
 			intf->altsetting[0].desc.bInterfaceNumber);
@@ -676,6 +729,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	}
 
 	if (usb_driver_claim_interface(&uvc_driver.driver, intf, dev)) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d interface %d is already "
 			"claimed\n", dev->udev->devnum,
 			intf->altsetting[0].desc.bInterfaceNumber);
@@ -684,6 +738,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 	streaming = kzalloc(sizeof(*streaming), GFP_KERNEL);
 	if (streaming == NULL) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		usb_driver_release_interface(&uvc_driver.driver, intf);
 		return -EINVAL;
 	}
@@ -697,7 +752,9 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	 * after the endpoint descriptors.
 	 */
 	if (buflen == 0) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		for (i = 0; i < alts->desc.bNumEndpoints; ++i) {
+printk(KERN_ERR"%s %d i=%d\n", __func__, __LINE__, i);
 			struct usb_host_endpoint *ep = &alts->endpoint[i];
 
 			if (ep->extralen == 0)
@@ -709,6 +766,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 					"from endpoint %u.\n", i);
 				buffer = alts->endpoint[i].extra;
 				buflen = alts->endpoint[i].extralen;
+printk(KERN_ERR"%s %d buffer=%s buflen=%d\n", __func__, __LINE__, buffer , buflen);
 				break;
 			}
 		}
@@ -718,9 +776,11 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	while (buflen > 2 && buffer[1] != USB_DT_CS_INTERFACE) {
 		buflen -= buffer[0];
 		buffer += buffer[0];
+printk(KERN_ERR"%s %d buffer=%s buflen=%d\n", __func__, __LINE__, buffer , buflen);
 	}
 
 	if (buflen <= 2) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "no class-specific streaming "
 			"interface descriptors found.\n");
 		goto error;
@@ -729,16 +789,19 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	/* Parse the header descriptor. */
 	switch (buffer[2]) {
 	case UVC_VS_OUTPUT_HEADER:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		streaming->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
 		size = 9;
 		break;
 
 	case UVC_VS_INPUT_HEADER:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		streaming->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 		size = 13;
 		break;
 
 	default:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
 			"%d HEADER descriptor not found.\n", dev->udev->devnum,
 			alts->desc.bInterfaceNumber);
@@ -749,6 +812,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	n = buflen >= size ? buffer[size-1] : 0;
 
 	if (buflen < size + p*n) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 			"interface %d HEADER descriptor is invalid.\n",
 			dev->udev->devnum, alts->desc.bInterfaceNumber);
@@ -758,12 +822,20 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	streaming->header.bNumFormats = p;
 	streaming->header.bEndpointAddress = buffer[6];
 	if (buffer[2] == UVC_VS_INPUT_HEADER) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		streaming->header.bmInfo = buffer[7];
 		streaming->header.bTerminalLink = buffer[8];
 		streaming->header.bStillCaptureMethod = buffer[9];
 		streaming->header.bTriggerSupport = buffer[10];
 		streaming->header.bTriggerUsage = buffer[11];
+printk(KERN_ERR"bmInfo=%d\nbTerminalLink=%d\nbStillCaptureMethod=%d\nbTriggerSupport=%d\nbTriggerUsage=%d\n",
+        streaming->header.bmInfo,
+        streaming->header.bTerminalLink,
+        streaming->header.bStillCaptureMethod,
+        streaming->header.bTriggerSupport,
+        streaming->header.bTriggerUsage);
 	} else {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		streaming->header.bTerminalLink = buffer[7];
 	}
 	streaming->header.bControlSize = n;
@@ -771,6 +843,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 	streaming->header.bmaControls = kmemdup(&buffer[size], p * n,
 						GFP_KERNEL);
 	if (streaming->header.bmaControls == NULL) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		ret = -ENOMEM;
 		goto error;
 	}
@@ -783,14 +856,18 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 	/* Count the format and frame descriptors. */
 	while (_buflen > 2 && _buffer[1] == USB_DT_CS_INTERFACE) {
+printk(KERN_ERR"%s %d _buffer[2]=%x\n", __func__, __LINE__, _buffer[2]);
 		switch (_buffer[2]) {
 		case UVC_VS_FORMAT_UNCOMPRESSED:
 		case UVC_VS_FORMAT_MJPEG:
 		case UVC_VS_FORMAT_FRAME_BASED:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			nformats++;
+printk(KERN_ERR"nformats=%d\n", nformats);
 			break;
 
 		case UVC_VS_FORMAT_DV:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			/* DV format has no frame descriptor. We will create a
 			 * dummy frame descriptor with a dummy frame interval.
 			 */
@@ -801,6 +878,7 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 		case UVC_VS_FORMAT_MPEG2TS:
 		case UVC_VS_FORMAT_STREAM_BASED:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming "
 				"interface %d FORMAT %u is not supported.\n",
 				dev->udev->devnum,
@@ -809,23 +887,30 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 		case UVC_VS_FRAME_UNCOMPRESSED:
 		case UVC_VS_FRAME_MJPEG:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			nframes++;
-			if (_buflen > 25)
+printk(KERN_ERR"nformats=%d\n", nformats);
+			if (_buflen > 25){
 				nintervals += _buffer[25] ? _buffer[25] : 3;
+printk(KERN_ERR"nintervals=%d _buffer[25]=%d\n", nintervals, _buffer[25]);
+			}
 			break;
 
 		case UVC_VS_FRAME_FRAME_BASED:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			nframes++;
 			if (_buflen > 21)
 				nintervals += _buffer[21] ? _buffer[21] : 3;
 			break;
 		}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		_buflen -= _buffer[0];
 		_buffer += _buffer[0];
 	}
 
 	if (nformats == 0) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_DESCR, "device %d videostreaming interface "
 			"%d has no supported formats defined.\n",
 			dev->udev->devnum, alts->desc.bInterfaceNumber);
@@ -834,12 +919,17 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 	size = nformats * sizeof(*format) + nframes * sizeof(*frame)
 	     + nintervals * sizeof(*interval);
+
 	format = kzalloc(size, GFP_KERNEL);
+	printk( "format=%p size=%d=%d+%d+%d\n", format ,size, nformats * sizeof(*format), nframes * sizeof(*frame), nintervals * sizeof(*interval));
+printk(KERN_ERR" nformats=%d nframes=%d nintervals=%d size=%d\n", nformats, nframes, nintervals, size);
 	if (format == NULL) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		ret = -ENOMEM;
 		goto error;
 	}
 
+printk(KERN_ERR"nformats=%d nframes=%d\n", nformats, nframes);
 	frame = (struct uvc_frame *)&format[nformats];
 	interval = (u32 *)&frame[nframes];
 
@@ -848,11 +938,13 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 	/* Parse the format descriptors. */
 	while (buflen > 2 && buffer[1] == USB_DT_CS_INTERFACE) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		switch (buffer[2]) {
 		case UVC_VS_FORMAT_UNCOMPRESSED:
 		case UVC_VS_FORMAT_MJPEG:
 		case UVC_VS_FORMAT_DV:
 		case UVC_VS_FORMAT_FRAME_BASED:
+printk(KERN_ERR"%s %d buffer[2]=%d\n", __func__, __LINE__, buffer[2]);
 			format->frame = frame;
 			ret = uvc_parse_format(dev, streaming, format,
 				&interval, buffer, buflen);
@@ -867,9 +959,11 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 			continue;
 
 		default:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			break;
 		}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		buflen -= buffer[0];
 		buffer += buffer[0];
 	}
@@ -881,23 +975,30 @@ static int uvc_parse_streaming(struct uvc_device *dev,
 
 	/* Parse the alternate settings to find the maximum bandwidth. */
 	for (i = 0; i < intf->num_altsetting; ++i) {
+printk(KERN_ERR"%s %d i=%d\n", __func__, __LINE__, i);
 		struct usb_host_endpoint *ep;
 		alts = &intf->altsetting[i];
 		ep = uvc_find_endpoint(alts,
 				streaming->header.bEndpointAddress);
-		if (ep == NULL)
+		if (ep == NULL){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			continue;
+		}
 
 		psize = le16_to_cpu(ep->desc.wMaxPacketSize);
 		psize = (psize & 0x07ff) * (1 + ((psize >> 11) & 3));
-		if (psize > streaming->maxpsize)
+		if (psize > streaming->maxpsize){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			streaming->maxpsize = psize;
+		}
 	}
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 	list_add_tail(&streaming->list, &dev->streams);
 	return 0;
 
 error:
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 	usb_driver_release_interface(&uvc_driver.driver, intf);
 	usb_put_intf(intf);
 	kfree(streaming->format);
diff --git a/drivers/media/usb/uvc/uvc_v4l2.c b/drivers/media/usb/uvc/uvc_v4l2.c
index 18a7384b50ee..7ae89835c908 100644
--- a/drivers/media/usb/uvc/uvc_v4l2.c
+++ b/drivers/media/usb/uvc/uvc_v4l2.c
@@ -108,32 +108,47 @@ static int uvc_ioctl_ctrl_map(struct uvc_video_chain *chain,
 static u32 uvc_try_frame_interval(struct uvc_frame *frame, u32 interval)
 {
 	unsigned int i;
-
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 	if (frame->bFrameIntervalType) {
 		u32 best = -1, dist;
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		for (i = 0; i < frame->bFrameIntervalType; ++i) {
 			dist = interval > frame->dwFrameInterval[i]
 			     ? interval - frame->dwFrameInterval[i]
 			     : frame->dwFrameInterval[i] - interval;
-
-			if (dist > best)
+printk(KERN_ERR"i=%d dist=%d interval=%d frame->dwFrameInterval[%d]=%d best=%d\n", i, dist, interval, i,frame->dwFrameInterval[i], best);
+			if (dist > best){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 				break;
+			}
 
 			best = dist;
 		}
 
+printk(KERN_ERR"interval = %d\n",interval);
 		interval = frame->dwFrameInterval[i-1];
+printk(KERN_ERR"interval = %d\n",interval);
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
+	
 	} else {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		const u32 min = frame->dwFrameInterval[0];
 		const u32 max = frame->dwFrameInterval[1];
 		const u32 step = frame->dwFrameInterval[2];
 
+printk(KERN_ERR"min=%d max=%d step=%d\n", min, max, step);
+
+printk(KERN_ERR"interval = %d\n",interval);
 		interval = min + (interval - min + step/2) / step * step;
-		if (interval > max)
+printk(KERN_ERR"interval = %d\n",interval);
+		if (interval > max){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			interval = max;
+		}
 	}
 
+printk(KERN_ERR"interval = %d\n",interval);
 	return interval;
 }
 
@@ -165,11 +180,12 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	int ret = 0;
 	u8 *fcc;
 
+printk("%s %d\n", __func__, __LINE__);
 	if (fmt->type != stream->type)
 		return -EINVAL;
 
 	fcc = (u8 *)&fmt->fmt.pix.pixelformat;
-	uvc_trace(UVC_TRACE_FORMAT, "Trying format 0x%08x (%c%c%c%c): %ux%u.\n",
+	printk( "Trying format 0x%08x (%c%c%c%c): %ux%u.\n",
 			fmt->fmt.pix.pixelformat,
 			fcc[0], fcc[1], fcc[2], fcc[3],
 			fmt->fmt.pix.width, fmt->fmt.pix.height);
@@ -178,12 +194,16 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	 * format otherwise.
 	 */
 	for (i = 0; i < stream->nformats; ++i) {
+printk("%s %d i=%d\n", __func__, __LINE__, i);
 		format = &stream->format[i];
-		if (format->fcc == fmt->fmt.pix.pixelformat)
+		if (format->fcc == fmt->fmt.pix.pixelformat){
+printk("%s %d\n", __func__, __LINE__);
 			break;
+		}
 	}
 
 	if (i == stream->nformats) {
+printk("%s %d\n", __func__, __LINE__);
 		format = stream->def_format;
 		fmt->fmt.pix.pixelformat = format->fcc;
 	}
@@ -196,22 +216,30 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	rh = fmt->fmt.pix.height;
 	maxd = (unsigned int)-1;
 
+printk("%s %d\n", __func__, __LINE__);
 	for (i = 0; i < format->nframes; ++i) {
+printk("%s %d i=%d\n", __func__, __LINE__, i);
 		u16 w = format->frame[i].wWidth;
 		u16 h = format->frame[i].wHeight;
+printk("w=%d rw=%d h=%d rh=%d\n", w, rw, h,rh);
 
 		d = min(w, rw) * min(h, rh);
 		d = w*h + rw*rh - 2*d;
+printk("d=%d maxd=%d\n", d, maxd);
 		if (d < maxd) {
+printk("%s %d\n", __func__, __LINE__);
 			maxd = d;
 			frame = &format->frame[i];
 		}
 
-		if (maxd == 0)
+		if (maxd == 0){
+printk("%s %d\n", __func__, __LINE__);
 			break;
+		}
 	}
 
 	if (frame == NULL) {
+printk("%s %d\n", __func__, __LINE__);
 		uvc_trace(UVC_TRACE_FORMAT, "Unsupported size %ux%u.\n",
 				fmt->fmt.pix.width, fmt->fmt.pix.height);
 		return -EINVAL;
@@ -219,16 +247,16 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 
 	/* Use the default frame interval. */
 	interval = frame->dwDefaultFrameInterval;
-	uvc_trace(UVC_TRACE_FORMAT, "Using default frame interval %u.%u us "
+printk("Using default frame interval %u.%u us "
 		"(%u.%u fps).\n", interval/10, interval%10, 10000000/interval,
 		(100000000/interval)%10);
 
 	/* Set the format index, frame index and frame interval. */
 	memset(probe, 0, sizeof(*probe));
 	probe->bmHint = 1;	/* dwFrameInterval */
-	probe->bFormatIndex = format->index;
-	probe->bFrameIndex = frame->bFrameIndex;
-	probe->dwFrameInterval = uvc_try_frame_interval(frame, interval);
+	probe->bFormatIndex = format->index; 								printk("probe->bFormatIndex=%d\n", probe->bFormatIndex);
+	probe->bFrameIndex = frame->bFrameIndex; 							printk("probe->bFrameIndex=%d\n", probe->bFrameIndex);
+	probe->dwFrameInterval = uvc_try_frame_interval(frame, interval);  	printk("probe->dwFrameInterval=%d\n", probe->dwFrameInterval);
 	/* Some webcams stall the probe control set request when the
 	 * dwMaxVideoFrameSize field is set to zero. The UVC specification
 	 * clearly states that the field is read-only from the host, so this
@@ -242,9 +270,11 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	 * the Windows driver).
 	 */
 	mutex_lock(&stream->mutex);
-	if (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)
+	if (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS){
 		probe->dwMaxVideoFrameSize =
 			stream->ctrl.dwMaxVideoFrameSize;
+printk("%s %d\n", __func__, __LINE__);
+	}
 
 	/* Probe the device. */
 	ret = uvc_probe_video(stream, probe);
@@ -252,20 +282,26 @@ static int uvc_v4l2_try_format(struct uvc_streaming *stream,
 	if (ret < 0)
 		goto done;
 
-	fmt->fmt.pix.width = frame->wWidth;
-	fmt->fmt.pix.height = frame->wHeight;
+	fmt->fmt.pix.width = frame->wWidth; 										printk("fmt->fmt.pix.width=%d\n", fmt->fmt.pix.width);
+	fmt->fmt.pix.height = frame->wHeight; 										printk("fmt->fmt.pix.height=%d\n", fmt->fmt.pix.height);
 	fmt->fmt.pix.field = V4L2_FIELD_NONE;
-	fmt->fmt.pix.bytesperline = uvc_v4l2_get_bytesperline(format, frame);
-	fmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize;
+	fmt->fmt.pix.bytesperline = uvc_v4l2_get_bytesperline(format, frame); 		printk("fmt->fmt.pix.bytesperline=%d\n", fmt->fmt.pix.bytesperline);
+	fmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize; 						printk("fmt->fmt.pix.sizeimage=%d\n", fmt->fmt.pix.sizeimage);
 	fmt->fmt.pix.colorspace = format->colorspace;
 	fmt->fmt.pix.priv = 0;
 
-	if (uvc_format != NULL)
+printk("%s %d\n", __func__, __LINE__);
+	if (uvc_format != NULL){
+printk("%s %d\n", __func__, __LINE__);
 		*uvc_format = format;
-	if (uvc_frame != NULL)
+	}
+	if (uvc_frame != NULL){
 		*uvc_frame = frame;
+printk("%s %d\n", __func__, __LINE__);
+	}
 
 done:
+printk("%s %d\n", __func__, __LINE__);
 	return ret;
 }
 
@@ -379,13 +415,19 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	unsigned int i;
 	int ret;
 
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
+dump_stack();
+
 	if (parm->type != stream->type)
 		return -EINVAL;
 
-	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		timeperframe = parm->parm.capture.timeperframe;
-	else
+	}else{
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		timeperframe = parm->parm.output.timeperframe;
+	}
 
 	interval = uvc_fraction_to_interval(timeperframe.numerator,
 		timeperframe.denominator);
@@ -395,6 +437,7 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	mutex_lock(&stream->mutex);
 
 	if (uvc_queue_streaming(&stream->queue)) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		mutex_unlock(&stream->mutex);
 		return -EBUSY;
 	}
@@ -404,32 +447,56 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	probe = stream->ctrl;
 	probe.dwFrameInterval = uvc_try_frame_interval(frame, interval);
 	maxd = abs((s32)probe.dwFrameInterval - interval);
-
+printk(KERN_ERR"probe.dwFrameInterval=%u maxd=%u format->nframes=%d\n",probe.dwFrameInterval, maxd, format->nframes);
 	/* Try frames with matching size to find the best frame interval. */
 	for (i = 0; i < format->nframes && maxd != 0; i++) {
 		u32 d, ival;
 
-		if (&format->frame[i] == stream->cur_frame)
+		if (&format->frame[i] == stream->cur_frame){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			continue;
+		}
 
 		if (format->frame[i].wWidth != stream->cur_frame->wWidth ||
-		    format->frame[i].wHeight != stream->cur_frame->wHeight)
+		    format->frame[i].wHeight != stream->cur_frame->wHeight){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			continue;
+		}
 
 		ival = uvc_try_frame_interval(&format->frame[i], interval);
 		d = abs((s32)ival - interval);
-		if (d >= maxd)
+printk(KERN_ERR"i=%d ival=%d d=%d\n",i, ival, d);
+		if (d >= maxd){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 			continue;
+		}
 
 		frame = &format->frame[i];
 		probe.bFrameIndex = frame->bFrameIndex;
 		probe.dwFrameInterval = ival;
 		maxd = d;
+
+
+printk(KERN_ERR"for: wWidth=%d wHeight=%d probe.dwFrameInterval=%d maxd=%d\n",                                                                                                                                     
+        format->frame[i].wWidth,
+        format->frame[i].wHeight,
+        probe.bFrameIndex,
+        probe.dwFrameInterval,
+        maxd);
 	}
 
+printk(KERN_ERR"for-end: i=%d wWidth=%d wHeight=%d probe.dwFrameInterval=%d maxd=%d\n", i,
+        format->frame[i].wWidth,
+        format->frame[i].wHeight,
+        probe.bFrameIndex,
+        probe.dwFrameInterval,
+        maxd);
+
+probe.dwFrameInterval = 333333;
 	/* Probe the device with the new settings. */
 	ret = uvc_probe_video(stream, &probe);
 	if (ret < 0) {
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		mutex_unlock(&stream->mutex);
 		return ret;
 	}
@@ -441,13 +508,18 @@ static int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,
 	/* Return the actual frame period. */
 	timeperframe.numerator = probe.dwFrameInterval;
 	timeperframe.denominator = 10000000;
+printk(KERN_ERR"Return the actual frame period: timeperframe.numerator=%d timeperframe.denominator=%d\n", timeperframe.numerator, timeperframe.denominator);	
 	uvc_simplify_fraction(&timeperframe.numerator,
 		&timeperframe.denominator, 8, 333);
+printk(KERN_ERR"Return the actual frame period: timeperframe.numerator=%d timeperframe.denominator=%d\n", timeperframe.numerator, timeperframe.denominator);	
 
-	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE){
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		parm->parm.capture.timeperframe = timeperframe;
-	else
+	}else{
+printk(KERN_ERR"%s %d\n", __func__, __LINE__);
 		parm->parm.output.timeperframe = timeperframe;
+	}
 
 	return 0;
 }
