我是参照如下分析　http://blog.sina.com.cn/s/blog_89f592f5010132qy.html

对phoenixos [android7.1]进行的分析

# 1. 总体调用关系图

![](00.分析.assets/89f592f5gc93e15c38ede.png)

Sensor 
框架分为三个层次，客户度、服务端、HAL层，服务端负责从HAL读取数据，并将数据写到管道中，客户端通过管道读取服务端数据。下面简单解释类的功能

## 1.1 客户端主要类

- SensorManager.java
  - 从　android4.1 开始，把SensorManager定义为一个抽象类，定义了一些主要的方法，类主要是应用层直接使用的类，提供给应用层的接口
  
- SystemSensorManager.java
  - 继承于SensorManager，客户端消息处理的实体，应用程序通过获取其实例，并注册监听接口，获取sensor数据
  - sensorEventListener接口
    - 用于注册监听的接口
  - sensorThread
    - 是SystemSensorManager的一个内部类，开启一个新线程负责读取读取sensor数据，当注册了sensorEventListener接口的时候才会启动线程
- android_hardware_SensorManager.cpp
  - 负责与java层通信的JNI接口
- SensorManager.cpp
  - sensor在Native层的客户端，负责与服务端SensorService.cpp的通信
- SenorEventQueue.cpp
  - 消息队列

## 1.2 服务端主要类

- SensorService.cpp
  - 服务端数据处理中心
  - SensorEventConnection
    - 从BnSensorEventConnection继承来，实现接口ISensorEventConnection的一些方法，ISensorEventConnection在SensorEventQueue会保存一个指针，指向调用服务接口创建的SensorEventConnection对象
- BitTube.cpp
  - 在这个类中创建了管道，即共享内存，用于服务端与客户端读写数据
- SensorDevice.cpp
  - 负责与HAL读取数据

## 1.3 HAL层

Sensor.h是google为Sensor定义的Hal接口，这里我们主要介绍Framework层。[sensor HAL介绍](http://blog.sina.com.cn/s/blog_89f592f5010130c8.html)<http://blog.sina.com.cn/s/blog_89f592f5010130c8.html>

# 2. 客户端读取数据

## 2.1 调用时序

![](00.分析.assets/89f592f5gc93e17b414bf.png)

## 2.2 代码分析

### 2.2.1 app层

在app 层中使用　sensor 时，只需要，　在Activity中实现 SensorEventListener  接口，并注册这个接口

#### 2.2.1.1 apk例子

```java
void onCreate(){
    ...
    SensorManager  mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);

 	Sensor mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    ...
}

protected void onResume() {
	super.onResume();
    mSensorManager.registerListenerImpl(this,
                                        mAccelerometer,
                                        SensorManager.SENSOR_DELAY_NORMAL);

	}

protected void onPause() {
           super.onPause();
         	mSensorManager.unregisterListener(this);
     }

void onSensorChanged(SensorEvent event){
    ...
}

void onAccuracyChanged(Sensor sensor, int accuracy){
    ...
}
```

```java
public interface SensorEventListener {
    public void onSensorChanged(SensorEvent event);
    public void onAccuracyChanged(Sensor sensor, int accuracy);
}
```

没有把全部代码写出来，Activity实现了SensorEventListener接口，在onCreate方法中，获取SystemSensorManager，并获取到加速传感器的Sensor，在onResume方法中调用SystemSensorManager.
registerListenerImpl注册监听器，当Sensor数据有改变的时候将会回调onSensorChanged方法。

#### 2.2.1.2 屏幕翻转例子

这个例子取自，屏幕翻转的例子。虽然这个例子是从framework中拿的。但，也属于应用层编程的范畴

```java
// frameworks$ vim ./base/services/core/java/com/android/server/policy/WindowOrientationListener.java

// [WindowOrientationListener.AccelSensorJudge]
public void onSensorChanged(SensorEvent event) {
    
    ...
        
    updatePredictedRotationLocked(now, nearestRotation);
    
    mProposedRotation = mPredictedRotation; // mPredictedRotation 在　updatePredictedRotationLocked　中被赋值的
    
    proposedRotation = mProposedRotation;
    
    // CHAOZHUO BEGIN
    if (proposedRotation == Surface.ROTATION_0 || proposedRotation == Surface.ROTATION_180) {
          onProposedRotationChanged(proposedRotation); // 在这个地方实现的屏幕翻转
    }
    // CHAOZHUO END
}


# 几个继承关系
class AccelSensorJudge extends OrientationJudge 
class OrientationJudge implements SensorEventListener

public interface SensorEventListener {
    public void onSensorChanged(SensorEvent event);
    public void onAccuracyChanged(Sensor sensor, int accuracy);
}
```

这部分相当是实现了　SensorEventListener　接口中的　onSensorChanged　函数。

在哪里注册的呢？

```java
// WindowOrientationListener.java
private Sensor mSensor;
String SENSOR_SERVICE = "sensor";
private SensorManager mSensorManager;

// [WindowOrientationListener]
private WindowOrientationListener(Context context, Handler handler, int rate) {
    // 构造函数

    mSensorManager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE); 
    
    mSensor = mSensorManager.getDefaultSensor(USE_GRAVITY_SENSOR
                    ? Sensor.TYPE_GRAVITY : Sensor.TYPE_ACCELEROMETER);
    
    mOrientationJudge = new AccelSensorJudge(context); // 这个就是我们的传感器的监听
}


// 注册的地方
// [WindowOrientationListener]
public void enable() {
    mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler);
    
    mEnabled = true;
}
```

到这里　可以对比　2.2.1.1 发现全部都可以对应上。

****

**这部分内容并不是本文分析的重点:**

这里暂时记录一下framework中调用　enable() 注册这个传感器监听的时机。

- 预备知识
  - class AudioWindowOrientationListener extends WindowOrientationListener
  - sWindowOrientationListener = new AudioWindowOrientationListener(context, handler);

```java
// RotationHelper.java

// [RotationHelper]
static void init(Context context, Handler handler) {
    sWindowOrientationListener = new AudioWindowOrientationListener(context, handler);
    sWindowOrientationListener.enable(); // 
}
```

```java
// AudioService.java

// [AudioService]　构造函数
public AudioService(Context context) {
    
    mMonitorRotation = SystemProperties.getBoolean("ro.audio.monitorRotation", false);
        if (mMonitorRotation) {
            RotationHelper.init(mContext, mAudioHandler);               
        }
}
```

从这里我们可以知道，android系统中，第一次，对屏幕方向监听的注册时机在　启动　AudioService　的时候

### 2.2.2 初始化 SystemSensorManager

1. SystemSensorManager extends SensorManager,
2. 在 app 中 (SensorManager)getSystemService(SENSOR_SERVICE);就是为了拿到　SystemSensorManager

现在来看 SystemSensorManager 的初始化。

```java
// SystemSensorManager.java
private final long mNativeInstance;

public SystemSensorManager(Context context, Looper mainLooper) {
        synchronized(sLock) {
            if (!sNativeClassInited) {
                sNativeClassInited = true;
                nativeClassInit(); // 分析
            }   
        }   

        mMainLooper = mainLooper;
        mTargetSdkLevel = context.getApplicationInfo().targetSdkVersion;
        mContext = context;
        mNativeInstance = nativeCreate(context.getOpPackageName());// 分析

        // initialize the sensor list
        for (int index = 0;;++index) {
            Sensor sensor = new Sensor(); // 在java层分配空间，却是在　c层进行填充
            if (!nativeGetSensorAtIndex(mNativeInstance, sensor, index)) break;   // 分析                                                                         
            mFullSensorsList.add(sensor);
            mHandleToSensor.put(sensor.getHandle(), sensor);
        }   
    } 
```

这里有三个函数：

1. nativeClassInit()
2. nativeCreate()
   - mNativeInstance 保存了　native 层中的　SensorManager(), 而SensorManager是用来连接SensorService的
3. nativeGetSensorAtIndex

  系统开机启动的时候，会创建SystemSensorManager的实例，在其构造函数中，主要做了四件事情：

- 初始化JNI

   	调用JNI函数nativeClassInit()进行初始化

- 初始化Sensor列表

  ​	 调用JNI函数nativeCreate，对Sensor模块进行初始化。创建了native层SensorManager的实例。

- 获取Sensor列表

   	调用JNI函数assertStateLocked()获取Sensor，并存在mSensorList列表中

- 构造SensorThread类

  ​	 构造线程的类函数，并没有启动线程，当有应用注册的时候才会启动线程

#### 2.2.2.1 nativeClassInit

```cpp
// android_hardware_SensorManager.cpp

static const JNINativeMethod gSystemSensorManagerMethods[] = { 
    {"nativeClassInit",
            "()V",
            (void*)nativeClassInit },
    {"nativeCreate",
             "(Ljava/lang/String;)J",
             (void*)nativeCreate },

    {"nativeGetSensorAtIndex",
            "(JLandroid/hardware/Sensor;I)Z",
            (void*)nativeGetSensorAtIndex },

}
```

![](00.分析.assets/2019-10-24 15-58-26 的屏幕截图.png)

#### 2.2.2.2 nativeCreate

```cpp
static jlong
nativeCreate
(JNIEnv *env, jclass clazz, jstring opPackageName)
{
    ScopedUtfChars opPackageNameUtf(env, opPackageName);
    return (jlong) &SensorManager::getInstanceForPackage(String16(opPackageNameUtf.c_str()));
}
```



```cpp
// SensorManager.cpp
SensorManager& SensorManager::getInstanceForPackage(const String16& packageName) {
    
    Mutex::Autolock _l(sLock);
    SensorManager* sensorManager;
    std::map<String16, SensorManager*>::iterator iterator =                         
        sPackageInstances.find(packageName);// 根据传入的包名　找到对应的 SensorManager

    if (iterator != sPackageInstances.end()) {
        sensorManager = iterator->second;
    } else {
        String16 opPackageName = packageName;

        ...
    
        sensorManager = new SensorManager(opPackageName);// 第一次创建包对应的　SensorManager

        // Stash the per package sensor manager.
        sPackageInstances.insert(std::make_pair(opPackageName, sensorManager));
    }

    return *sensorManager; // 这里在c 层创建的，却将对象保存在　java 层了，　符合动态对动态，静态对静态的思路
    
}
```



```cpp
// SensorManager.cpp 

// 构造函数
SensorManager::SensorManager(const String16& opPackageName)
    : mSensorList(0), mOpPackageName(opPackageName) {
    assertStateLocked();
}
```



```cpp
// SensorManager.cpp
status_t SensorManager::assertStateLocked() {
    ALOGE("colby %s %d\n", __func__, __LINE__);
    bool initSensorManager = false;
    if (mSensorServer == NULL) {
        initSensorManager = true;
    } else {
       ...
    }
    if (initSensorManager) {
        // try for 300 seconds (60*5(getService() tries for 5 seconds)) before giving up ...
        const String16 name("sensorservice");
        for (int i = 0; i < 60; i++) {
            status_t err = getService(name, &mSensorServer); // 获取 sensorservice 服务
            if (err == NAME_NOT_FOUND) {
                sleep(1);
                continue;
            }
            if (err != NO_ERROR) {
                return err;
            }
            break;
        }

        ...

        mSensors = mSensorServer->getSensorList(mOpPackageName);// 获取传感器列表
        size_t count = mSensors.size();
        mSensorList =
                static_cast<Sensor const**>(malloc(count * sizeof(Sensor*))); // 分配空间

        for (size_t i=0 ; i<count ; i++) {
            mSensorList[i] = mSensors.array() + i;// 填充mSensorList
        }
    }       
    return NO_ERROR;
}
```

分析到最后，我们发现 assertStateLocked , 最后获取到了传感器的列表



#### 2.2.2.3 nativeGetSensorAtIndex 

```c
// android_hardware_SensorManager.cpp
// 此时传入的　sensorManager　是在　nativeCreate 中创建的　SensorManger ，并在java层保存的

static jboolean
nativeGetSensorAtIndex(JNIEnv *env, jclass clazz, jlong sensorManager, jobject sensor, jint index)                                 
{
    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
    Sensor const* const* sensorList;
    ssize_t count = mgr->getSensorList(&sensorList); // 从sensor service 端拿到　sensorlist    的信息

    // *sensorList[index]: 拿到对应　index 对应的信息
    return translateNativeSensorToJavaSensor(env, sensor, *sensorList[index]) != NULL;
}
```



```cpp
// SensorManager.cpp
ssize_t SensorManager::getSensorList(Sensor const* const** list) {
    status_t err = assertStateLocked();// 在前面有分析过，目的是　获取传感器列表
    if (err < 0) {
        return static_cast<ssize_t>(err);
    }
    *list = mSensorList;
    return static_cast<ssize_t>(mSensors.size());
}
```



```cpp
// android_hardware_SensorManager.cpp
static jobject
translateNativeSensorToJavaSensor(JNIEnv *env, jobject sensor, const Sensor& nativeSensor) {
    const SensorOffsets& sensorOffsets(gSensorOffsets);

    if (sensor == NULL) {
        // Sensor sensor = new Sensor();
        sensor = env->NewObject(sensorOffsets.clazz, sensorOffsets.init, "");
    }

    if (sensor != NULL) {
        jstring name = env->NewStringUTF(nativeSensor.getName().string());
        jstring vendor = env->NewStringUTF(nativeSensor.getVendor().string());
        jstring requiredPermission =
                env->NewStringUTF(nativeSensor.getRequiredPermission().string());

        env->SetObjectField(sensor, sensorOffsets.name,      name);
        env->SetObjectField(sensor, sensorOffsets.vendor,    vendor);
        env->SetIntField(sensor, sensorOffsets.version,      nativeSensor.getVersion());
        env->SetIntField(sensor, sensorOffsets.handle,       nativeSensor.getHandle());
        env->SetFloatField(sensor, sensorOffsets.range,      nativeSensor.getMaxValue());
        env->SetFloatField(sensor, sensorOffsets.resolution, nativeSensor.getResolution());
        env->SetFloatField(sensor, sensorOffsets.power,      nativeSensor.getPowerUsage());
        env->SetIntField(sensor, sensorOffsets.minDelay,     nativeSensor.getMinDelay());
        env->SetIntField(sensor, sensorOffsets.fifoReservedEventCount,
                         nativeSensor.getFifoReservedEventCount());
        env->SetIntField(sensor, sensorOffsets.fifoMaxEventCount,
                         nativeSensor.getFifoMaxEventCount());
        env->SetObjectField(sensor, sensorOffsets.requiredPermission,
                            requiredPermission);
        env->SetIntField(sensor, sensorOffsets.maxDelay, nativeSensor.getMaxDelay());
        env->SetIntField(sensor, sensorOffsets.flags, nativeSensor.getFlags());

        if (env->CallBooleanMethod(sensor, sensorOffsets.setType, nativeSensor.getType())
                == JNI_FALSE) {
            jstring stringType = getInternedString(env, &nativeSensor.getStringType());
            env->SetObjectField(sensor, sensorOffsets.stringType, stringType);
        }

        // TODO(b/29547335): Rename "setUuid" method to "setId".
        int64_t id = nativeSensor.getId();
        env->CallVoidMethod(sensor, sensorOffsets.setUuid, id, 0);                         
    }
    return sensor;
}
```

translateNativeSensorToJavaSensor() 函数主要功能就是填充　java层的　sensor　对象.



### 2.2.3 注册传感器监听

应用层调用

```java
mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler);
```

registerListener() 最终会被调用到如下的　registerListenerImpl() 代码中

对应的代码在:

```java
protected boolean registerListenerImpl(SensorEventListener listener, Sensor sensor,              
            int delayUs, Handler handler, int maxBatchReportLatencyUs, int reservedFlags) {
        synchronized (mSensorListeners) {
            SensorEventQueue queue = mSensorListeners.get(listener);// 从mSensorListeners　找到之前　add过得，　第一次这里返回 null
            if (queue == null) {
                // 这里决定用　自己的looper  还是　主线程的looper
                Looper looper = (handler != null) ? handler.getLooper() : mMainLooper;
                
                final String fullClassName = listener.getClass().getEnclosingClass() != null ?
                    listener.getClass().getEnclosingClass().getName() :
                    listener.getClass().getName();
                
                // new SensorEventQueue
                queue = new SensorEventQueue(listener, looper, this, fullClassName);
                if (!queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs)) {
                    queue.dispose();
                    return false;
                }
                mSensorListeners.put(listener, queue);　// 将　SensorEventQueue　添加到　mSensorListeners
                return true;
            } else {
                ...
            }   
        }   
    }
```

