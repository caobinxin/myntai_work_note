# main.mk

```makefile
#指定我们使用 /bin/bash 进行后续的解析
ifdef ANDROID_BUILD_SHELL
SHELL := $(ANDROID_BUILD_SHELL)
else
SHELL := /bin/bash
endif

# 这将关闭make中内置的后缀规则
.SUFFIXES:

# 这将关闭gnu make的rcs/sccs隐式规则
% : RCS/%,v
% : RCS/%
% : %,v
% : s.%
% : SCCS/s.%

#如果规则失败，删除 $@
.DELETE_ON_ERROR:

# 弄清楚我们在哪。
#TOP := $(dir $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))　# 具体看2.1 剖析
#TOP := $(patsubst %/,%,$(TOP))　# 具体看　4.1 实例

# TOPDIR　是您应该使用的常规变量，因为如果我们是相对于当前目录执行的，那么它可以是“”，而TOP必须是“.”，这会在从不同位置的路径中删除尾随的“./”时导致模式匹配问题。
#ifeq ($(TOP),.)
#TOPDIR :=
#else
#TOPDIR := $(TOP)/
#endif

# 检查make的损坏版本
ifneq (1,$(strip $(shell expr $(MAKE_VERSION) \>= 3.81)))
$(warning ********************************************************************************)
$(warning *  You are using version $(MAKE_VERSION) of make.)
$(warning *  Android can only be built by versions 3.81 and higher.)
$(warning *  see https://source.android.com/source/download.html)
$(warning ********************************************************************************)
$(error stopping)
endif

# 当前工作目录的绝对路径。
# 这将重写shell变量 $pwd，它不一定指向源树的顶部，例如在m/mm/mmm中使用“make-c”时。
PWD := $(shell pwd)

TOP := .
TOPDIR :=

BUILD_SYSTEM := $(TOPDIR)build/core

# 确保未在外部设置 JAVA_NOT_REQUIRED
JAVA_NOT_REQUIRED := false

# 这是默认目标。它必须是第一个声明的目标。
.PHONY: droid
DEFAULT_GOAL := droid
$(DEFAULT_GOAL): droid_targets

.PHONY: droid_targets
droid_targets:

# 用来强迫目标建立。仅用于有条件定义的目标。
.PHONY: FORCE
FORCE:

# 这些目标不需要收集并包含android.mks/cleanspec.mks 在代码tree中
dont_bother_goals := clean clobber dataclean installclean \
    help out \
    snod systemimage-nodeps \
    stnod systemtarball-nodeps \
    userdataimage-nodeps userdatatarball-nodeps \
    cacheimage-nodeps \
    vendorimage-nodeps \
    systemotherimage-nodeps \
    ramdisk-nodeps \
    bootimage-nodeps \
    recoveryimage-nodeps \
    product-graph dump-products

# 看实例 8.1
ifneq ($(filter $(dont_bother_goals), $(MAKECMDGOALS)),)
dont_bother := true
endif

ORIGINAL_MAKECMDGOALS := $(MAKECMDGOALS)

# 在生成系统上提供快速帮助的目标。
include $(BUILD_SYSTEM)/help.mk

# 根据配置和主机信息设置各种标准变量。
include $(BUILD_SYSTEM)/config.mk

relaunch_with_ninja :=
ifneq ($(USE_NINJA),false)
ifndef BUILDING_WITH_NINJA
relaunch_with_ninja := true
endif
endif

ifeq ($(relaunch_with_ninja),true)
# 标注这是一个 ninja build.
$(shell mkdir -p $(OUT_DIR) && touch $(OUT_DIR)/ninja_build)
include build/core/ninja.mk
else # !relaunch_with_ninja
ifndef BUILDING_WITH_NINJA
# 如果ninja build标记存在则移除
$(shell rm -f $(OUT_DIR)/ninja_build)
endif

#　将内部版本号写入文件，以便在每次不更改命令行的情况下将其读回。使用ninja时避免重建。
$(shell mkdir -p $(OUT_DIR) && \
    echo -n $(BUILD_NUMBER) > $(OUT_DIR)/build_number.txt && \
    echo -n $(BUILD_DATETIME) > $(OUT_DIR)/build_date.txt)
BUILD_NUMBER_FROM_FILE := $$(cat $(OUT_DIR)/build_number.txt)
BUILD_DATETIME_FROM_FILE := $$(cat $(OUT_DIR)/build_date.txt)

# 见shell 2.1 实例描述
ifeq ($(HOST_OS),darwin)
DATE_FROM_FILE := date -r $(BUILD_DATETIME_FROM_FILE)
else
DATE_FROM_FILE := date -d @$(BUILD_DATETIME_FROM_FILE)
endif

# 不包含　cts 的mk
-include cts/build/config.mk
# 不包含　vts 的mk
-include test/vts/tools/vts-tradefed/build/config.mk

# 这允许我们在config.mk环境设置完成之后，但在生成任何依赖项之前强制一个干净的构建。这个文件内联rm-rf，因此下面所有的dep都将正确生成
include $(BUILD_SYSTEM)/cleanbuild.mk

-include vendor/google/build/config.mk

VERSION_CHECK_SEQUENCE_NUMBER := 6
-include $(OUT_DIR)/versions_checked.mk
ifneq ($(VERSION_CHECK_SEQUENCE_NUMBER),$(VERSIONS_CHECKED))

$(info Checking build tools versions...)

# 检查区分大小写的文件系统
ifneq (a,$(shell mkdir -p $(OUT_DIR) ; \
                echo a > $(OUT_DIR)/casecheck.txt; \
                    echo B > $(OUT_DIR)/CaseCheck.txt; \
                cat $(OUT_DIR)/casecheck.txt))
$(warning ************************************************************)
$(warning You are building on a case-insensitive filesystem.)
$(warning Please move your source tree to a case-sensitive filesystem.)
$(warning ************************************************************)
$(error Case-insensitive filesystems not supported)
endif

# 确保绝对路径中没有空格；生成系统无法处理它们。
ifneq ($(words $(shell pwd)),1)
$(warning ************************************************************)
$(warning You are building in a directory whose absolute path contains)
$(warning a space character:)
$(warning $(space))
$(warning "$(shell pwd)")
$(warning $(space))
$(warning Please move your source tree to a path that does not contain)
$(warning any spaces.)
$(warning ************************************************************)
$(error Directory names containing spaces not supported)
endif

ifeq ($(JAVA_NOT_REQUIRED), false)
java_version_str := $(shell unset _JAVA_OPTIONS && java -version 2>&1)
javac_version_str := $(shell unset _JAVA_OPTIONS && javac -version 2>&1)

# 检查Java的正确版本，默认情况下应该是1.8，如果设置了LEGACY_USE_JAVA7，则只有1.7。
ifeq ($(LEGACY_USE_JAVA7),) # if LEGACY_USE_JAVA7 == ''
required_version := "1.8.x"
required_javac_version := "1.8"
java_version := $(shell echo '$(java_version_str)' | grep '[ "]1\.8[\. "$$]')
javac_version := $(shell echo '$(javac_version_str)' | grep '[ "]1\.8[\. "$$]')
else
required_version := "1.7.x"
required_javac_version := "1.7"
java_version := $(shell echo '$(java_version_str)' | grep '^java .*[ "]1\.7[\. "$$]')
javac_version := $(shell echo '$(javac_version_str)' | grep '[ "]1\.7[\. "$$]')
endif # if LEGACY_USE_JAVA7 == ''

ifeq ($(strip $(java_version)),)
$(info ************************************************************)
$(info You are attempting to build with the incorrect version)
$(info of java.)
$(info $(space))
$(info Your version is: $(java_version_str).)
$(info The required version is: $(required_version))
$(info $(space))
$(info Please follow the machine setup instructions at)
$(info $(space)$(space)$(space)$(space)https://source.android.com/source/initializing.html)
$(info ************************************************************)
$(error stop)
endif

# 检查当前的 JDK.
#
# 对于Java 1.7／1.8，我们需要Linux上的OpenJDK和Mac OS上的Oracle JDK。
requires_openjdk := false
ifeq ($(BUILD_OS),linux)
requires_openjdk := true
endif


# 检查当前的 jdk
ifeq ($(requires_openjdk), true)
# 用户请求OpenJDK，所以检查主机Java版本是否是OpenJDK，而不是其他JDK。
ifeq ($(shell echo '$(java_version_str)' | grep -i openjdk),)
$(info ************************************************************)
$(info You asked for an OpenJDK based build but your version is)
$(info $(java_version_str).)
$(info ************************************************************)
$(error stop)
endif # java version is not OpenJdk
else # if requires_openjdk
ifneq ($(shell echo '$(java_version_str)' | grep -i openjdk),)
$(info ************************************************************)
$(info You are attempting to build with an unsupported JDK.)
$(info $(space))
$(info You use OpenJDK but only Sun/Oracle JDK is supported.)
$(info Please follow the machine setup instructions at)
$(info $(space)$(space)$(space)$(space)https://source.android.com/source/download.html)
$(info ************************************************************)
$(error stop)
endif # java version is not Sun Oracle JDK
endif # if requires_openjdk

KNOWN_INCOMPATIBLE_JAVAC_VERSIONS := google
incompat_javac := $(foreach v,$(KNOWN_INCOMPATIBLE_JAVAC_VERSIONS),$(findstring $(v),$(javac_version_str)))
ifneq ($(incompat_javac),)
javac_version :=
endif

# 检查　javac　的版本
ifeq ($(strip $(javac_version)),)
$(info ************************************************************)
$(info You are attempting to build with the incorrect version)
$(info of javac.)
$(info $(space))
$(info Your version is: $(javac_version_str).)
ifneq ($(incompat_javac),)
$(info This '$(incompat_javac)' version is not supported for Android platform builds.)
$(info Use a publicly available JDK and make sure you have run envsetup.sh / lunch.)
else
$(info The required version is: $(required_javac_version))
endif
$(info $(space))
$(info Please follow the machine setup instructions at)
$(info $(space)$(space)$(space)$(space)https://source.android.com/source/download.html)
$(info ************************************************************)
$(error stop)
endif

endif # if JAVA_NOT_REQUIRED

ifndef BUILD_EMULATOR
  # 仿真器二进制文件现在在下面提供 prebuilts/android-emulator/
  BUILD_EMULATOR := false
endif

$(shell echo 'VERSIONS_CHECKED := $(VERSION_CHECK_SEQUENCE_NUMBER)' \
        > $(OUT_DIR)/versions_checked.mk)
$(shell echo 'BUILD_EMULATOR ?= $(BUILD_EMULATOR)' \
        >> $(OUT_DIR)/versions_checked.mk)
endif

# 这些修改器目标本身不做任何事情，但会更改生成的行为。（必须在包含定义之前定义.make）
INTERNAL_MODIFIER_TARGETS := showcommands all

# EMMA_INSTRUMENT_STATIC 将静态emma库合并到每个启用emma的模块。
ifeq (true,$(EMMA_INSTRUMENT_STATIC))
EMMA_INSTRUMENT := true
endif

# 引入标准生成系统定义。
include $(BUILD_SYSTEM)/definitions.mk

# 引入 dex_preopt.mk
include $(BUILD_SYSTEM)/dex_preopt.mk

ifneq ($(filter user userdebug eng,$(MAKECMDGOALS)),)
$(info ***************************************************************)
$(info ***************************************************************)
$(info Do not pass '$(filter user userdebug eng,$(MAKECMDGOALS))' on \
       the make command line.)
$(info Set TARGET_BUILD_VARIANT in buildspec.mk, or use lunch or)
$(info choosecombo.)
$(info ***************************************************************)
$(info ***************************************************************)
$(error stopping)
endif

# 分析见　makefile 11.1
ifneq ($(filter-out $(INTERNAL_VALID_VARIANTS),$(TARGET_BUILD_VARIANT)),)
$(info ***************************************************************)
$(info ***************************************************************)
$(info Invalid variant: $(TARGET_BUILD_VARIANT))
$(info Valid values are: $(INTERNAL_VALID_VARIANTS))
$(info ***************************************************************)
$(info ***************************************************************)
$(error stopping)
endif

# -----------------------------------------------------------------
# 变量检查PDK构建中的Java支持级别。如果部件不在PDK中，则不需要。未定义：不支持“sdk”：只支持sdk api“平台”：支持平台api
TARGET_BUILD_JAVA_SUPPORT_LEVEL := platform

# -----------------------------------------------------------------
# pdk（平台开发工具包）构建
include build/core/pdk_config.mk

#
# -----------------------------------------------------------------
# jack 版本配置
-include $(TOPDIR)prebuilts/sdk/tools/jack_versions.mk
-include $(TOPDIR)prebuilts/sdk/tools/jack_for_module.mk

#
# -----------------------------------------------------------------
# 安装开始 Jack server
-include $(TOPDIR)prebuilts/sdk/tools/jack_server_setup.mk

#
# -----------------------------------------------------------------
# jacoco软件包名称 Jack
-include $(TOPDIR)external/jacoco/config.mk

#
# -----------------------------------------------------------------
# 对所有生成（最终版本除外）启用动态链接器开发人员警告。
ifneq ($(PLATFORM_VERSION_CODENAME),REL)
  ADDITIONAL_BUILD_PROPERTIES += ro.bionic.ld.warning=1
endif

# -----------------------------------------------------------------
###
### 在这一节中，我们设置了构建变体之间的不同之处
###

is_sdk_build :=

ifneq ($(filter sdk win_sdk sdk_addon,$(MAKECMDGOALS)),)
is_sdk_build := true
endif

# 为艺术添加生成属性。这些定义installd用来将标志传递给dex2oat的系统属性。 
ADDITIONAL_BUILD_PROPERTIES += persist.sys.dalvik.vm.lib.2=libart.so
ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.isa.$(TARGET_ARCH).variant=$(DEX2OAT_TARGET_CPU_VARIANT)
ifneq ($(DEX2OAT_TARGET_INSTRUCTION_SET_FEATURES),)
  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.isa.$(TARGET_ARCH).features=$(DEX2OAT_TARGET_INSTRUCTION_SET_FEATURES)
endif

ifdef TARGET_2ND_ARCH
  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.isa.$(TARGET_2ND_ARCH).variant=$($(TARGET_2ND_ARCH_VAR_PREFIX)DEX2OAT_TARGET_CPU_VARIANT)
  ifneq ($($(TARGET_2ND_ARCH_VAR_PREFIX)DEX2OAT_TARGET_INSTRUCTION_SET_FEATURES),)
    ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.isa.$(TARGET_2ND_ARCH).features=$($(TARGET_2ND_ARCH_VAR_PREFIX)DEX2OAT_TARGET_INSTRUCTION_SET_FEATURES)
  endif
endif

## user/userdebug ##

user_variant := $(filter user userdebug,$(TARGET_BUILD_VARIANT))
enable_target_debugging := true
tags_to_install :=
ifneq (,$(user_variant))
  # 目标在用户生成中是安全的。
  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=1
  ADDITIONAL_DEFAULT_PROPERTIES += security.perf_harden=1

  ifeq ($(user_variant),user)
    ADDITIONAL_DEFAULT_PROPERTIES += ro.adb.secure=1
  endif

  ifeq ($(user_variant),userdebug)
    # 拿起一些特别有用的工具
    tags_to_install += debug
  else
    # 在纯用户生成中禁用调试。
    enable_target_debugging :=
  endif

  # 默认情况下不允许用户生成的模拟位置
  ADDITIONAL_DEFAULT_PROPERTIES += ro.allow.mock.location=0

else # !user_variant
  # 对非用户生成启用checkjni。
  ADDITIONAL_BUILD_PROPERTIES += ro.kernel.android.checkjni=1
  # 为非用户生成设置设备不安全。
  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=0
  # 默认情况下允许非用户生成的模拟位置
  ADDITIONAL_DEFAULT_PROPERTIES += ro.allow.mock.location=1
endif # !user_variant

ifeq (true,$(strip $(enable_target_debugging)))
  # 目标更易于调试，默认情况下ADBD处于打开状态
  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1
  # 启用dalvik锁争用日志记录。
  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.lockprof.threshold=500
  # 在此版本中包括调试/测试OTA密钥。
  INCLUDE_TEST_OTA_KEYS := true
else # !enable_target_debugging
  # 目标的可调试性较低，默认情况下ADBD处于关闭状态
  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0
endif # !enable_target_debugging

## eng ##

ifeq ($(TARGET_BUILD_VARIANT),eng)
tags_to_install := debug eng

# 实例12.1 
ifneq ($(filter ro.setupwizard.mode=ENABLED, $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))),)
  # 不需要在生成引擎时使用安装向导
  ADDITIONAL_BUILD_PROPERTIES := $(filter-out ro.setupwizard.mode=%,\
          $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))) \
          ro.setupwizard.mode=OPTIONAL
endif
ifndef is_sdk_build
  # 若要加速非预处理生成的启动，请不要验证或编译启动映像。
  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.image-dex2oat-filter=verify-at-runtime
endif
endif

## sdk ##

ifdef is_sdk_build

# 检测是否要为sdk构建存储库
sdk_repo_goal := $(strip $(filter sdk_repo,$(MAKECMDGOALS)))
MAKECMDGOALS := $(strip $(filter-out sdk_repo,$(MAKECMDGOALS)))

ifneq ($(words $(sort $(filter-out $(INTERNAL_MODIFIER_TARGETS) checkbuild emulator_tests target-files-package,$(MAKECMDGOALS)))),1)
$(error The 'sdk' target may not be specified with any other targets)
endif

# TODO: 我想这应该是eng。因为sdk是从eng变体构建的。
tags_to_install := debug eng
ADDITIONAL_BUILD_PROPERTIES += xmpp.auto-presence=true
ADDITIONAL_BUILD_PROPERTIES += ro.config.nocheckin=yes
else # !sdk
endif

BUILD_WITHOUT_PV := true

ADDITIONAL_BUILD_PROPERTIES += net.bt.name=Android

# 现在在文件中启用vm跟踪有助于跟踪内容进程中anr的原因
ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.stack-trace-file=/data/anr/traces.txt

# ------------------------------------------------------------
# 定义一个函数，在给定模块标记列表的情况下，如果该模块应安装在/system中，则该函数返回非空。

# 对于大多数目标，任何没有标记“tests”标记的内容都应该安装在/system中。
define should-install-to-system
$(if $(filter tests,$(1)),,true)
endef

ifdef is_sdk_build
# 对于sdk的目标，任何带有“samples”标签的东西都应该安装在/data中，即使该模块也有“eng/”debug/“user”。
define should-install-to-system
$(if $(filter samples tests,$(1)),,true)
endef
endif


# 如果他们只使用修改目标（表演命令等），我们将实际建立缺陷目标。
ifeq ($(filter-out $(INTERNAL_MODIFIER_TARGETS),$(MAKECMDGOALS)),)
.PHONY: $(INTERNAL_MODIFIER_TARGETS)
$(INTERNAL_MODIFIER_TARGETS): $(DEFAULT_GOAL)
endif

#
# 典型构建；包括我们可以找到的任何android.mk文件。
#
subdirs := $(TOP)

FULL_BUILD := true

# 在我们去包含所有的模块makefile之前，先把产品的值藏起来，以便以后我们可以验证它们没有被修改。
stash_product_vars:=true
ifeq ($(stash_product_vars),true)
  $(call stash-product-vars, __STASHED)
endif

ifneq ($(ONE_SHOT_MAKEFILE),)
# 我们可能已经被“mm”shell函数用一个子目录的makefile调用了。
include $(ONE_SHOT_MAKEFILE)
# 将CUSTOM_MODULES更改为仅包含此makefile定义的模块；这将作为副作用安装所有这些模块。在包含一个生成文件后执行此操作，以便模块将安装在正常生成时的相同位置。
CUSTOM_MODULES := $(sort $(call get-tagged-modules,$(ALL_MODULE_TAGS)))
FULL_BUILD :=
# 将通知目标存根，使用 ONE_SHOT_MAKEFILE 时可能未定义这些目标。
NOTICE-HOST-%: ;
NOTICE-TARGET-%: ;

# 打印出安装路径的助手目标
.PHONY: GET-INSTALL-PATH
GET-INSTALL-PATH:
	@echo "Install paths for modules in $(ONE_SHOT_MAKEFILE):"
	@$(foreach m, $(ALL_MODULES), $(if $(ALL_MODULES.$(m).INSTALLED), \
		echo 'INSTALL-PATH: $(m) $(ALL_MODULES.$(m).INSTALLED)';))

else # ONE_SHOT_MAKEFILE

ifneq ($(dont_bother),true)
#
# 包括系统中的所有生成文件
#

# 不能在下面使用第一个makefile，因为--mindepth=2使prune不起作用。 
subdir_makefiles := \
	$(shell build/tools/findleaves.py $(FIND_LEAVES_EXCLUDES) $(subdirs) Android.mk)

ifeq ($(USE_SOONG),true)
subdir_makefiles := $(SOONG_ANDROID_MK) $(call filter-soong-makefiles,$(subdir_makefiles))
endif

$(foreach mk, $(subdir_makefiles),$(info including $(mk) ...)$(eval include $(mk)))

ifdef PDK_FUSION_PLATFORM_ZIP
# 引入pdk platform.zip模块。
include $(BUILD_SYSTEM)/pdk_fusion_modules.mk
endif # PDK_FUSION_PLATFORM_ZIP

endif # dont_bother

endif # ONE_SHOT_MAKEFILE

# 现在加载了所有android.mks，我们可以执行清理后步骤。
include $(BUILD_SYSTEM)/post_clean.mk

ifeq ($(stash_product_vars),true)
  $(call assert-product-vars, __STASHED)
endif

include $(BUILD_SYSTEM)/legacy_prebuilts.mk
ifneq ($(filter-out $(GRANDFATHERED_ALL_PREBUILT),$(strip $(notdir $(ALL_PREBUILT)))),)
  $(warning *** Some files have been added to ALL_PREBUILT.)
  $(warning *)
  $(warning * ALL_PREBUILT is a deprecated mechanism that)
  $(warning * should not be used for new files.)
  $(warning * As an alternative, use PRODUCT_COPY_FILES in)
  $(warning * the appropriate product definition.)
  $(warning * build/target/product/core.mk is the product)
  $(warning * definition used in all products.)
  $(warning *)
  $(foreach bad_prebuilt,$(filter-out $(GRANDFATHERED_ALL_PREBUILT),$(strip $(notdir $(ALL_PREBUILT)))),$(warning * unexpected $(bad_prebuilt) in ALL_PREBUILT))
  $(warning *)
  $(error ALL_PREBUILT contains unexpected files)
endif

# -------------------------------------------------------------------
# 此时已包含所有模块生成文件。
# -------------------------------------------------------------------


# -------------------------------------------------------------------
# 修复 CUSTOM_MODULES 以引用已安装的文件，而不是仅引用裸模块名称。如果未知模块实际上是特定文件的完整路径，请不要使用它们。
known_custom_modules := $(filter $(ALL_MODULES),$(CUSTOM_MODULES))
unknown_custom_modules := $(filter-out $(ALL_MODULES),$(CUSTOM_MODULES))
CUSTOM_MODULES := \
	$(call module-installed-files,$(known_custom_modules)) \
	$(unknown_custom_modules)

# -------------------------------------------------------------------
# 为需要其他模块的模块定义依赖关系。只有在我们读入所有模块makefile之后，这种情况才会发生。
#
# TODO: 处理裸模块名不够明确的事实。可能声明短目标，如APPS:Quake or HOST:SHARED_LIBRARIES:libutils。
# BUG: 系统映像将不知道是否依赖于作为其他模块需求引入的模块。
# 
# 将所需的模块名解析为32位或64位变量。获取相应的32位模块名列表（如果存在）。
define get-32-bit-modules
$(strip $(foreach m,$(1),\
  $(if $(ALL_MODULES.$(m)$(TARGET_2ND_ARCH_MODULE_SUFFIX).CLASS),\
    $(m)$(TARGET_2ND_ARCH_MODULE_SUFFIX))))
endef
# 获取相应的32位模块名列表（如果存在）；否则返回原始模块名
define get-32-bit-modules-if-we-can
$(strip $(foreach m,$(1),\
  $(if $(ALL_MODULES.$(m)$(TARGET_2ND_ARCH_MODULE_SUFFIX).CLASS),\
    $(m)$(TARGET_2ND_ARCH_MODULE_SUFFIX),
    $(m))))
endef

# If a module is for a cross host os, the required modules must be for
# that OS too.
# If a module is built for 32-bit, the required modules must be 32-bit too;
# Otherwise if the module is an exectuable or shared library,
#   the required modules must be 64-bit;
#   otherwise we require both 64-bit and 32-bit variant, if one exists.
$(foreach m,$(ALL_MODULES),\
  $(eval r := $(ALL_MODULES.$(m).REQUIRED))\
  $(if $(r),\
    $(if $(ALL_MODULES.$(m).FOR_HOST_CROSS),\
      $(eval r := $(addprefix host_cross_,$(r))))\
    $(if $(ALL_MODULES.$(m).FOR_2ND_ARCH),\
      $(eval r_r := $(call get-32-bit-modules-if-we-can,$(r))),\
      $(if $(filter EXECUTABLES SHARED_LIBRARIES,$(ALL_MODULES.$(m).CLASS)),\
        $(eval r_r := $(r)),\
        $(eval r_r := $(r) $(call get-32-bit-modules,$(r)))\
       )\
     )\
     $(eval ALL_MODULES.$(m).REQUIRED := $(strip $(r_r)))\
  )\
)
r_r :=

define add-required-deps
$(1): | $(2)
endef

$(foreach m,$(ALL_MODULES), \
  $(eval r := $(ALL_MODULES.$(m).REQUIRED)) \
  $(if $(r), \
    $(eval r := $(call module-installed-files,$(r))) \
    $(eval t_m := $(filter $(TARGET_OUT_ROOT)/%, $(ALL_MODULES.$(m).INSTALLED))) \
    $(eval h_m := $(filter $(HOST_OUT_ROOT)/%, $(ALL_MODULES.$(m).INSTALLED))) \
    $(eval hc_m := $(filter $(HOST_CROSS_OUT_ROOT)/%, $(ALL_MODULES.$(m).INSTALLED))) \
    $(eval t_r := $(filter $(TARGET_OUT_ROOT)/%, $(r))) \
    $(eval h_r := $(filter $(HOST_OUT_ROOT)/%, $(r))) \
    $(eval hc_r := $(filter $(HOST_CROSS_OUT_ROOT)/%, $(r))) \
    $(eval t_m := $(filter-out $(t_r), $(t_m))) \
    $(eval h_m := $(filter-out $(h_r), $(h_m))) \
    $(eval hc_m := $(filter-out $(hc_r), $(hc_m))) \
    $(if $(t_m), $(eval $(call add-required-deps, $(t_m),$(t_r)))) \
    $(if $(h_m), $(eval $(call add-required-deps, $(h_m),$(h_r)))) \
    $(if $(hc_m), $(eval $(call add-required-deps, $(hc_m),$(hc_r)))) \
   ) \
 )

t_m :=
h_m :=
hc_m :=
t_r :=
h_r :=
hc_r :=

# Establish the dependecies on the shared libraries.
# It also adds the shared library module names to ALL_MODULES.$(m).REQUIRED,
# so they can be expanded to product_MODULES later.
# $(1): TARGET_ or HOST_ or HOST_CROSS_.
# $(2): non-empty for 2nd arch.
# $(3): non-empty for host cross compile.
define resolve-shared-libs-depes
$(foreach m,$($(if $(2),$($(1)2ND_ARCH_VAR_PREFIX))$(1)DEPENDENCIES_ON_SHARED_LIBRARIES),\
  $(eval p := $(subst :,$(space),$(m)))\
  $(eval mod := $(firstword $(p)))\
  $(eval deps := $(subst $(comma),$(space),$(lastword $(p))))\
  $(if $(2),$(eval deps := $(addsuffix $($(1)2ND_ARCH_MODULE_SUFFIX),$(deps))))\
  $(if $(3),$(eval deps := $(addprefix host_cross_,$(deps))))\
  $(eval r := $(filter $($(1)OUT)/%,$(call module-installed-files,\
    $(deps))))\
  $(eval $(call add-required-deps,$(word 2,$(p)),$(r)))\
  $(eval ALL_MODULES.$(mod).REQUIRED += $(deps)))
endef

$(call resolve-shared-libs-depes,TARGET_)
ifdef TARGET_2ND_ARCH
$(call resolve-shared-libs-depes,TARGET_,true)
endif
$(call resolve-shared-libs-depes,HOST_)
ifdef HOST_2ND_ARCH
$(call resolve-shared-libs-depes,HOST_,true)
endif
ifdef HOST_CROSS_OS
$(call resolve-shared-libs-depes,HOST_CROSS_,,true)
endif

m :=
r :=
p :=
deps :=
add-required-deps :=

# -------------------------------------------------------------------
# Figure out our module sets.
#
# Of the modules defined by the component makefiles,
# determine what we actually want to build.

###########################################################
## Expand a module name list with REQUIRED modules
###########################################################
# $(1): The variable name that holds the initial module name list.
#       the variable will be modified to hold the expanded results.
# $(2): The initial module name list.
# Returns empty string (maybe with some whitespaces).
define expand-required-modules
$(eval _erm_new_modules := $(sort $(filter-out $($(1)),\
  $(foreach m,$(2),$(ALL_MODULES.$(m).REQUIRED)))))\
$(if $(_erm_new_modules),$(eval $(1) += $(_erm_new_modules))\
  $(call expand-required-modules,$(1),$(_erm_new_modules)))
endef

ifdef FULL_BUILD
  # The base list of modules to build for this product is specified
  # by the appropriate product definition file, which was included
  # by product_config.mk.
  product_MODULES := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES)
  # Filter out the overridden packages before doing expansion
  product_MODULES := $(filter-out $(foreach p, $(product_MODULES), \
      $(PACKAGES.$(p).OVERRIDES)), $(product_MODULES))

  # Resolve the :32 :64 module name
  modules_32 := $(patsubst %:32,%,$(filter %:32, $(product_MODULES)))
  modules_64 := $(patsubst %:64,%,$(filter %:64, $(product_MODULES)))
  modules_rest := $(filter-out %:32 %:64,$(product_MODULES))
  # Note for 32-bit product, $(modules_32) and $(modules_64) will be
  # added as their original module names.
  product_MODULES := $(call get-32-bit-modules-if-we-can, $(modules_32))
  product_MODULES += $(modules_64)
  # For the rest we add both
  product_MODULES += $(call get-32-bit-modules, $(modules_rest))
  product_MODULES += $(modules_rest)

  $(call expand-required-modules,product_MODULES,$(product_MODULES))

  product_FILES := $(call module-installed-files, $(product_MODULES))
  ifeq (0,1)
    $(info product_FILES for $(TARGET_DEVICE) ($(INTERNAL_PRODUCT)):)
    $(foreach p,$(product_FILES),$(info :   $(p)))
    $(error done)
  endif
else
  # We're not doing a full build, and are probably only including
  # a subset of the module makefiles.  Don't try to build any modules
  # requested by the product, because we probably won't have rules
  # to build them.
  product_FILES :=
endif

eng_MODULES := $(sort \
        $(call get-tagged-modules,eng) \
        $(call module-installed-files, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_ENG)) \
    )
debug_MODULES := $(sort \
        $(call get-tagged-modules,debug) \
        $(call module-installed-files, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_DEBUG)) \
    )
tests_MODULES := $(sort \
        $(call get-tagged-modules,tests) \
        $(call module-installed-files, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_TESTS)) \
    )

# TODO: Remove the 3 places in the tree that use ALL_DEFAULT_INSTALLED_MODULES
# and get rid of it from this list.
modules_to_install := $(sort \
    $(ALL_DEFAULT_INSTALLED_MODULES) \
    $(product_FILES) \
    $(foreach tag,$(tags_to_install),$($(tag)_MODULES)) \
    $(CUSTOM_MODULES) \
  )

# Some packages may override others using LOCAL_OVERRIDES_PACKAGES.
# Filter out (do not install) any overridden packages.
overridden_packages := $(call get-package-overrides,$(modules_to_install))
ifdef overridden_packages
#  old_modules_to_install := $(modules_to_install)
  modules_to_install := \
      $(filter-out $(foreach p,$(overridden_packages),$(p) %/$(p).apk %/$(p).odex), \
          $(modules_to_install))
endif
#$(error filtered out
#           $(filter-out $(modules_to_install),$(old_modules_to_install)))

# Don't include any GNU General Public License shared objects or static
# libraries in SDK images.  GPL executables (not static/dynamic libraries)
# are okay if they don't link against any closed source libraries (directly
# or indirectly)

# It's ok (and necessary) to build the host tools, but nothing that's
# going to be installed on the target (including static libraries).

ifdef is_sdk_build
  target_gnu_MODULES := \
              $(filter \
                      $(TARGET_OUT_INTERMEDIATES)/% \
                      $(TARGET_OUT)/% \
                      $(TARGET_OUT_DATA)/%, \
                              $(sort $(call get-tagged-modules,gnu)))
  target_gnu_MODULES := $(filter-out $(TARGET_OUT_EXECUTABLES)/%,$(target_gnu_MODULES))
  $(info Removing from sdk:)$(foreach d,$(target_gnu_MODULES),$(info : $(d)))
  modules_to_install := \
              $(filter-out $(target_gnu_MODULES),$(modules_to_install))

  # Ensure every module listed in PRODUCT_PACKAGES* gets something installed
  # TODO: Should we do this for all builds and not just the sdk?
  dangling_modules :=
  $(foreach m, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES), \
    $(if $(strip $(ALL_MODULES.$(m).INSTALLED) $(ALL_MODULES.$(m)$(TARGET_2ND_ARCH_MODULE_SUFFIX).INSTALLED)),,\
      $(eval dangling_modules += $(m))))
  ifneq ($(dangling_modules),)
    $(warning: Modules '$(dangling_modules)' in PRODUCT_PACKAGES have nothing to install!)
  endif
  $(foreach m, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_DEBUG), \
    $(if $(strip $(ALL_MODULES.$(m).INSTALLED)),,\
      $(warning $(ALL_MODULES.$(m).MAKEFILE): Module '$(m)' in PRODUCT_PACKAGES_DEBUG has nothing to install!)))
  $(foreach m, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_ENG), \
    $(if $(strip $(ALL_MODULES.$(m).INSTALLED)),,\
      $(warning $(ALL_MODULES.$(m).MAKEFILE): Module '$(m)' in PRODUCT_PACKAGES_ENG has nothing to install!)))
  $(foreach m, $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES_TESTS), \
    $(if $(strip $(ALL_MODULES.$(m).INSTALLED)),,\
      $(warning $(ALL_MODULES.$(m).MAKEFILE): Module '$(m)' in PRODUCT_PACKAGES_TESTS has nothing to install!)))
endif

# build/core/Makefile contains extra stuff that we don't want to pollute this
# top-level makefile with.  It expects that ALL_DEFAULT_INSTALLED_MODULES
# contains everything that's built during the current make, but it also further
# extends ALL_DEFAULT_INSTALLED_MODULES.
ALL_DEFAULT_INSTALLED_MODULES := $(modules_to_install)
include $(BUILD_SYSTEM)/Makefile
modules_to_install := $(sort $(ALL_DEFAULT_INSTALLED_MODULES))
ALL_DEFAULT_INSTALLED_MODULES :=


# These are additional goals that we build, in order to make sure that there
# is as little code as possible in the tree that doesn't build.
modules_to_check := $(foreach m,$(ALL_MODULES),$(ALL_MODULES.$(m).CHECKED))

# If you would like to build all goals, and not skip any intermediate
# steps, you can pass the "all" modifier goal on the commandline.
ifneq ($(filter all,$(MAKECMDGOALS)),)
modules_to_check += $(foreach m,$(ALL_MODULES),$(ALL_MODULES.$(m).BUILT))
endif

# for easier debugging
modules_to_check := $(sort $(modules_to_check))
#$(error modules_to_check $(modules_to_check))

# -------------------------------------------------------------------
# This is used to to get the ordering right, you can also use these,
# but they're considered undocumented, so don't complain if their
# behavior changes.
.PHONY: prebuilt
prebuilt: $(ALL_PREBUILT)

# An internal target that depends on all copied headers
# (see copy_headers.make).  Other targets that need the
# headers to be copied first can depend on this target.
.PHONY: all_copied_headers
all_copied_headers: ;

$(ALL_C_CPP_ETC_OBJECTS): | all_copied_headers

# All the droid stuff, in directories
.PHONY: files
files: prebuilt \
        $(modules_to_install) \
        $(INSTALLED_ANDROID_INFO_TXT_TARGET)

# -------------------------------------------------------------------

.PHONY: checkbuild
checkbuild: $(modules_to_check) droid_targets
ifeq ($(USE_SOONG),true)
checkbuild: checkbuild-soong
endif
ifeq (true,$(ANDROID_BUILD_EVERYTHING_BY_DEFAULT))
droid: checkbuild
endif

.PHONY: ramdisk
ramdisk: $(INSTALLED_RAMDISK_TARGET)

.PHONY: systemtarball
systemtarball: $(INSTALLED_SYSTEMTARBALL_TARGET)

.PHONY: boottarball
boottarball: $(INSTALLED_BOOTTARBALL_TARGET)

.PHONY: userdataimage
userdataimage: $(INSTALLED_USERDATAIMAGE_TARGET)

ifneq (,$(filter userdataimage, $(MAKECMDGOALS)))
$(call dist-for-goals, userdataimage, $(BUILT_USERDATAIMAGE_TARGET))
endif

.PHONY: userdatatarball
userdatatarball: $(INSTALLED_USERDATATARBALL_TARGET)

.PHONY: cacheimage
cacheimage: $(INSTALLED_CACHEIMAGE_TARGET)

.PHONY: vendorimage
vendorimage: $(INSTALLED_VENDORIMAGE_TARGET)

.PHONY: systemotherimage
systemotherimage: $(INSTALLED_SYSTEMOTHERIMAGE_TARGET)

.PHONY: bootimage
bootimage: $(INSTALLED_BOOTIMAGE_TARGET)

# phony target that include any targets in $(ALL_MODULES)
.PHONY: all_modules
ifndef BUILD_MODULES_IN_PATHS
all_modules: $(ALL_MODULES)
else
# BUILD_MODULES_IN_PATHS is a list of paths relative to the top of the tree
build_modules_in_paths := $(patsubst ./%,%,$(BUILD_MODULES_IN_PATHS))
module_path_patterns := $(foreach p, $(build_modules_in_paths),\
    $(if $(filter %/,$(p)),$(p)%,$(p)/%))
my_all_modules := $(sort $(foreach m, $(ALL_MODULES),$(if $(filter\
    $(module_path_patterns), $(addsuffix /,$(ALL_MODULES.$(m).PATH))),$(m))))
all_modules: $(my_all_modules)
endif


# Build files and then package it into the rom formats
.PHONY: droidcore
droidcore: files \
	systemimage \
	$(INSTALLED_BOOTIMAGE_TARGET) \
	$(INSTALLED_RECOVERYIMAGE_TARGET) \
	$(INSTALLED_USERDATAIMAGE_TARGET) \
	$(INSTALLED_CACHEIMAGE_TARGET) \
	$(INSTALLED_VENDORIMAGE_TARGET) \
	$(INSTALLED_SYSTEMOTHERIMAGE_TARGET) \
	$(INSTALLED_FILES_FILE) \
	$(INSTALLED_FILES_FILE_VENDOR) \
	$(INSTALLED_FILES_FILE_SYSTEMOTHER)

# dist_files only for putting your library into the dist directory with a full build.
.PHONY: dist_files

ifneq ($(TARGET_BUILD_APPS),)
  # If this build is just for apps, only build apps and not the full system by default.

  unbundled_build_modules :=
  ifneq ($(filter all,$(TARGET_BUILD_APPS)),)
    # If they used the magic goal "all" then build all apps in the source tree.
    unbundled_build_modules := $(foreach m,$(sort $(ALL_MODULES)),$(if $(filter APPS,$(ALL_MODULES.$(m).CLASS)),$(m)))
  else
    unbundled_build_modules := $(TARGET_BUILD_APPS)
  endif

  # Dist the installed files if they exist.
  apps_only_installed_files := $(foreach m,$(unbundled_build_modules),$(ALL_MODULES.$(m).INSTALLED))
  $(call dist-for-goals,apps_only, $(apps_only_installed_files))
  # For uninstallable modules such as static Java library, we have to dist the built file,
  # as <module_name>.<suffix>
  apps_only_dist_built_files := $(foreach m,$(unbundled_build_modules),$(if $(ALL_MODULES.$(m).INSTALLED),,\
      $(if $(ALL_MODULES.$(m).BUILT),$(ALL_MODULES.$(m).BUILT):$(m)$(suffix $(ALL_MODULES.$(m).BUILT)))\
      $(if $(ALL_MODULES.$(m).AAR),$(ALL_MODULES.$(m).AAR):$(m).aar)\
      ))
  $(call dist-for-goals,apps_only, $(apps_only_dist_built_files))

  ifeq ($(EMMA_INSTRUMENT),true)
    $(EMMA_META_ZIP) : $(apps_only_installed_files)

    $(call dist-for-goals,apps_only, $(EMMA_META_ZIP))
  endif

  $(PROGUARD_DICT_ZIP) : $(apps_only_installed_files)
  $(call dist-for-goals,apps_only, $(PROGUARD_DICT_ZIP))

  $(SYMBOLS_ZIP) : $(apps_only_installed_files)
  $(call dist-for-goals,apps_only, $(SYMBOLS_ZIP))

.PHONY: apps_only
apps_only: $(unbundled_build_modules)

droid_targets: apps_only

# Combine the NOTICE files for a apps_only build
$(eval $(call combine-notice-files, \
    $(target_notice_file_txt), \
    $(target_notice_file_html), \
    "Notices for files for apps:", \
    $(TARGET_OUT_NOTICE_FILES), \
    $(apps_only_installed_files)))


else # TARGET_BUILD_APPS
  $(call dist-for-goals, droidcore, \
    $(INTERNAL_UPDATE_PACKAGE_TARGET) \
    $(INTERNAL_OTA_PACKAGE_TARGET) \
    $(BUILT_OTATOOLS_PACKAGE) \
    $(SYMBOLS_ZIP) \
    $(INSTALLED_FILES_FILE) \
    $(INSTALLED_FILES_FILE_VENDOR) \
    $(INSTALLED_FILES_FILE_SYSTEMOTHER) \
    $(INSTALLED_BUILD_PROP_TARGET) \
    $(BUILT_TARGET_FILES_PACKAGE) \
    $(INSTALLED_ANDROID_INFO_TXT_TARGET) \
    $(INSTALLED_RAMDISK_TARGET) \
   )

  # Put a copy of the radio/bootloader files in the dist dir.
  $(foreach f,$(INSTALLED_RADIOIMAGE_TARGET), \
    $(call dist-for-goals, droidcore, $(f)))

  ifneq ($(ANDROID_BUILD_EMBEDDED),true)
  ifneq ($(TARGET_BUILD_PDK),true)
    $(call dist-for-goals, droidcore, \
      $(APPS_ZIP) \
      $(INTERNAL_EMULATOR_PACKAGE_TARGET) \
      $(PACKAGE_STATS_FILE) \
    )
  endif
  endif

  ifeq ($(EMMA_INSTRUMENT),true)
    $(EMMA_META_ZIP) : $(INSTALLED_SYSTEMIMAGE)

    $(call dist-for-goals, dist_files, $(EMMA_META_ZIP))
  endif

# Building a full system-- the default is to build droidcore
droid_targets: droidcore dist_files

endif # TARGET_BUILD_APPS

.PHONY: docs
docs: $(ALL_DOCS)

.PHONY: sdk
ALL_SDK_TARGETS := $(INTERNAL_SDK_TARGET)
sdk: $(ALL_SDK_TARGETS)
$(call dist-for-goals,sdk win_sdk, \
    $(ALL_SDK_TARGETS) \
    $(SYMBOLS_ZIP) \
    $(INSTALLED_BUILD_PROP_TARGET) \
)

# umbrella targets to assit engineers in verifying builds
.PHONY: java native target host java-host java-target native-host native-target \
        java-host-tests java-target-tests native-host-tests native-target-tests \
        java-tests native-tests host-tests target-tests tests
# some synonyms
.PHONY: host-java target-java host-native target-native \
        target-java-tests target-native-tests
host-java : java-host
target-java : java-target
host-native : native-host
target-native : native-target
target-java-tests : java-target-tests
target-native-tests : native-target-tests
tests : host-tests target-tests

# To catch more build breakage, check build tests modules in eng and userdebug builds.
ifneq ($(ANDROID_NO_TEST_CHECK),true)
ifneq ($(TARGET_BUILD_PDK),true)
ifneq ($(filter eng userdebug,$(TARGET_BUILD_VARIANT)),)
droidcore : target-tests host-tests
endif
endif
endif

ifneq (,$(filter samplecode, $(MAKECMDGOALS)))
.PHONY: samplecode
sample_MODULES := $(sort $(call get-tagged-modules,samples))
sample_APKS_DEST_PATH := $(TARGET_COMMON_OUT_ROOT)/samples
sample_APKS_COLLECTION := \
        $(foreach module,$(sample_MODULES),$(sample_APKS_DEST_PATH)/$(notdir $(module)))
$(foreach module,$(sample_MODULES),$(eval $(call \
        copy-one-file,$(module),$(sample_APKS_DEST_PATH)/$(notdir $(module)))))
sample_ADDITIONAL_INSTALLED := \
        $(filter-out $(modules_to_install) $(modules_to_check) $(ALL_PREBUILT),$(sample_MODULES))
samplecode: $(sample_APKS_COLLECTION)
	@echo "Collect sample code apks: $^"
	# remove apks that are not intended to be installed.
	rm -f $(sample_ADDITIONAL_INSTALLED)
endif  # samplecode in $(MAKECMDGOALS)

.PHONY: findbugs
findbugs: $(INTERNAL_FINDBUGS_HTML_TARGET) $(INTERNAL_FINDBUGS_XML_TARGET)

.PHONY: clean
clean:
	@rm -rf $(OUT_DIR)/*
	@echo "Entire build directory removed."

.PHONY: clobber
clobber: clean

# The rules for dataclean and installclean are defined in cleanbuild.mk.

#xxx scrape this from ALL_MODULE_NAME_TAGS
.PHONY: modules
modules:
	@echo "Available sub-modules:"
	@echo "$(call module-names-for-tag-list,$(ALL_MODULE_TAGS))" | \
	      tr -s ' ' '\n' | sort -u | $(COLUMN)

.PHONY: showcommands
showcommands:
	@echo >/dev/null

.PHONY: nothing
nothing:
	@echo Successfully read the makefiles.
endif # !relaunch_with_ninja
```

# soong.mk

```makefile
SOONG_OUT_DIR := $(OUT_DIR)/soong
SOONG_HOST_EXECUTABLES := $(SOONG_OUT_DIR)/host/$(HOST_PREBUILT_TAG)/bin
KATI := $(SOONG_HOST_EXECUTABLES)/ckati
MAKEPARALLEL := $(SOONG_HOST_EXECUTABLES)/makeparallel

SOONG := $(SOONG_OUT_DIR)/soong
SOONG_BOOTSTRAP := $(SOONG_OUT_DIR)/.soong.bootstrap
SOONG_BUILD_NINJA := $(SOONG_OUT_DIR)/build.ninja
SOONG_ANDROID_MK := $(SOONG_OUT_DIR)/Android.mk
SOONG_IN_MAKE := $(SOONG_OUT_DIR)/.soong.in_make
SOONG_VARIABLES := $(SOONG_OUT_DIR)/soong.variables

# We need to rebootstrap soong if SOONG_OUT_DIR or the reverse path from
# SOONG_OUT_DIR to TOP changes
SOONG_NEEDS_REBOOTSTRAP :=
ifneq ($(wildcard $(SOONG_BOOTSTRAP)),)
  ifneq ($(SOONG_OUT_DIR),$(strip $(shell source $(SOONG_BOOTSTRAP); echo $$BUILDDIR)))
    SOONG_NEEDS_REBOOTSTRAP := FORCE
    $(warning soong_out_dir changed)
  endif
  ifneq ($(strip $(shell build/soong/reverse_path.py $(SOONG_OUT_DIR))),$(strip $(shell source $(SOONG_BOOTSTRAP); echo $$SRCDIR_FROM_BUILDDIR)))
    SOONG_NEEDS_REBOOTSTRAP := FORCE
    $(warning reverse path changed)
  endif
endif

# Bootstrap soong.
$(SOONG_BOOTSTRAP): bootstrap.bash $(SOONG_NEEDS_REBOOTSTRAP)
	$(hide) mkdir -p $(dir $@)
	$(hide) BUILDDIR=$(SOONG_OUT_DIR) ./bootstrap.bash

# Create soong.variables with copies of makefile settings.  Runs every build,
# but only updates soong.variables if it changes
SOONG_VARIABLES_TMP := $(SOONG_VARIABLES).$$$$
$(SOONG_VARIABLES): FORCE
	$(hide) mkdir -p $(dir $@)
	$(hide) (\
	echo '{'; \
	echo '    "Device_uses_jemalloc": $(if $(filter true,$(MALLOC_SVELTE)),false,true),'; \
	echo '    "Device_uses_dlmalloc": $(if $(filter true,$(MALLOC_SVELTE)),true,false),'; \
	echo '    "Platform_sdk_version": $(PLATFORM_SDK_VERSION),'; \
	echo '    "Unbundled_build": $(if $(TARGET_BUILD_APPS),true,false),'; \
	echo '    "Brillo": $(if $(BRILLO),true,false),'; \
	echo ''; \
	echo '    "DeviceName": "$(TARGET_DEVICE)",'; \
	echo '    "DeviceArch": "$(TARGET_ARCH)",'; \
	echo '    "DeviceArchVariant": "$(TARGET_ARCH_VARIANT)",'; \
	echo '    "DeviceCpuVariant": "$(TARGET_CPU_VARIANT)",'; \
	echo '    "DeviceAbi": ["$(TARGET_CPU_ABI)", "$(TARGET_CPU_ABI2)"],'; \
	echo '    "DeviceUsesClang": $(if $(USE_CLANG_PLATFORM_BUILD),$(USE_CLANG_PLATFORM_BUILD),false),'; \
	echo ''; \
	echo '    "DeviceSecondaryArch": "$(TARGET_2ND_ARCH)",'; \
	echo '    "DeviceSecondaryArchVariant": "$(TARGET_2ND_ARCH_VARIANT)",'; \
	echo '    "DeviceSecondaryCpuVariant": "$(TARGET_2ND_CPU_VARIANT)",'; \
	echo '    "DeviceSecondaryAbi": ["$(TARGET_2ND_CPU_ABI)", "$(TARGET_2ND_CPU_ABI2)"],'; \
	echo ''; \
	echo '    "HostArch": "$(HOST_ARCH)",'; \
	echo '    "HostSecondaryArch": "$(HOST_2ND_ARCH)",'; \
	echo ''; \
	echo '    "CrossHost": "$(HOST_CROSS_OS)",'; \
	echo '    "CrossHostArch": "$(HOST_CROSS_ARCH)",'; \
	echo '    "CrossHostSecondaryArch": "$(HOST_CROSS_2ND_ARCH)"'; \
	echo '}') > $(SOONG_VARIABLES_TMP); \
	if ! cmp -s $(SOONG_VARIABLES_TMP) $(SOONG_VARIABLES); then \
	  mv $(SOONG_VARIABLES_TMP) $(SOONG_VARIABLES); \
	else \
	  rm $(SOONG_VARIABLES_TMP); \
	fi

# Tell soong that it is embedded in make
$(SOONG_IN_MAKE):
	$(hide) mkdir -p $(dir $@)
	$(hide) touch $@

# Build an Android.mk listing all soong outputs as prebuilts
$(SOONG_ANDROID_MK): $(SOONG_BOOTSTRAP) $(SOONG_VARIABLES) $(SOONG_IN_MAKE) FORCE
	$(hide) $(SOONG) $(KATI) $(MAKEPARALLEL) $(NINJA_ARGS)

$(KATI): $(SOONG_ANDROID_MK)
$(MAKEPARALLEL): $(SOONG_ANDROID_MK)
```



## Makefile函数

### 1. word

```makefile
$(word <n>,<text>)
名称:取单词函数——word。
功能:取字符串<text>中第<n>个单词。(从一开始)
返回:返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大,那么返
回空字符串。
示例:$(word 2, foo bar baz)返回值是“bar”。
```

### 2. words

```makefile
$(words <text>)
名称:单词个数统计函数——words。
功能:统计<text>中字符串中的单词个数。
返回:返回<text>中的单词数。
示例:$(words, foo bar baz)返回值是“3”。
备注:如果我们要取<text>中最后的一个单词,我们可以这样:$(word $(words <te
xt>),<text>)。
```

#### 2.1 实例解析

```makefile
TOP := $(dir $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))
```

将上述进行分解：

```makefile
# A 部分
A = $(words $(MAKEFILE_LIST))  # 这个是伪代码　返回　MAKEFILE_LIST 中单词的个数
B = $(word A,$(MAKEFILE_LIST)) # 取出　MAKEFILE_LIST　中最后一个单词
TOP := $(dir B) # 取出B文件　所对应的目录
```

### 3. dir

```makefile
$(dir <names...>)
名称:取目录函数——dir。
功能:从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠(“/”)之前
的部分。如果没有反斜杠,那么返回“./”。
返回:返回文件名序列<names>的目录部分。
示例: $(dir src/foo.c hacks)返回值是“src/ ./”。
```

### 4. patsubst

```makefile
$(patsubst <pattern>,<replacement>,<text>)
名称:模式字符串替换函数——patsubst。
功能:查找<text>中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符
合模式<pattern>,如果匹配的话,则以<replacement>替换。这里,<pattern>可以包括通
配符“%”,表示任意长度的字串。如果<replacement>中也包含“%”,那么,<replacement>
中的这个“%”将是<pattern>中的那个“%”所代表的字串。
(可以用“\”来转义,以“\%”
来表示真实含义的“%”字符)
返回:函数返回被替换过后的字符串。
```

```makefile
示例:
$(patsubst %.c,%.o,x.c.c bar.c)
把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o],返回结果是“x.c.o bar.o”
备注:
这和我们前面“变量章节”说过的相关知识有点相似。
如:
“$(var:<pattern>=<replacement>)”
相当于
“$(patsubst <pattern>,<replacement>,$(var))”,
而“$(var: <suffix>=<replacement>)” 则相当于
“$(patsubst %<suffix>,%<replacement>,$(var))”。
例如有:objects = foo.o bar.o baz.o,
那么,“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。
```

#### 4.1 实例

```makefile
TOP := $(dir $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))
TOP := $(patsubst %/,%,$(TOP)) # 将目录中最后一个/ 取掉
```

### 5. if

```makefile
if 函数很像 GNU 的 make 所支持的条件语句——ifeq(参见前面所述的章节)
,if 函数
的语法是

$(if <condition>,<then-part>)
或是
$(if <condition>,<then-part>,<else-part>)

可见,if 函数可以包含“else”部分,或是不含。即 if 函数的参数可以是两个,也可
以是三个。<condition>参数是 if 的表达式,如果其返回的为非空字符串,那么这个表达式
就相当于返回真,于是,<then-part>会被计算,否则<else-part>会被计算。
而 if 函数的返回值是,如果<condition>为真(非空字符串)
,那个<then-part>会是整个函数的返回值,
如果<condition>为假(空字符串),那么<else-part>会是整个函数的返
回值,此时如果<else-part>没有被定义,那么,整个函数返回空字串。
所以,<then-part>和<else-part>只会有一个被计算。
```

### 6. ifeq ifneq ifdef ifndef

ifeq ifneq ifdef ifndef 这些都属于　条件表达式的部分

```makefile
条件表达式的语法为:
<conditional-directive>
<text-if-true>
endif
其中<conditional-directive>表示条件关键字,如“ifeq”。这个关键字有四个。

在<conditional-directive>这一行上,多余的空格是被允许的,但是不能以[Tab]键做
为开始(不然就被认为是命令)。而注释符“#”同样也是安全的。“else”和“endif”也
一样,只要不是以[Tab]键开始就行了。

特别注意的是,make 是在读取 Makefile 时就计算条件表达式的值,并根据条件表达式
的值来选择语句,所以,你最好不要把自动化变量(如“$@”等)放入条件表达式中,因为
自动化变量是在运行时才有的。
而且,为了避免混乱,make 不允许把整个条件语句分成两部分放在不同的文件中。
```

#### 6.1 ifeq  

```makefile
ifeq (<arg1>, <arg2>)
ifeq '<arg1>' '<arg2>'
ifeq "<arg1>" "<arg2>"
ifeq "<arg1>" '<arg2>'
ifeq '<arg1>' "<arg2>"
比较参数“arg1”和“arg2”的值是否相同。当然,参数中我们还可以使用 make 的函数。
```

```makefile
ifeq ($(strip $(foo)),)
<text-if-empty>
endif
这 个 示 例 中 使 用 了 “strip” 函 数 , 如 果 这 个 函 数 的 返 回 值 是 空 ( Empty ), 那 么
<text-if-empty>就生效。
```

#### 6.2 ifneq

```makefile
ifneq (<arg1>, <arg2>)
ifneq '<arg1>' '<arg2>'
ifneq "<arg1>" "<arg2>"
ifneq "<arg1>" '<arg2>'
ifneq '<arg1>' "<arg2>"

其比较参数“arg1”和“arg2”的值是否相同,如果不同,则为真。和“ifeq”类似。
```

#### 6.3 ifdef

```makefile
ifdef <variable-name>
如 果 变 量 <variable-name> 的 值 非 空 , 那 到 表 达 式 为 真 。 否 则 , 表 达 式 为 假 。 当 然 ,
<variable-name>同样可以是一个函数的返回值。注意,ifdef 只是测试一个变量是否有值,
其并不会把变量扩展到当前位置。还是来看两个例子:
```

实例一：

```makefile
bar =
foo = $(bar)
ifdef foo　# 执行这个分之
frobozz = yes
else
frobozz = no
endif
```

实例二：

```makefile
foo =
ifdef foo
frobozz = yes
else # 执行这个
frobozz = no
endif
```

第一个例子中,“$(frobozz)”值是“yes”,第二个则是“no”。

#### 6.4 ifndef

```makefile
ifndef <variable-name>
这个我就不多说了,和“ifdef”是相反的意思

```

### 7. strip

```makefile
$(strip <string>)
名称:去空格函数——strip
功能:去掉<string>字串中开头和结尾的空字符。
返回:返回被去掉空格的字符串值。
```

```makefile
示例:
$(strip a b c )
把字串“a b c ”去到开头和结尾的空格,结果是“a b c”。
```

### 8. filter

```makefile
$(filter <pattern...>,<text>)
名称:过滤函数——filter。
功能:以<pattern>模式过滤<text>字符串中的单词,保留符合模式<pattern>的单词。可以
有多个模式。
返回:返回符合模式<pattern>的字串。
```

```makefile
示例:
sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
cc $(filter %.c %.s,$(sources)) -o foo

# 返回的结果
$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。
```

#### 8.1 实例

```makefile
# 过滤符合　dont_bother_goals 匹配规则的
A = $(filter $(dont_bother_goals), $(MAKECMDGOALS))

# 过滤后的结果不为空　则将　dont_bother := true
ifneq (A,)
dont_bother := true
endif
```

### 9. findstring

```makefile
$(findstring <find>,<in>)
名称:查找字符串函数——findstring。
功能:在字串<in>中查找<find>字串。
返回:如果找到,那么返回<find>,否则返回空字符串。
示例:
$(findstring a,a b c)
$(findstring a,b c)
第一个函数返回“a”字符串,第二个返回“”字符串(空字符串)
```

### 10.  foreach

```makefile
foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的,Makefile
中的 foreach 函数几乎是仿照于 Unix 标准 Shell(/bin/sh)中的 for 语句,或是 C-Shell
(/bin/csh)中的 foreach 语句而构建的。它的语法是:
$(foreach <var>,<list>,<text>)
这个函数的意思是,把参数<list>中的单词逐一取出放到参数<var>所指定的变量中,
然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串,循环过程中,<text>
的所返回的每个字符串会以空格分隔,最后当整个循环结束时,<text>所返回的每个字符串
所组成的整个字符串(以空格分隔)将会是 foreach 函数的返回值。
所以,<var>最好是一个变量名,<list>可以是一个表达式,而<text>中一般会使用<var>
这个参数来依次枚举<list>中的单词。举个例子:
names := a b c d
files := $(foreach n,$(names),$(n).o)
上面的例子中,$(name)中的单词会被挨个取出,并存到变量“n”中,“$(n).o”每次
根据“$(n)”计算出一个值,这些值以空格分隔,最后作为 foreach 函数的返回,所以,
$(files)的值是“a.o b.o c.o d.o”。
注意,foreach 中的<var>参数是一个临时的局部变量,foreach 函数执行完后,参数
<var>的变量将不在作用,其作用域只在 foreach 函数当中。
```



#### 10.1 实例

```makefile
incompat_javac := $(foreach v,$(KNOWN_INCOMPATIBLE_JAVAC_VERSIONS),$(findstring $(v),$(javac_version_str)))
```

将上述进行分解

```makefile
# 从KNOWN_INCOMPATIBLE_JAVAC_VERSIONS　中遍历每一个字符串，将　每个字符串给　v 

incompat_javac := $(foreach v,$(KNOWN_INCOMPATIBLE_JAVAC_VERSIONS),A)

# 从　javac_version_str　中找到v 中的字符串，如果找到，就给　incompat_javac ; 如果没有就返回 ""
A = $(findstring $(v),$(javac_version_str))
```

### 11. filter-out

```makefile
$(filter-out <pattern...>,<text>)
名称:反过滤函数——filter-out。
功能:以<pattern>模式过滤<text>字符串中的单词,去除符合模式<pattern>的单词。可以
有多个模式。
返回:返回不符合模式<pattern>的字串。
示例:
objects=main1.o foo.o main2.o bar.o
mains=main1.o main2.o
$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。
```

#### 11.1 实例

```makefile
ifneq ($(filter-out $(INTERNAL_VALID_VARIANTS),$(TARGET_BUILD_VARIANT)),)
$(info ***************************************************************)
$(info ***************************************************************)
$(info Invalid variant: $(TARGET_BUILD_VARIANT))
$(info Valid values are: $(INTERNAL_VALID_VARIANTS))
$(info ***************************************************************)
$(info ***************************************************************)
$(error stopping)
endif
```

将其分解：

```makefile
A = $(filter-out $(INTERNAL_VALID_VARIANTS),$(TARGET_BUILD_VARIANT))

ifneq (A,)

endif
```

### 12 call 函数

```makefile
call 函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达
式,这个表达式中,你可以定义许多参数,然后你可以用 call 函数来向这个表达式传递参
数。其语法是:
$(call <expression>,<parm1>,<parm2>,<parm3>...)
当 make 执行这个函数时,<expression>参数中的变量,如$(1),$(2),$(3)等,会被
参数<parm1>,<parm2>,<parm3>依次取代。而<expression>的返回值就是 call 函数的返回
值。

例如:
reverse = $(1) $(2)
foo = $(call reverse,a,b)
那么,foo 的值就是“a b”。当然,参数的次序是可以自定义的,不一定是顺序的,
如:
reverse = $(2) $(1)
foo = $(call reverse,a,b)
此时的 foo 的值就是“b a”。
```

#### 12.1 实例

```makefile
ifneq ($(filter ro.setupwizard.mode=ENABLED, $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))),)
  # Don't require the setup wizard on eng builds
  ADDITIONAL_BUILD_PROPERTIES := $(filter-out ro.setupwizard.mode=%,\
          $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))) \
          ro.setupwizard.mode=OPTIONAL
endif
```

将上述的分步骤进行讲解

```makefile
# define collapse-pairs 是被定义在　definitions.mk　文件中的
define collapse-pairs                             
$(eval _cpSEP := $(strip $(if $(2),$(2),=)))\
$(subst $(space)$(_cpSEP)$(space),$(_cpSEP),$(strip \
    $(subst $(_cpSEP), $(_cpSEP) ,$(1))))
endef



A = $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))

ifneq ($(filter ro.setupwizard.mode=ENABLED, A),)
  # Don't require the setup wizard on eng builds
  ADDITIONAL_BUILD_PROPERTIES := $(filter-out ro.setupwizard.mode=%,\
          $(call collapse-pairs, $(ADDITIONAL_BUILD_PROPERTIES))) \
          ro.setupwizard.mode=OPTIONAL
endif
```

### 13 define

```makefile
如果 Makefile 中出现一些相同命令序列,那么我们可以为这些相同的命令序列定义一
个变量。定义这种命令序列的语法以“define”开始,以“endef”结束,如:
define run-yacc
yacc $(firstword $^)
mv y.tab.c $@
endef
这里,“run-yacc”是这个命令包的名字,其不要和 Makefile 中的变量重名。在
“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行 Yacc
程序,因为 Yacc 程序总是生成“y.tab.c”的文件,所以第二行的命令就是把这个文件改改
名字。还是把这个命令包放到一个示例中来看看吧。
foo.c : foo.y
$(run-yacc)
我们可以看见,要使用这个命令包,我们就好像使用变量一样。在这个命令包的使用中,
命令包“run-yacc”中的“$^”就是“foo.y”,“$@”就是“foo.c”(有关这种以“$”
开头的特殊变量,我们会在后面介绍),make 在执行命令包时,命令包中的每个命令会被依
次独立执行。
```

#### 13.1 实例：

### 14 eval

参考连接：https://www.cnblogs.com/merlindu/p/6542805.html

**函数功能：**函数“eval”是一个比较特殊的函数。使用它可以在Makefile中构造一个可变的规则结构关系（依赖关系链），其中可以使用其它变量和函数。函数“eval”对它的参数进行展开，展开的结果作为Makefile的一部分，make可以对展开内容进行语法解析。展开的结果可以包含一个新变量、目标、隐含规则或者是明确规则等。也就是说此函数的功能主要是：根据其参数的关系、结构，对它们进行替换展开。

**返回值：**函数“eval”的返回值时空，也可以说没有返回值。

**函数说明：**“eval”函数执行时会对它的参数进行两次展开。第一次展开过程发是由函数本身完成的，第二次是函数展开后的结果被作为Makefile内容时由make解析时展开的。明确这一过程对于使用“eval”函数非常重要。理解了函数“eval”二次展开的过程后。实际使用时，如果在函数的展开结果中存在引用（格式为：$(x)），那么在函数的参数中应该使用“$$”来代替“$”。因为这一点，所以通常它的参数中会使用函数“value”来取一个变量的文本值。

```makefile
###############################################
pointer := pointed_value

define foo 
var := 123
arg := $1
$$($1) := ooooo
endef 

$(info $(call foo,pointer))
# $(eval $(call foo,pointer))
target:
	@echo -----------------------------
	@echo var: $(var), arg: $(arg)
	@echo pointer: $(pointer), pointed_value: $(pointed_value)
	@echo done.
	@echo -----------------------------
###############################################
```

```shell
######### 打印的结果
var := 123
arg := pointer
$(pointer) := ooooo
-----------------------------
var: , arg:　# 注意看这里的值都为　空
pointer: pointed_value, pointed_value:
done.
-----------------------------
```

注意，
var := 123
arg := pointer
$(pointer) := ooooo
这几行就是  $(call foo,pointer) 的结果(或者说，调用 foo 这个 "函数"(因为 Makefile 中正式的名字叫做宏包)  的返回值)。同时注意到， var, arg, pointed_value 都是空值，因为我实际上只是通过 $(info ) 函数将替换了参数后的  foo 函数体，或者说 $(call foo, pointer) 的返回值打印到标准输出而已($1 就是 pointer,  调用函数，就直接替换下参数而已)，所以，这几行代码并没有真正执行。

注意了，这个 $(call foo,pointer) 就是 Makefile 对 foo 函数的第一次求值。上面看到了，实际上求值出来的结果还是 Makefile 代码。

那么问题就来了。既然求值出来的结果还是 Makefile 代码，那这段代码又要怎么运行呢？**答案就是再包一个 eval, 所以 eval 就是第二次求值了。**
因此，如果将 $(eval $(all foo,pointer)) 那行注释取消掉的话，运行结果如下：



换做执行eval 的语句：

```makefile
###############################################
pointer := pointed_value

define foo 
var := 123
arg := $1
$$($1) := ooooo
endef 

# $(info $(call foo,pointer))
$(eval $(call foo,pointer))
target:
	@echo -----------------------------
	@echo var: $(var), arg: $(arg)
	@echo pointer: $(pointer), pointed_value: $(pointed_value)
	@echo done.
	@echo -----------------------------
###############################################
```

```makefile
# 执行结果
-----------------------------
var: 123, arg: pointer
pointer: pointed_value, pointed_value: ooooo
done.
-----------------------------
```

### 15 subst

```makefile
$(subst <from>,<to>,<text>)
名称:字符串替换函数——subst。
功能:把字串<text>中的<from>字符串替换成<to>。
返回:函数返回被替换过后的字符串。

示例:
$(subst ee,EE,feet on the street),
把 “feet on the street” 中 的 “ee” 替 换 成 “EE” , 返 回结 果 是 “fEEt on the
strEEt”。
```

#### 15.1 实例

```makefile
define collapse-pairs                             
$(eval _cpSEP := $(strip $(if $(2),$(2),=)))\
$(subst $(space)$(_cpSEP)$(space),$(_cpSEP),$(strip \
    $(subst $(_cpSEP), $(_cpSEP) ,$(1))))
endef
```

```makefile
define collapse-pairs                             
$(eval _cpSEP := $(if $(2),$(2),=)) $(subst $(space)$(_cpSEP)$(space),$(_cpSEP),$(subst $(_cpSEP), $(_cpSEP) ,$(1)))
endef
```

### 16 if

```makefile
if 函数很像 GNU 的 make 所支持的条件语句——ifeq(参见前面所述的章节),if 函数的语法是:
$(if <condition>,<then-part>)
或是
$(if <condition>,<then-part>,<else-part>)
可见,if 函数可以包含“else”部分,或是不含。即 if 函数的参数可以是两个,也可
以是三个。<condition>参数是 if 的表达式,如果其返回的为非空字符串,那么这个表达式
就相当于返回真,于是,<then-part>会被计算,否则<else-part>会被计算。
而 if 函数的返回值是,如果<condition>为真(非空字符串)
,那个<then-part>会是整
个函数的返回值,如果<condition>为假(空字符串),那么<else-part>会是整个函数的返
回值,此时如果<else-part>没有被定义,那么,整个函数返回空字串。
所以,<then-part>和<else-part>只会有一个被计算。
```

### 17 sort

```makefile
$(sort <list>)
名称:排序函数——sort。
功能:给字符串<list>中的单词排序(升序)。
返回:返回排序后的字符串。
示例:$(sort foo bar lose)返回“bar foo lose” 。
备注:sort 函数会去掉<list>中相同的单词。
```

### 18 wildcard

```makefile


在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”，它的用法是：$(wildcard PATTERN...) 。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下规则中通配符的展开和上一小节匹配通配符的区别。

一般我们可以使用“$(wildcard *.c)”来获取工作目录下的所有的.c文件列表。复杂一些用法；可以使用“$(patsubst %.c,%.o,$(wildcard *.c))”，首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录可生成的.o文件列表。因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有的.c文件进行编译并最后连接成为一个可执行文件：

 

#sample Makefile

objects := $(patsubst %.c,%.o,$(wildcard *.c))

 

foo : $(objects)

cc -o foo $(objects)

 

这里我们使用了make的隐含规则来编译.c的源文件。对变量的赋值也用到了一个特殊的符号（:=）。

 

1、wildcard : 扩展通配符
2、notdir ： 去除路径
3、patsubst ：替换通配符

例子：
建立一个测试目录，在测试目录下建立一个名为sub的子目录
$ mkdir test
$ cd test
$ mkdir sub

在test下，建立a.c和b.c2个文件，在sub目录下，建立sa.c和sb.c2 个文件

建立一个简单的Makefile
src=$(wildcard *.c ./sub/*.c)
dir=$(notdir $(src))
obj=$(patsubst %.c,%.o,$(dir) )

all:
 @echo $(src)
 @echo $(dir)
 @echo $(obj)
 @echo "end"
 
执行结果分析：
第一行输出：
a.c b.c ./sub/sa.c ./sub/sb.c

wildcard把 指定目录 ./ 和 ./sub/ 下的所有后缀是c的文件全部展开。

第二行输出：
a.c b.c sa.c sb.c
notdir把展开的文件去除掉路径信息

第三行输出：
a.o b.o sa.o sb.o

在$(patsubst %.c,%.o,$(dir) )中，patsubst把$(dir)中的变量符合后缀是.c的全部替换成.o，
任何输出。
或者可以使用
obj=$(dir:%.c=%.o)
效果也是一样的。

这里用到makefile里的替换引用规则，即用您指定的变量替换另一个变量。
它的标准格式是
$(var:a=b) 或 ${var:a=b}
它的含义是把变量var中的每一个值结尾用b替换掉a
是时候好好总结下自己走过的路。
```



## shell

### 1. expr

#### 1.1 计算表达式

expr 用于计算表达式的值

```shell
# expr expression1 操作符 expression2
# 操作符前必须加'\'用于转义，并且操作符和两个expression之间必须有空格
count=1
count=`expr $count + 1`
echo $count

# 输出为2

```

```shell
也可以使用$[]
var=$[1+5]
echo $var  //6

count=1
var=$[$count+1]
echo $var
```

```shell
最好用$(())代替，效率更高
count=1
count=$(($count+1))
echo $count # 2
```

#### 1.2 length

```shell
`expr length String1`  #  返回String1长度
```

#### 1.3 index

```shell
`expr index String1 String2`
```

  返回 *String1* 中包含 *String2* 中任意字符的第一个位置。

#### 1.4 substr

```shell
`expr substr string1 startposition length `
```

返回string1中从startposition开始的lenght个字符



### 2. data

用法：date [选项]... [+格式]
或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]

```shell
  -d,--date=字符串		显示指定字符串所描述的时间，而非当前时间
  -f,--file=日期文件		类似--date，从日期文件中按行读入时间描述
  -r, --reference=文件		显示文件指定文件的最后修改时间
  -R, --rfc-2822		以RFC 2822格式输出日期和时间
				例如：2006年8月7日，星期一 12:34:56 -0600
      --rfc-3339=TIMESPEC	以RFC 3339 格式输出日期和时间。
				TIMESPEC=`date'，`seconds'，或 `ns' 
				表示日期和时间的显示精度。
				日期和时间单元由单个的空格分开：
				2006-08-07 12:34:56-06:00
  -s, --set=字符串         	设置指定字符串来分开时间
  -u, --utc, --universal	输出或者设置协调的通用时间
      --help		显示此帮助信息并退出
      --version		显示版本信息并退出
```



#### 2.1 实例

```shell
ifeq ($(HOST_OS),darwin)
DATE_FROM_FILE := date -r $(BUILD_DATETIME_FROM_FILE) # 显示文件指定文件的最后修改时间
else
DATE_FROM_FILE := date -d @$(BUILD_DATETIME_FROM_FILE) # 显示指定字符串所描述的时间，而非当前时间
endif
```

```shell
colby@pc:~$ date -d @1398004852
2014年 04月 20日 星期日 22:40:52 CST
```

#### 2.2 实例

```shell
date +"%Y-%m-%d %H:%M:%S" # 输出当前日期和时间

date -d @1398004852 +"%Y-%m-%d %H:%M:%S" # 时间搓转datetime格式

date +%^_10A # 转大写并以空格填充
```

#### 2.3 备注

```shell
  %%	一个文字的 %
  %a	当前locale 的星期名缩写(例如： 日，代表星期日)
  %A	当前locale 的星期名全称 (如：星期日)
  %b	当前locale 的月名缩写 (如：一，代表一月)
  %B	当前locale 的月名全称 (如：一月)
  %c	当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)
  %C	世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)
  %d	按月计的日期(例如：01)
  %D	按月计的日期；等于%m/%d/%y
  %e	按月计的日期，添加空格，等于%_d
  %F	完整日期格式，等价于 %Y-%m-%d
  %g	ISO-8601 格式年份的最后两位 (参见%G)
  %G	ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用
  %h	等于%b
  %H	小时(00-23)
  %I	小时(00-12)
  %j	按年计的日期(001-366)
  %k	时(0-23)
  %l	时(1-12)
  %m	月份(01-12)
  %M	分(00-59)
  %n	换行
  %N	纳秒(000000000-999999999)
  %p	当前locale 下的"上午"或者"下午"，未知时输出为空
  %P	与%p 类似，但是输出小写字母
  %r	当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)
  %R	24 小时时间的时和分，等价于 %H:%M
  %s	自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数
  %S	秒(00-60)
  %t	输出制表符 Tab
  %T	时间，等于%H:%M:%S
  %u	星期，1 代表星期一
  %U	一年中的第几周，以周日为每星期第一天(00-53)
  %V	ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)
  %w	一星期中的第几日(0-6)，0 代表周一
  %W	一年中的第几周，以周一为每星期第一天(00-53)
  %x	当前locale 下的日期描述 (如：12/31/99)
  %X	当前locale 下的时间描述 (如：23:13:48)
  %y	年份最后两位数位 (00-99)
  %Y	年份
  %z +hhmm		数字时区(例如，-0400)
  %:z +hh:mm		数字时区(例如，-04:00)
  %::z +hh:mm:ss	数字时区(例如，-04:00:00)
  %:::z			数字时区带有必要的精度 (例如，-04，+05:30)
  %Z			按字母表排序的时区缩写 (例如，EDT)
  
  
  
  
 #以下可选标记可以跟在"%"后:
- (连字符)不填充该域
_ (下划线)以空格填充
0 (数字0)以0 填充
^ 如果可能，使用大写字母
# 如果可能，使用相反的大小写
在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。
作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的
表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。
```

### 3. unset

Linux unset命令用于删除变量或函数。

unset为shell内建指令，可删除变量或函数。

**语法**

```
unset [-fv][变量或函数名称]
```

**参数**：

- -f 　仅删除函数。
- -v 　仅删除变量。

**实例**

 删除环境变量

```shell
[root@runoob.com ~]# lx="ls -lh" //设定环境变量
[root@runoob.com ~]# $lx //使用环境变量
总用量 116K
-rw-r--r-- 1 root root 2.1K 2008-03-30 anaconda-ks.cfg
drwx------ 3 root root 4.0K 3月 30 21:22 Desktop
-rw-r--r-- 1 root root 50K 2008-03-30 install.log
-rw-r--r-- 1 root root 32K 2008-03-30 install.log.syslog
lrwxrwxrwx 1 root root  9 2008-03-30 qte -> /opt/qte/
[root@runoob.com ~]# set //查看当前的环境变量
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
……省略部分内容
PROMPT_COMMAND='echo -ne "33]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/~}07"'
PS1='[u@h W]$ '
PS2='> '
PS4='+ '
PWD=/root
QTDIR=/usr/lib/qt-3.3
SHELL=/bin/bash
SSH_TTY=/dev/pts/4
SUPPORTED=zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en
SYSFONT=latarcyrheb-sun16
TERM=xterm
UID=0
USER=root
_=-lh
lx='ls -lh'
[root@runoob.com ~]# unset lx //删除环境变量
[root@runoob.com ~]# set //显示当前环境变量
BASH=/bin/bash
BASH_ARGC=()
BASH_ARGV=()
……省略部分内容
PROMPT_COMMAND='echo -ne "33]0;${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/~}07"'
PS1='[u@h W]$ '
PS2='> '
PS4='+ '
PWD=/root
QTDIR=/usr/lib/qt-3.3
SHELL=/bin/bash
SSH_TTY=/dev/pts/4
SUPPORTED=zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en
SYSFONT=latarcyrheb-sun16
TERM=xterm
UID=0
USER=root
_=-lh
```