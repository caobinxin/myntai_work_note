**Android编译系统**

**状态：**草稿(2006年5月18日)

**正文：**

**目的：**

编译android系统工作的主要目的在于：

(1)使得依赖关系工作时更加的值得信赖，即当文件需要重新编译时可以被正确的执行；

(2)提升编译系统的表现，即不必要的模块不需要重新编译，而且如果很少的或者根本没有需要重新编译的文件时，在根目录下的编译操作会使用尽可能少的时间。

 

**原则与用例与策略：**

 

根据上述的目的，接下来的这些就是我们会支持的所有原则与用例。但这不是一个非常详尽的列表。

 

**多个目标：**

 

在android平台上进行多目标的编译是需要的，这意味着：

(1)编译系统将会支持编译主平台上的工具，同时包括在编译过程中自身用到的工具和开发者用到的工具(比如说仿真机)；

(2)编译系统需要能够在linux(明确包括Goobuntu和Grhat)、MacOS以及一定程度上在Windows上编译工具；

(3)编译系统需要能够在linux上编译android操作系统，并且在短期内支持Mac。注意停止在windows上编译android操作系统是一个有主动的决定。我们将会依赖于仿真器(emulator)而不会使用模拟器(simulator)。这是一个要求，因为仿真器的未来看起来更加的光明。

 

**不可回归的编译：**

 

为了实现这个目的，编译系统需要被重写来使得编译过程不可回归。更多的背景知识在：http://aegis.sourceforge.net/auug97.pdf，非pdf版：<http://72.14.203.104/search?q=cache:HwuX7YF2uBIJ:aegis.sourceforge.net/auug97.pdf&hl=en&gl=us&ct=clnk&cd=2&client=firefox。>

 

**快速编译测试：**

 

当开发一个组件时，例如一个c++共享库，需要能够简单地单独编译该组件，而不是需要耗费很多时间等待大量的依赖项检查和不需要的组件的编译。

 

**环境和配置文件的基本设置：**

 

为了设置目标和其他的选项，队伍里的一些人想要在一个目录中有一个配置文件这样他们就不需要运行一个环境配置脚本，而其他人想要一个可运行的环境配置脚本这样他们就可以在不同的终端进行相同的编译操作，或者在同一个终端进行回退或者更新。我们对于两种方式都支持。

 

**目标文件目录/清除命令(make clean)：**

 

目标文件和其他的中间文件需要被整合到同一个在源码树中分开的目录下。清除命令(make clean)的目标是实现和根目录下的”rm -rf”一样的功能。这里主要的目标就是可以简单地在源码树进行检索，而且使得”make  clean”更加值得信赖。

 

**SDK：**

 

SDK将会是一个压缩包，它允许非操作系统开发者能够编写app。实际上app会在第一次编译SDK时进行编译，并且在以后通过SDK来编译app。这将会：

(1)使得编写app更加的简单，因为我们不会总是重新编译android操作系统，并且我们可以使用支持的java-app开发工具来开发app；

(2)允许我们通过”dog-food”测试来帮助确定SDK的质量。

Cedric建议(而且我认同)通过SDK编译的app应该用ant来编译。请关注更多的细节，因为我们需要明确的指出他们怎么工作。

 

**依赖关系：**

 

依赖关系应该是自动的。除非有定制的工具被使用了（比如webkit中有一些），动态库和静态库以及c\cpp\h\java\java libraries库等等的依赖关系都应该在不干预Android.mk文件的前提下工作。

 

**隐藏命令行：**

 

默认条件下编译系统会在命令行中隐藏编译过程中的执行步骤。是否隐藏执行命令可以通过命令showcommands来指明需要显示的目标，也可以通过设置环境变量来修改。

 

**通配符源文件：**

 

通配符源文件会是不被鼓励的。它可能会在一些情境下有用。当前的目录被设置到编译目录的根目录时，默认的通配符$(wildcard *)不会起效果。

 

**单目录中的多个目标：**

 

可能会需要在一个给定的子目录中生成超过一个目标。比如说，libutils为目标产生了一个共享库并且为主机产生了一个静态库。

 

**模块的Makefile片段：**

 

Android.mk是控制编译所给出模块的makefile片段的标准名称。只有顶层目录才应该有一个名为”Makefile”的文件。

 

**使用共享库：**

 

现在，模拟器(simulator)已经不再被编译来使用共享库。这个是应该被修复的，而且现在是一个做这件事的好时机。这暗示着需要将共享库运行在Mac操作系统上。

 

**很高兴能够拥有这些:**

 

这些东西应该被快乐的拥有着，并且这里是一个记录他们的好地方，虽然这里没有任何的承诺。

 

**同时编译：**

 

我们希望可以同时在同一个目录树下为了不同的组合进行两个编译，但是这是一个延伸的目标，不是一个要求。不过非同时地在同一个目录下进行两个编译是必须的工作。（更新：看起来我们好像会实现同时同一目录的编译功能）

 

**删除头文件(或者其他的依赖)：**

 

当你删除一个被”.d”文件中引用到的头文件时，问题可能就会出现。简单的处理方式是”make clean”。这里应该有一个更好的方式来处理它（由fadden提出）。

一个解决的方式是在目录中介绍依赖。问题是这个方式可能会造成额外的依赖结构并且降低编译的速度。这是一个取舍。

 

**复合编译：**

 

表现已知平台的集合的编译过程的主要方式。这会更加简单地在测试一个修改时表现复合平台的编译，并且允许一个大规模的”make clean”。现在buildspec.mk或者环境变量需要在每一次的编译中被更新(fadden提出)。

 

**售后市场的场所和载体(Aftermarket Locales and Carrier)：**

 

我们最终会需要为创建场所和载体的自定义SDK添加支持，但是不会是现在。

 

**使用：**

 

现在你已经阅读了（或者浏览了）所有的编译系统的动机，并且你想要了解怎么去使用它。现在就让我们开始吧。

 

**你的第一次编译：**

 

编译文档(building.html)描述了怎么进行编译：

 

**Build/envsetup.sh的功能：**

 

如果你将文件build/envsetup.sh放入你的bash环境当中，你会获得一些有帮助的shell命令功能：

(1)printconfig------打印当前通过lunch命令以及choosecombo命令设置的配置；

(2)m------从顶层目录执行make命令。这是很有用的，因为这样你就可以在子目录里面执行make命令。如果你设置了top这个环境变量，它就会被使用。如果你没有，它会从当前目录进行搜索，直到找到目录的顶部；

(3)croot-----跳转到目录的顶部；

(4)sgrep-----通过你提供的正则表达式来过滤当前目录下所有的c\cpp\h\java\xml文件。

 

**编译特点/种类：**

 

当编译一个特殊的产品时，拥有一个镜像的最终的编译结果的变量的数据常常是有用的。这里是一些当前定义了的特征和种类（我们需要为他们确定一个真正的名称）

| eng       | 这是默认的特征. 一个简单的”make”等同于”make eng”. droid 是 eng的别名. · 安装标记为: eng, debug, user, 以及/或者 development的模块。 · 安装没有特殊标签的非apk模块。 · 通过产品定义的文件安装未标记的apk. · ro.secure=0 · ro.debuggable=1 · ro.kernel.android.checkjni=1 · Adb默认开启。 |
| --------- | ------------------------------------------------------------ |
| user      | "make user" 这是最终成为release版本的代码的特征。 · 安装标签为user的模块. · 安装没有特殊标签的非apk模块。 · 通过产品定义文件安装apk; 对于apk模块来说标签是被忽略的。 · ro.secure=1 · ro.debuggable=0 · Adb默认关闭。 |
| userdebug | "make userdebug" 与user相同, 除了: · 也安装标签为 debug的模块。 · ro.debuggable=1 · Adb默认开启。 |

 

如果你编译了一个特征然后接着编译另一个，你应该在两次编译之间运行”make installclean”命令来确认你没有选择上一个特征时安装的文件。”make clean”命令也可以，不过会耗费大量额外的时间。

**更多的伪目标：**

 

有时候你只想要编译一个小部分。下列的伪目标可以使你更加方便：

 

(1)**droid**------make droid是通常的编译方式。这个目标在这是因为默认的目标必须要有一个名称。

(2)**All**-----make all编译了每一个make droid编译的文件，而且编译了每一个LOCAL_MODULE_TAGS中没有包含”droid”标签的文件。编译服务运行这个命令是为了确定每一个源码树中有Android.mk文件的模块都被编译了。

(3)**Clean-$(LOCAL_MODULE)**以及**clean-$(LOCAL_PACKAGE_NAME)**-----使你可选择地清除一个目标。比如，你可以使用make clean-libutils命令然后它将会删除libutils.so以及所有的中间文件，或者你可以使用make  clean-Home命令然后它就会清除Home app。

(4)**Clean**-----make clean删除当前配置的输出和中间文件。这个命令等同于rm -rf out/<configuration>/

(5)**Clobber**-----make clobber删除所有配置当中的输出以及中间文件。这个命令等同于rm -rf out/。

(6)**Dataclean**-----make dataclean删除在当前组合目录中的数据目录内容。这个命令对于仿真器(emulator)和模拟器(simulator)特别地有用，因为其中的数据会在多次编译中持久的保存。

(7)**Showcommands**-----showcommands是一个可修改的目标，它会造成编译系统显示编译步骤当中的实际命令行。更多的人喜欢看到明确的描述而不是命令行，因为命令行相当长而且很难阅读，但如果你抱着debug的目的，你可以把showcommands加入到你要编译的目标当中。比如说make  showcommands会编译默认的android配置，而make runtime showcommands只会编译runtime以及它依赖的目标并且显示命令行，请记住这里有一些命令行不显示的地方。这被认为是bug，而且应该被修复，但是他们通常很难被追踪。如果你找到了，请告知android编译小队。

(8)**LOCAL_MODULE**-----任何在Android.mk当中被你选中来作为一个LOCAL_MODULE的对象都会被编译到一个伪目标当中。

(9)**Targets**------make targets 会打印一个你能编译的LOCAL_MODULE的所有名称列表。

**怎样添加一个组件到Android.mk的编译模块当中:**

 

你有一个新的库、app或者一个新的可执行文件。对于每一个模板中的通用种类，都有一个在模板目录当中与之对应的文件。通常复制其中之一并且填入你自己的值就已经够了。一些更加少用的值没有被包含到模块当中，但通过文档进行了替代，正如文档中记录了用自定义的工具来生成文件的方法。

通常的，你可以通过查看模块中的TODO注释并且按照它的内容来做。请记住完成后删除TODO注释来保证文件集的干净整洁。模块有着最小的文档说明，因为他们可能会被复制到其他地方，这样当文档变得过时需要更新的时候，复制的内容却不会得到更新。所以请继续阅读…



**Apps:**

 

使用 templates/apps  文件。

这个模板相当的自解释。看下面的变量来了解更多的细节。

 

**Java 库:**

使用templates/java_library文件

有意思的事是这里LOCAL_MODULE的值成为了jar文件的名称。（事实上现在我们还没有编译jar文件，仅仅编译了.class文件的目录，但是目录是通过你放在LOCAL_MODULE中的内容来命名的）这个名称会放到对应模块的LOCAL_JAVA_LIBRARIES当中，它们依赖于你的java库。

 

**C/C++ 可执行文件：**

 

使用templates/executable文件，或者templates/executable_host文件。

这个模板有一些你平常不需要的额外的选项。请删除掉你不需要的部分，并且移除掉TODO注释。这使得剩下的部分更加容易阅读，而且你总是可以在需要他们的时候再次使用这些模板。

默认的，在target当中的c/c++可执行文件被编译到/system/bin当中，host当中的被编译到/host/bin当中。这些可以通过设置LOCAL_MODULE_PATH或者LOCAL_MODUL_RELATIVE_PATH来进行修改。查看Putting  targets elsewhere（build-system.html#moving-targets文件）来获取更多信息。

 

**共享库:**

 

使用templates/shared_library文件或者templates/shared_library_host文件。

记住在这个目标当中，我们使用了共享库，并且在主机中，我们使用了静态库，因为发行后可执行文件的大小不是固定的，而且它简化了在SDK中的介绍。

 

**使用自定义工具：**

 

如果你有一个为你自己生成源文件的工具，使得这个编译系统为你的工具获取正确的依赖关系。这里有一些例子。$@在编译当中的含义是“当前的目标”。红色的部分是你需要修改的部分。

 

你需要把这个流程放到你已经明确了LOCAL_PATH以及LOCAL_MODULE之后，因为$(local-generated-sources-dir)和$(local-host-generated-sources-dir)大量地使用到这两个变量来指明把文件放到哪里。

 

例子1：

 

这里有一个已经生成的文件，叫做chartables.c，它并不依赖于任何文件。而且是被编译在$(HOST_OUT_EXEUTABLES)/dftables的文件编译的。把依赖于工具的信息记录到倒数第二行。

 

intermediates:= $(local-generated-sources-dir)

GEN := $(intermediates)/chartables.c

$(GEN): PRIVATE_CUSTOM_TOOL = $(HOST_OUT_EXECUTABLES)/dftables $@

$(GEN): $(HOST_OUT_EXECUTABLES)/dftables

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

 

例子2：

 

这里有一个假定的例子，我们使用cat命令来传递一个文件。假定它做了一些有用的事。记录我们使用了一个目标明确的名为PRIVATE_INPUT_FILE的变量来存储输入文件的名称。

 

intermediates:= $(local-generated-sources-dir)

GEN := $(intermediates)/file.c

$(GEN): PRIVATE_INPUT_FILE := $(LOCAL_PATH)/input.file

$(GEN): PRIVATE_CUSTOM_TOOL = cat $(PRIVATE_INPUT_FILE) > $@

$(GEN): $(LOCAL_PATH)/file.c

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

 

例子3：

 

如果你有一些名字类似的文件，并且使用了相同的工具，你可以把他们组合起来。（这里的*.lut.h文件是生成的文件，*.cpp文件是输入的文件）

 

intermediates:= $(local-generated-sources-dir)

GEN := $(addprefix $(intermediates)/kjs/, \

​            array_object.lut.h \

​            bool_object.lut.h \

​        )

$(GEN): PRIVATE_CUSTOM_TOOL = perl libs/WebKitLib/WebKit/JavaScriptCore/kjs/create_hash_table $< -i > $@

$(GEN): $(intermediates)/%.lut.h : $(LOCAL_PATH)/%.cpp

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

 

**平台的特殊环境：**

 

有时候你需要为不同的平台设置特别的标签。这里有一个已定义的变量将被设置到的编译系统的值的列表和一些例子。

编译一个硬件的时候，TARGET_OS是linux(我们在使用linux)，并且TARGET_ARCH是arm。

编译一个模拟器的时候，TARGET_OS和TARGET_ARCH被设置为和HOST_OS一样而且HOST_ARCH取决于你的平台。TARGET_PRODUCT是你正在编译的hardware/product目标的名称。sim的值被用于模拟器。我们还没有考虑过在这里会发生的全流程定制，但是似乎这里会有额外的针对性的UI配置。

 

 

| **HOST_OS**  linux  darwin  (cygwin)   | **HOST_ARCH**  x86        | **HOST_BUILD_TYPE**  release  debug   |                                        |
| -------------------------------------- | ------------------------- | ------------------------------------- | -------------------------------------- |
| **TARGET_OS**  linux  darwin  (cygwin) | **TARGET_ARCH**  arm  x86 | **TARGET_BUILD_TYPE**  release  debug | **TARGET_PRODUCT**  sim  dream  sooner |



**一些例子：**

 

ifeq ($(TARGET_BUILD_TYPE),release)

LOCAL_CFLAGS += -DNDEBUG=1

endif

 

\# from libutils

ifeq ($(TARGET_OS),linux)

\# Use the futex based mutex and condition variable

\# implementation from android-arm because it's shared mem safe

LOCAL_SRC_FILES += futex_synchro.c

LOCAL_LDLIBS += -lrt -ldl

endif

 

**把模块放到其他地方:**

 

如果你有在一些地方能正常使用的模块，并且你需要让它们在其他地方进行编译，阅读接下来的内容。

如果你有一些需要运行在它们本来的位置的子目录的模块，比如说HAL模块需要被运行在/system/lib/hw或者/vendor/lib/hw里面，在你的Android.mk文件中对LOCAL_MODUL_RELATIVE_PATH进行设置，比如：

LOCAL_MODUL_RELATIVE_PATH := hw

如果你有一些需要在完全不同的位置运行的模块，比如不是在/system中的根文件系统，把这些行加入到你的Android.mk文件当中：

LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)

LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_SBIN_UNSTRIPPED)

对于可执行文件以及库文件，如果你明确了一个LOCAL_MODULE_PATH，你需要指明一个LOCAL_UNSTRIPPED_PATH位置，因为在目标编译中，我们保持了未剥离的可执行文件，所以GDB可以找到这些记号。LOCAL_UNSTRIPPED_PATH不是必要的，如果你只是指明了LOCAL_MODULE_RELATIVE_PATH。

查看config/envsetup.make  来得到所有定义了需要编译文件的位置的变量。

FYI：如果你正在安装一个可执行文件到/bin目录下，你可能也想要把LOCAL_FORCE_STATIC_EXCUTABLE := true设置到你的Android.mk文件当中，这会强制连接器只接受静态库。

 

**Android.mk 变量**

 

这些是你会常常在Android.mk文件当中看到的变量，按照字母顺序进行了列举。

但是首先，是变量的名称：

(1)**LOCAL_**------这些变量在每个模块中都被设置。他们被命令include $(CLEAR_VARS)清理，所以你可以在包含include $(CLEAR_VARS)命令后，相信他们是空的。在你会使用的大多数的模块中的大多数变量都是LOCAL_变量。

(2)**PRIVATE_**------这些变量是编译指定目标的变量。那意味着他们只在特定模块的命令当中是有用的。这也意味着他们不太可能在你所包含的模块结束后发生改变。这个链接与编译的文档([http://www.gnu.org/software/make/manual/make.html#Target_002dspecific)描述了更多的指定目标的变量](https://blog.csdn.net/class_brick/article/details/70859809#Target_002dspecific)描述了更多的指定目标的变量)。请记住有些源码树中的私有变量没有以PRIVATE_作为前缀。这是安全的，并且他们会在他们被发现的时候被修复。对于造成的疑惑道歉。

(3)**INTERNAL_**------这些变量是对编译系统的功能至关重要的，所以你不应该创建以这个作为前缀的变量，并且你也许也并不应该在你的makefile文件中弄乱这些变量。

(4)**HOST_和TARGET_**------这些变量包含了明确指向主机以及目标的目录以及定义。不要在你的makefile文件当中设置以HOST_或者TARGET开始的变量。

(5)**BUILD_**和**CLEAR_VARS**------这些变量包含了需要包含的定义好的模板makefile文件。一些例子是CLEAR_VARS和BUILD_HOST_PACKAGE。

(6)任何在你的Android.mk文件当中的其他名称的使用都是公平的。然而，记住这是一个不可回归的编译系统，所以你的变量可能会被另一个更晚包含的Android.mk文件修改，并且在你的规则或者模块的命令执行时变得不一样。

 

**LOCAL_ASSET_FILES：**

 

在Android.mk文件当中include $(BUILD_PACKAGE)将下面的句子设置到了你想要设置到的你的app的文件集合当中，通常是：

LOCAL_ASSET_FILES += $(call find-subdir-assets)

当我们选择ant作为app的编译系统时，这个可能会改变。

 

**LOCAL_CC：**

 

如果你想要在模块当中使用一个不同的C编译器，设置LOCAL_CC为编译器的路径。如果LOCAL_CC是空白的，适合的默认编译器将被使用。

 

**LOCAL_CXX：**

 

如果你想要在模块中使用一个不一样的C++编译器，把LOCAL_CXX设置为编译器的路径。如果LOCAL_CXX是空白的，适合的默认编译器将被使用。

 

**LOCAL_CFLAGS:**

 

如果你有额外的标签来传递到C/C++编译器，把他们加到这里。比如说：

LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1

 

**LOCAL_CPPFLAGS：**

 

如果你有只传递给C++编译器的额外标签，把他们加到这。比如说：

LOCAL_CPPFLAGS += -ffriend-injection

LOCAL_CPPFLAGS 被保证会放在LOCAL_CFLAGS的编译行之后，所以你可以使用它来覆盖LOCAL_CFLAGS列表中的标签。

 

**LOCAL_CPP_EXTENSION：**

 

如果你的C++文件以非”.cpp”来结尾，你可以在这里指明自定义扩展名;现在混合不同的扩展名是不可能的。

 

**LOCAL_NO_DEFAULT_COMPILER_FLAGS：**

 

通常的，这条编译命令在C/C++文件中包含了全局包含路径和全局CFLAGS。如果LOCAL_NO_DEFAULT_COMPILER_FLAGS非空，当前模块模块的C/C++文件的编译时没有默认的包含或者标签会被使用。LOCAL_C_INCLUDES,LOCAL_CFLAGS,和LOCAL_CPPFLAGS依然会载这个模块中被使用，同时任何在模块中被定义的DEBUG_CFLAGS也都会被使用。

 

**LOCAL_COPY_HEADERS：**

**即将被移除**



需要被复制到安装的包含树的文件集合。你同时也必须要支持LOCAL_COPY_HEADERS_TO。

此变量将被移除的原因是复制头文件使得错误信息变得混乱，并且可能会导致人们编辑那些不正确的头文件。这也会导致系统中更容易出现错误的层级，这是我们想要避免的。我们也没有在制作一个C/C++ SDK,所以这里没有一个复制任何头文件的根本需求。

 

**LOCAL_COPY_HEADERS_TO**

**即将被移除**

 

一个把LOCAL_COPY_HEADER中列举的头文件所复制到的目录。

此变量将被移除的原因是复制头文件使得错误信息变得混乱，并且可能会导致人们编辑那些不正确的头文件。这也会导致系统中更容易出现错误的层级，这是我们想要避免的。我们也没有在制作一个C/C++ SDK,所以这里没有一个复制任何头文件的根本需求。

 

**LOCAL_C_INCLUDES：**

 

额外的目录来通知C/C++编译器在其中寻找头文件。这些路径起始于源代码树的根目录。如果你想要把你自己的子目录加入到包含路径当中，使用LOCAL_PATH变量。比如说：

LOCAL_C_INCLUDES += extlibs/zlib-1.2.3

LOCAL_C_INCLUDES += $(LOCAL_PATH)/src

但是你不应该把包含的子目录再加入到LOCAL_C_INCLUDES当中，同时你应该把那些文件引用到他们的子目录中的#include状态当中。比如说：

\#include <utils/KeyedVector.h>

而不是 ~~#include <KeyedVector.h>~~

有一些组件在处理这个变量时是错误的，并且应当被清除。

 

**LOCAL_REQUIRED_MODULES:**

 

用任何以空白分开的模块名设置LOCAL_REQUIRED_MODULES，比如”libblah”或者”Email”。如果这个模块被安装了，所有它需求的模块都会被安装。这个变量可以被用来确认当一个给予的app安装时必要的共享库或者提供者被安装了。

 

**LOCAL_FORCE_STATIC_EXECUTABLE:**

 

如果你的可执行文件需要被静态链接，设置LOCAL_FORCE_STATOC_EXECUTABLE:=true。有一个我们采用静态模式执行的非常小的库的列表（现在只有libc）。这个变量只被用于根目录下的/sbin的可执行文件。

 

**LOCAL_GENERATED_SOURCES：**

 

被添加到LOCAL_GENERATED_SOURCES当中的文件会在你的模块被编译的时候自动的生成并链接。阅读自定义工具（build-system.html#custom-tools）模块中的makefile文件来获取一个例子。

 

**LOCAL_JAVACFLAGS：**

 

如果你有要传递给javac编译器的额外的标签，把他们加到这里。比如说：

LOCAL_JAVACFLAGS += -Xlint:deprecation

 

**LOCAL_JAVA_LIBRARIES：**

 

当链接Java apps和库的时候，LOCAL_JAVA_LIBRARIES明确了需要包含的java类集合。现在这些集合有两个：core和framework。在大多数的场合，它会看起来像接下来的东西：

LOCAL_JAVA_LIBRARIES := core framework

记住在通过”include $(BUILD_PACKAGE)”编译一个APK时设置LOCAL_JAVA_LIBRARIES是不必要的（同时也是不允许的）。适合的库会被自动的包含。

 

**LOCAL_LDFLAGS：**

 

你可以通过设置LOCAL_LDFLAGS来把额外的标签传递给连接器。记住参数的顺序对于ld是十分重要的，所以不管你做了什么，在所有的平台上进行测试。

 

**LOCAL_LDLIBS：**

 

LOCAL_LDLIBS允许你指明不属于你的可执行文件或者库的编译部分的额外的库。用-lxxx的形式来指明你想要的库；他们会被直接传递到链接的命令行。然而，记住不会有任何的依赖产生到这些库上面。当你想要使用一个在主机上预先安装的库来编译一个仿真机的时候，这个变量将会非常有用。连接器是一个非常挑剔的老顽固，所以有时候传递一些其他的标签到这里会变得非常重要，如果你在做一些鬼鬼祟祟的小动作的话。比如说：

LOCAL_LDLIBS += -lcurses -lpthread

LOCAL_LDLIBS += -Wl, -z, origin

 

**LOCAL_NO_MANIFEST：**

 

如果你的包不包含一个manifest(AndroidManigest.xml)，那么设置LOCAL_NO_MANIFEST := true。普通的资源包这么做了。

 

**LOCAL_PACKAGE_NAME：**

 

LOCAL_PACKAGE_NAME是app的名字。比如说，Dialer，Contacts，等等。它可能

会改变或者消失，当我们切换到一个基于ant的app编译系统时。

 

**LOCAL_PATH：**

 

你的Android.mk文件所在的目录。你可以通过把接下来的内容放到你的Android.mk文件的第一行来设置它：

LOCAL_PATH := $(my-dir)

my-dir大量地使用了MAKEFILE_LIST(http://www.gnu.org/software/make/manual/make.html#MAKEFILE_005fLIST-Variable)文件中的变量，所以在你包含任何其他的makefile文件前调用它。同时，

考虑到你包含的任何子目录都可能重置LOCAL_PATH，所以在包含他们之前设置好这些内容。这同样也意味着如果你想要写入几行include来引用LOCAL_PATH，它不会生效，因为那些引用到的makefile文件可能会重置LOCAL_PATH。

 

**LOCAL_POST_PROCESS_COMMAND：**

 

对于可执行的主机文件，你可以指定一个命令行使得一个模块被链接后直接运行。你可能不得不经过一些曲折的道路来使得变量名正确，由于一些或早或晚的变量诊断：

module := $(HOST_OUT_EXECUTABLES)/$(LOCAL_MODULE)

LOCAL_POST_PROCESS_COMMAND := /Developer/Tools/Rez -d __DARWIN__ -t APPL\

​       -d __WXMAC__ -o $(module) Carbon.r



**LOCAL_PREBUILT_EXECUTABLES：**

 

当包含$(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)的时候，把这些设置到你想要复制的可执行文件里。他们会自动的置入到正确的bin目录下。

 

**LOCAL_PREBUILT_LIBS：**

 

当包含$(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)的时候，把这些库设置到你想要复制的可执行文件里。他们会自动的置入到正确的bin目录下。

 

**LOCAL_SHARED_LIBRAIES：**

 

这些是你将要直接链接的库。你不需要过渡性的传递包含的库。不加后缀的指明这些文件：

LOCAL_SHARED_LIBRARIES := \

​     libutils \

​    libui \

​     libaudio \

​     libexpat \

​     libsgl

 

**LOCAL_SRC_FILES：**

 

编译系统通过查看LOCAL_SRC_FILES来知道哪些源文件需要被编译-----.cpp/.c/.y/.l/.java。对于lex和yacc文件，他知道如何正确的自动进行.h/和.c/.cpp文件的中转。如果文件是在一个包含了Android.mk的子目录当中，在他们前面加上目录的名称：

LOCAL_SRC_FILES := \

​     file1.cpp \

​      dir/file2.cpp

 

**LOCAL_STATIC_LIBRARIES：**

 

这些是你想要加入到你的模块当中的静态库。总的来说，我们使用共享库，但是有些地方，比如bin目录下的可执行文件以及主机可执行文件，我们使用了静态库来替代。

 

LOCAL_STATIC_LIBRARIES := \

​     libutils \

​      libtinyxml

 

**LOCAL_MODULE：**

 

LOCAL_MODULE是被期望于产生在你的Android.mk当中(编译后生成)的名字。比如说，对于libkjs，LOCAL_MODULE是”libkjs”(编译系统添加了合适的后缀------.so/.dylib/.dll)。对于app模块，使用LOCAL_PACKAGE_NAME而不是LOCAL_MODULE。我们正在计划切换到ant来编译app，所以这个还是值得讨论的。

 

**LOCAL_MODULE_PATH：**

 

通知编译系统来将模块放置到对于它的类型不是通常要放到的地方。如果你覆写了这个变量，确定你也设置了LOCAL_UNSTRIPPED_PATH，因为如果它不是一个可执行文件或者共享库，至少这个未拆开的二进制有地方来进行存放。如果你忘记了设置LOCAL_UNSTRIPPED_PATH，一个错误会被报出来。

阅读本文的**把模块放到其他地方**来获取更多信息。

 

**LOCAL_MODULE_RELATIVE_PATH：**

 

通知编译系统来将一个模块放置到它的类型通常需要放到的目录的子目录下。如果你设置了这个，你就可以不需要设置LOCAL_UNSTRIPPED_PATH，未拆分的二进制文件也会使用关联的路径。

阅读本文的**把模块放到其他地方**来获取更多信息。

 

**LOCAL_UNSTRIPPED_PATH：**



通知编译系统来把未明确版本的模块来放到对于它的版本不通常放到的地方。通常的，你覆写了这个是因为你为了一个可执行文件或者共享库修改了LOCAL_MODULE_PATH变量。如果你覆写了LOCAL_MODULE_PATH变量，但是没有覆写LOCAL_UNSTRIPPED变量，一个错误将会发生。

阅读本文的**把模块放到其他地方**来获取更多信息。

 

**LOCAL_WHOLE_STATIC_LIBRARIES：**



这些是一些你想要在不允许连接器删除掉过时的代码的情况下包含到你的模块中的静态库。它最有用的地方是当你想要把一个静态库加入到共享库而且使得这个静态库的内容暴露给共享库时。

LOCAL_WHOLE_STATIC_LIBRARIES := \

Libsqlite3_android

 

**LOCAL_YACCFLAGS：**



任何传递给你的模块的yacc调用。这里一个已知的限制是你的模块中的所有YACC的调用都是相同的。这个可以被修复。如果你曾经希望它变成这样，只需要问我们。

LOCAL_YACCFLAGS := -o kjsyy

 

**实现细节：**

 

除非你正在添加一个新的平台、工具或者添加新的特性到编译系统，你永远也不应该接触到配置目录中的任何内容。总的来说，在你走入android编译系统的泥潭前，请先请教编译系统的拥有者（android编译小队mailto:android-build-team）。也就是说，这里有一些在表面之下的笔记。

 

**环境配置/buildspec.mk 版本：**

 

为了使得人们能够更简单地修改编译系统，当改变buildspec.mk或者重新运行环境配置脚本变得必要时，他们在BUILD_ENV_SEQUENCE_NUMBER当中包含了一个版本号。如果这个变量并不与编译系统预期的相对应，编译就会失败并打印出错误信息来解释发生了什么。如果你做了一个需要更新的改动，你需要更新两个地方，然后消息才会被打印。

(1)在config/envsetup.make中，增长CORRECT_BUILD_ENV_SEQUENCE_NUMBER的定义。

(2)在buildspec.mk.default中，更新BUILD_ENV_SEQUENCE_DUMBER定义来与config/envsetup.make中的其中一个进行对应。

自动化脚本从编译系统当中取得值，所以他们也会触发警告。

 

**额外的makefile变量：**

 

你也许不应该使用这些变量。在使用他们之前请去请教android编译小队。这些主要是为了其他重大问题的工作或者是并没有完全正确运行的东西。

 

**LOCAL_ADDITIONAL_DEPENDENCIES：**

 

如果你的模块需要依赖于任何并不在其中编译的东西，你可以把这些编译目标加入到LOCAL_ADDITIONAL_DEPENDENCIES当中。通常的这是一个为了一些非自动化创建的依赖关系工作的工作区。

 

**LOCAL_BUILT_MODULE：**



当一个模块被编译时，这个模块被创建到一个中间目录然后复制到最终的位置。LOCAL_BUILT_MODULE是中间文件的全路径。查看LOCAL_INSTALLED_MODULE来了解模块的最终安装位置的路径。

 

**LOCAL_HOST：**



通过host_xxx.make的包含关系的设置来告诉base_rules.make和其他的我们正在为主机编译的包含文件。Kenneth把这个做成了openbinder的一部分，并且我更喜欢将它清空所以规则、包含关系和定义不会在主机和目标之间重复。

 

**LOCAL_INSTALLED_MODULE：**



模块最终所处的位置的路径的全称。查看LOCAL_BUILT_MODULE来了解中间文件的位置，这些文件实际表明了变异规则构造的方式。

 

**LOCAL_REPLACE_VARS：**

 

用于一些遗留的openbinder的特殊值集合的编译脚本的资料。

 

**LOCAL_SCRIPTS：**



用于一些openbinder编译系统中我们也许会发现方便的脚本文件。

 

**LOCAL_MODULE_CLASS：**

 

这是一种模块。这个变量被用于创建其他的用来放置模块的其他变量名。查看base_rules.make和envsetup.make。

 

**LOCAL_MODULE_NAME：**

 

设置为LOCAL_BUILT_MODULE的叶名字。我不确定，但是看起来它被用在WHO_AM_I变量来确定漂亮的打印出什么在被编译。

 

**LOCAL_MODULE_SUFFIX：**

 

后缀会被追加到LOCAL_MODULE来形成LOCAL_MODULE_NAME。比如说，.so/.a/.dylib。

 

**LOCAL_STRIP_MODULE：**

 

通过在base_rules.make文件中计算来指明是否这个模块应该真正的被剥离，基于是否LOCAL_STRIPPABLE_MODULE被设置，以及是否这个组合在曾经的剥离模块当中被配置。在Iliyan的剥离工具中，这个可能会改变。

 

**LOCAL_STRIPPABLE_MODULE：**

 

通过包含makefile文件来设置，如果模块是可剥离的。可执行文件和共享库都是这样。

 

**LOCAL_SYSTEM_SHARED_LIBRARIES：**

 

当编译基本库:libc、libm、libdl时被使用。通常它被设置为”none”，正如在$(CLEAR_VARS)中。当编译这些库的时候，它被设置为他们链接的目标。比如说,libc，libstdc++和libdl并不和其他任何东西链接，并且libm链接到libc。通常的，当值为none的时候，这些变量会自动的链接到可执行文件和库，所以你不需要手动的指明他们。


**原文：**

# **Android Build System**

**Status:** *Draft*   (as of May 18, 2006) 

**Contents**

## **Objective**

The primary goals of reworking the build system are (1) to make  dependencies work more reliably, so that when files need to rebuilt,  they are, and (2) to improve performance of the build system so that  unnecessary modules are not rebuilt, and so doing a  top-level build when little or nothing needs to be done for a build  takes as little time as possible.

## **Principles and Use Cases and Policy**

Given the above objective, these are the overall principles and use cases that we will support. This is not an exhaustive list.

### **Multiple Targets**

It needs to be possible to build the Android platform for multiple targets. This means:

· The build system will support building tools for the host platform,  both ones that are used in the build process itself, and developer  tools like the simulator.

· The build system will need to be able to build tools on Linux  (definitely Goobuntu and maybe Grhat), MacOS, and to some degree on  Windows.

· The build system will need to be able to build the OS on Linux, and  in the short-term, MacOS. Note that this is a conscious decision to  stop building the OS on Windows. We are going to rely on the emulator  there and not attempt to use the simulator. This  is a requirement change now that the emulator story is looking  brighter.

### **Non-Recursive Make**

To achieve the objectives, the build system will be rewritten to use make non-recursively. For more background on this, read[Recursive Make  Considered Harmful](http://aegis.sourceforge.net/auug97.pdf). For those that don't want PDF, here is the[Google  translated version](http://72.14.203.104/search?q=cache:HwuX7YF2uBIJ:aegis.sourceforge.net/auug97.pdf&hl=en&gl=us&ct=clnk&cd=2&client=firefox). 

### **Rapid Compile-Test Cycles**

When developing a component, for example a C++ shared library, it  must be possible to easily rebuild just that component, and not have to  wait more than a couple seconds for dependency checks, and not have to  wait for unneeded components to be built.

### **Both Environment and Config File Based Settings**

To set the target, and other options, some people on the team like to  have a configuration file in a directory so they do not have an  environment setup script to run, and others want an environment setup  script to run so they can run builds in different  terminals on the same tree, or switch back and forth in one terminal.  We will support both.

### **Object File Directory / make clean**

Object files and other intermediate files will be generated into a  directory that is separate from the source tree. The goal is to have  make clean be "rm -rf " in the tree root directory. The primary goals of  this are to simplify searching the source tree,  and to make "make clean" more reliable.

### **SDK**

The SDK will be a tarball that will allow non-OS-developers to write  apps. The apps will actually be built by first building the SDK, and  then building the apps against that SDK. This will hopefully (1) make  writing apps easier for us, because we won't have  to rebuild the OS as much, and we can use the standard java-app  development tools, and (2) allow us to dog-food the SDK, to help ensure  its quality. Cedric has suggested (and I agree) that apps built from the  SDK should be built with ant. Stay tuned for more  details as we figure out exactly how this will work.

### **Dependecies**

Dependencies should all be automatic. Unless there is a custom tool  involved (e.g. the webkit has several), the dependencies for shared and  static libraries, .c, .cpp, .h, .java, java libraries, etc., should all  work without intervention in the Android.mk  file.

### **Hiding command lines**

The default of the build system will be to hide the command lines  being executed for make steps. It will be possible to override this by  specifying the showcommands pseudo-target, and possibly by setting an  environment variable.

### **Wildcard source files**

Wildcarding source file will be discouraged. It may be useful in some  scenarios. The default $(wildcard *) will not work due to the current  directory being set to the root of the build tree.

### **Multiple targets in one directory**

It will be possible to generate more than one target from a given  subdirectory. For example, libutils generates a shared library for the  target and a static library for the host.

### **Makefile fragments for modules**

**Android.mk** is the standard name for the makefile  fragments that control the building of a given module. Only the top  directory should have a file named "Makefile".

### **Use shared libraries**

Currently, the simulator is not built to use shared libraries. This  should be fixed, and now is a good time to do it. This implies getting  shared libraries to work on Mac OS.

## **Nice to Have**

These things would be nice to have, and this is a good place to record them, however these are not promises.

### **Simultaneous Builds**

The hope is to be able to do two builds for different combos in the  same tree at the same time, but this is a stretch goal, not a  requirement. Doing two builds in the same tree, not at the same time  must work. (update: it's looking like we'll get the two  builds at the same time working)

### **Deleting headers (or other dependecies)**

Problems can arise if you delete a header file that is referenced in  ".d" files. The easy way to deal with this is "make clean". There should  be a better way to handle it. (from fadden)

One way of solving this is introducing a dependency on the directory.  The problem is that this can create extra dependecies and slow down the  build. It's a tradeoff.

### **Multiple builds**

General way to perform builds across the set of known platforms. This  would make it easy to perform multiple platform builds when testing a  change, and allow a wide-scale "make clean". Right now the buildspec.mk  or environment variables need to be updated  before each build. (from fadden)

### **Aftermarket Locales and Carrier**

We will eventually need to add support for creating locales and  carrier customizations to the SDK, but that will not be addressed right  now.

## **Usage**

You've read (or scrolled past) all of the motivations for this build  system, and you want to know how to use it. This is the place.

### **Your first build**

The [Building](https://blog.csdn.net/class_brick/article/details/70859809) document describes how do do builds.

### **build/envsetup.sh functions**

If you source the file build/envsetup.sh into your bash environment, .  build/envsetup.shyou'll get a few helpful shell functions:

· **printconfig** - Prints the current configuration as set by the lunch and choosecombo commands.

· **m** - Runs make from the top of the tree. This is  useful because you can run make from within subdirectories. If you have  the TOP environment variable set, it uses that. If you don't, it looks  up the tree from the current directory, trying  to find the top of the tree.

· **croot** - cd to the top of the tree.

· **sgrep** - grep for the regex you provide in all .c, .cpp, .h, .java, and .xml files below the current directory.

### **Build flavors/types**

When building for a particular product, it's often useful to have  minor variations on what is ultimately the final release build. These  are the currently-defined "flavors" or "types" (we need to settle on a  real name for these).

| eng       | This is the default flavor. A plain "make" is the same as "make eng". droid is an alias for eng. · Installs modules tagged with: eng, debug, user, and/or development.  · Installs non-APK modules that have no tags specified.  · Installs APKs according to the product definition files, in addition to tagged APKs. · ro.secure=0  · ro.debuggable=1  · ro.kernel.android.checkjni=1  · adb is enabled by default. |
| --------- | ------------------------------------------------------------ |
| user      | "make user"  This is the flavor intended to be the final release bits.  · Installs modules tagged with user.  · Installs non-APK modules that have no tags specified.  · Installs APKs according to the product definition files; tags are ignored for APK modules. · ro.secure=1  · ro.debuggable=0  · adb is disabled by default. |
| userdebug | "make userdebug"  The same as user, except:  · Also installs modules tagged with debug.  · ro.debuggable=1  · adb is enabled by default. |

If you build one flavor and then want to  build another, you should run "make installclean" between the two makes  to guarantee that you don't pick up files installed by the previous  flavor. "make clean" will also suffice, but it takes a lot longer.

### **More pseudotargets**

Sometimes you want to just build one thing. The following pseudotargets are there for your convenience:

· **droid** - make droid is the normal build. This target is here because the default target has to have a name.

· **all** - make all builds everything make droid does,  plus everything whose LOCAL_MODULE_TAGS do not include the "droid" tag.  The build server runs this to make sure that everything that is in the  tree and has an Android.mk builds.

· **clean-$(LOCAL_MODULE)** and **clean-$(LOCAL_PACKAGE_NAME)** -  Let you selectively clean one target. For example, you can type make  clean-libutils and it will delete libutils.so and all of the  intermediate files, or you can type  make clean-Home and it will clean just the Home app.

· **clean** - make clean deletes all of the output and  intermediate files for this configuration. This is the same as rm -rf  out/<configuration>/

· **clobber** - make clobber deletes all of the output and intermediate files for all configurations. This is the same as rm -rf out/.

· **dataclean** - make dataclean deletes contents of the  data directory inside the current combo directory. This is especially  useful on the simulator and emulator, where the persistent data remains  present between builds.

· **showcommands** - showcommands is a modifier target  which causes the build system to show the actual command lines for the  build steps, instead of the brief descriptions. Most people don't like  seeing the actual commands, because they're  quite long and hard to read, but if you need to for debugging purposes,  you can add showcommands to the list of targets you build. For example  make showcommands will build the default android configuration, and make  runtime showcommands will build just the  runtime, and targets that it depends on, while displaying the full  command lines. Please note that there are a couple places where the  commands aren't shown here. These are considered bugs, and should be  fixed, but they're often hard to track down. Please  let [android-build-team](mailto:android-build-team) know if you find any.

· **LOCAL_MODULE** - Anything you specify as a  LOCAL_MODULE in an Android.mk is made into a pseudotarget. For example,  make runtime might be shorthand for make  out/linux-x86-debug/system/bin/runtime (which would work), and make  libkjs might  be shorthand for make out/linux-x86-debug/system/lib/libkjs.so (which  would also work).

· **targets** - make targets will print a list of all of the LOCAL_MODULE names you can make.

### **How to add another component to the build - Android.mk templates**

You have a new library, a new app, or a new executable. For each of  the common types of modules, there is a corresponding file in the  templates directory. It will usually be enough to copy one of these, and  fill in your own values. Some of the more esoteric  values are not included in the templates, but are instead just  documented here, as is the documentation on using custom tools to  generate files.

Mostly, you can just look for the TODO comments in the templates and  do what it says. Please remember to delete the TODO comments when you're  done to keep the files clean. The templates have minimal documentation  in them, because they're going to be copied,  and when that gets stale, the copies just won't get updated. So read  on...

#### **Apps**

Use the templates/apps file.

This template is pretty self-explanitory. See the variables below for more details.

#### **Java Libraries**

Use the templates/java_library file.

The interesting thing here is the value of LOCAL_MODULE, which  becomes the name of the jar file. (Actually right now, we're not making  jar files yet, just directories of .class files, but the directory is  named according to what you put in LOCAL_MODULE).  This name will be what goes in the LOCAL_JAVA_LIBRARIES variable in  modules that depend on your java library.

#### **C/C++ Executables**

Use the templates/executable file, or the templates/executable_host file.

This template has a couple extra options that you usually don't need.  Please delete the ones you don't need, and remove the TODO comments. It  makes the rest of them easier to read, and you can always refer back to  the templates if you need them again later.

By default, on the target these are built into /system/bin, and on  the host, they're built into /host/bin. These can be overridden by  setting LOCAL_MODULE_PATH or LOCAL_MODULE_RELATIVE_PATH. See[Putting  targets elsewhere](https://blog.csdn.net/class_brick/article/details/70859809#moving-targets) for more.

#### **Shared Libraries**

Use the templates/shared_library file, or the templates/shared_library_host file.

Remember that on the target, we use shared libraries, and on the  host, we use static libraries, since executable size isn't as big an  issue, and it simplifies distribution in the SDK.

#### **Static Libraries**

Use the templates/static_library file, or the templates/static_library_host file.

Remember that on the target, we use shared libraries, and on the  host, we use static libraries, since executable size isn't as big an  issue, and it simplifies distribution in the SDK.

#### **Using Custom Tools**

If you have a tool that generates source files for you, it's possible  to have the build system get the dependencies correct for it. Here are a  couple of examples. $@ is the make built-in variable for "the current  target." Thered parts  are the parts you'll need to change.

You need to put this after you have declared LOCAL_PATH and  LOCAL_MODULE, because the $(local-generated-sources-dir) and  $(local-host-generated-sources-dir) macros use these variables to  determine where to put the files.

##### **Example 1**

Here, there is one generated file, called chartables.c, which doesn't  depend on anything. And is built by the tool built to  $(HOST_OUT_EXECUTABLES)/dftables. Note on the second to last line that a  dependency is created on the tool.

intermediates:= $(local-generated-sources-dir)

GEN := $(intermediates)/chartables.c

$(GEN): PRIVATE_CUSTOM_TOOL = $(HOST_OUT_EXECUTABLES)/dftables $@

$(GEN): $(HOST_OUT_EXECUTABLES)/dftables

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

##### **Example 2**

Here as a hypothetical example, we use use cat as if it were to  transform a file. Pretend that it does something useful. Note how we use  a target-specific variable called PRIVATE_INPUT_FILE to store the name  of the input file.

intermediates:= $(local-generated-sources-dir)

GEN := $(intermediates)/file.c

$(GEN): PRIVATE_INPUT_FILE := $(LOCAL_PATH)/input.file

$(GEN): PRIVATE_CUSTOM_TOOL = cat $(PRIVATE_INPUT_FILE) > $@

$(GEN): $(LOCAL_PATH)/file.c

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

##### **Example 3**

If you have several files that are all similar in name, and use the  same tool, you can combine them. (here the *.lut.h files are the  generated ones, and the *.cpp files are the input files)

intermediates:= $(local-generated-sources-dir)

GEN := $(addprefix $(intermediates)/kjs/, \

​            array_object.lut.h \

​            bool_object.lut.h \

​        )

$(GEN): PRIVATE_CUSTOM_TOOL = perl libs/WebKitLib/WebKit/JavaScriptCore/kjs/create_hash_table $< -i > $@

$(GEN): $(intermediates)/%.lut.h : $(LOCAL_PATH)/%.cpp

$(transform-generated-source)

LOCAL_GENERATED_SOURCES += $(GEN)

### **Platform specific conditionals**

Sometimes you need to set flags specifically for different platforms.  Here is a list of which values the different build-system defined  variables will be set to and some examples.

For a device build, TARGET_OS is linux (we're using linux!), and TARGET_ARCH is arm.

For a simulator build, TARGET_OS and TARGET_ARCH are set to the same  as HOST_OS and HOST_ARCH are on your platform. TARGET_PRODUCT is the  name of the target hardware/product you are building for. The value  sim is used for the simulator. We haven't thought  through the full extent of customization that will happen here, but  likely there will be additional UI configurations specified here as  well.

| **HOST_OS**  linux  darwin  (cygwin)   | **HOST_ARCH**  x86        | **HOST_BUILD_TYPE**  release  debug   |                                        |
| -------------------------------------- | ------------------------- | ------------------------------------- | -------------------------------------- |
| **TARGET_OS**  linux  darwin  (cygwin) | **TARGET_ARCH**  arm  x86 | **TARGET_BUILD_TYPE**  release  debug | **TARGET_PRODUCT**  sim  dream  sooner |

#### **Some Examples**

ifeq ($(TARGET_BUILD_TYPE),release)

LOCAL_CFLAGS += -DNDEBUG=1

endif

 

\# from libutils

ifeq ($(TARGET_OS),linux)

\# Use the futex based mutex and condition variable

\# implementation from android-arm because it's shared mem safe

LOCAL_SRC_FILES += futex_synchro.c

LOCAL_LDLIBS += -lrt -ldl

endif

 

### **Putting modules elsewhere**

If you have modules that normally go somewhere, and you need to have them build somewhere else, read this.

If you have modules that need to go in a subdirectory of their normal  location, for example HAL modules that need to go in /system/lib/hw or  /vendor/lib/hw, set LOCAL_MODULE_RELATIVE_PATH in your Android.mk, for  example:

LOCAL_MODULE_RELATIVE_PATH := hw

If you have modules that need to go in an entirely different  location, for example the root filesystem instead of in /system, add  these lines to your Android.mk:

LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)

LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_SBIN_UNSTRIPPED)

For executables and libraries, you need to specify a  LOCAL_UNSTRIPPED_PATH location if you specified a LOCAL_MODULE_PATH,  because on target builds, we keep the unstripped executables so GDB can  find the symbols. LOCAL_UNSTRIPPED_PATH is not necessary if  you only specified LOCAL_MODULE_RELATIVE_PATH.

Look in config/envsetup.make for all of the variables defining places to build things.

FYI: If you're installing an executable to /sbin, you probably also  want to set LOCAL_FORCE_STATIC_EXCUTABLE := true in your Android.mk,  which will force the linker to only accept static libraries.

### **Android.mk variables**

These are the variables that you'll commonly see in Android.mk files, listed alphabetically.

But first, a note on variable naming: 

· **LOCAL_** - These variables are set per-module. They  are cleared by the include $(CLEAR_VARS) line, so you can rely on them  being empty after including that file. Most of the variables you'll use  in most modules are LOCAL_ variables.

· **PRIVATE_** - These variables are  make-target-specific variables. That means they're only usable within  the commands for that module. It also means that they're unlikely to  change behind your back from modules that are included after yours.  This [link to the make documentation](https://blog.csdn.net/class_brick/article/details/70859809#Target_002dspecific) describes more about target-specific variables. Please note that there are a couple of these laying around the tree  that aren't prefixed with PRIVATE_. It is safe, and they will be fixed as they are discovered. Sorry for the confusion.

· **INTERNAL_** - These variables are critical to  functioning of the build system, so you shouldn't create variables named  like this, and you probably shouldn't be messing with these variables  in your makefiles.

· **HOST_** and **TARGET_** - These contain  the directories and definitions that are specific to either the host or  the target builds. Do not set variables that start with HOST_ or  TARGET_ in your makefiles.

· **BUILD_** and **CLEAR_VARS** - These contain the names of well-defined template makefiles to include. Some examples are CLEAR_VARS and BUILD_HOST_PACKAGE.

· Any other name is fair-game for you to use in your Android.mk.  However, remember that this is a non-recursive build system, so it is  possible that your variable will be changed by another Android.mk  included later, and be different when the commands for  your rule / module are executed.

#### **LOCAL_ASSET_FILES**

In Android.mk files that include $(BUILD_PACKAGE) set this to the set of files you want built into your app. Usually:

LOCAL_ASSET_FILES += $(call find-subdir-assets)

This will probably change when we switch to ant for the apps' build system.

#### **LOCAL_CC**

If you want to use a different C compiler for this module, set  LOCAL_CC to the path to the compiler. If LOCAL_CC is blank, the  appropriate default compiler is used.

#### **LOCAL_CXX**

If you want to use a different C++ compiler for this module, set  LOCAL_CXX to the path to the compiler. If LOCAL_CXX is blank, the  appropriate default compiler is used.

#### **LOCAL_CFLAGS**

If you have additional flags to pass into the C or C++ compiler, add them here. For example:

LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1

#### **LOCAL_CPPFLAGS**

If you have additional flags to pass into *only* the C++ compiler, add them here. For example:

LOCAL_CPPFLAGS += -ffriend-injection

LOCAL_CPPFLAGS is guaranteed to be after LOCAL_CFLAGS on the compile  line, so you can use it to override flags listed in LOCAL_CFLAGS.

#### **LOCAL_CPP_EXTENSION**

If your C++ files end in something other than ".cpp", you can specify the custom extension here. For example:

LOCAL_CPP_EXTENSION := .cc

Note that all C++ files for a given module must have the same  extension; it is not currently possible to mix different extensions.

#### **LOCAL_NO_DEFAULT_COMPILER_FLAGS**

Normally, the compile line for C and C++ files includes global  include paths and global cflags. If LOCAL_NO_DEFAULT_COMPILER_FLAGS is  non-empty, none of the default includes or flags will be used when  compiling C and C++ files in this module. LOCAL_C_INCLUDES,  LOCAL_CFLAGS, and LOCAL_CPPFLAGS will still be used in this case, as  will any DEBUG_CFLAGS that are defined for the module.

#### **LOCAL_COPY_HEADERS**

This will be going away.

The set of files to copy to the install include tree. You must also supply LOCAL_COPY_HEADERS_TO.

This is going away because copying headers messes up the error  messages, and may lead to people editing those headers instead of the  correct ones. It also makes it easier to do bad layering in the system,  which we want to avoid. We also aren't doing a C/C++  SDK, so there is no ultimate requirement to copy any headers.

#### **LOCAL_COPY_HEADERS_TO**

This will be going away.

The directory within "include" to copy the headers listed in LOCAL_COPY_HEADERS to.

This is going away because copying headers messes up the error  messages, and may lead to people editing those headers instead of the  correct ones. It also makes it easier to do bad layering in the system,  which we want to avoid. We also aren't doing a C/C++  SDK, so there is no ultimate requirement to copy any headers.

#### **LOCAL_C_INCLUDES**

Additional directories to instruct the C/C++ compilers to look for  header files in. These paths are rooted at the top of the tree. Use  LOCAL_PATH if you have subdirectories of your own that you want in the  include paths. For example:

LOCAL_C_INCLUDES += extlibs/zlib-1.2.3
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/src 

You should not add subdirectories of include to LOCAL_C_INCLUDES,  instead you should reference those files in the #include statement with  their subdirectories. For example:

\#include <utils/KeyedVector.h>
 not ~~#include <KeyedVector.h>~~

There are some components that are doing this wrong, and should be cleaned up.

#### **LOCAL_MODULE_TAGS**

Set LOCAL_MODULE_TAGS to any number of whitespace-separated tags. If  the tag list is empty or contains droid, the module will get installed  as part of a make droid. Otherwise, it will only get installed by  running make <your-module> or with the make all pseudotarget.

#### **LOCAL_REQUIRED_MODULES**

Set LOCAL_REQUIRED_MODULES to any number of whitespace-separated  module names, like "libblah" or "Email". If this module is installed,  all of the modules that it requires will be installed as well. This can  be used to, e.g., ensure that necessary shared  libraries or providers are installed when a given app is installed. 

#### **LOCAL_FORCE_STATIC_EXECUTABLE**

If your executable should be linked statically, set  LOCAL_FORCE_STATIC_EXECUTABLE:=true. There is a very short list of  libraries that we have in static form (currently only libc). This is  really only used for executables in /sbin on the root filesystem.

#### **LOCAL_GENERATED_SOURCES**

Files that you add to LOCAL_GENERATED_SOURCES will be automatically  generated and then linked in when your module is built. See the[Custom Tools](https://blog.csdn.net/class_brick/article/details/70859809#custom-tools) template makefile  for an example.

#### **LOCAL_JAVACFLAGS**

If you have additional flags to pass into the javac compiler, add them here. For example:

LOCAL_JAVACFLAGS += -Xlint:deprecation

#### **LOCAL_JAVA_LIBRARIES**

When linking Java apps and libraries, LOCAL_JAVA_LIBRARIES specifies  which sets of java classes to include. Currently there are two of these:  core and framework. In most cases, it will look like this:

LOCAL_JAVA_LIBRARIES := core framework

Note that setting LOCAL_JAVA_LIBRARIES is not necessary (and is not  allowed) when building an APK with "include $(BUILD_PACKAGE)". The  appropriate libraries will be included automatically.

#### **LOCAL_LDFLAGS**

You can pass additional flags to the linker by setting LOCAL_LDFLAGS.  Keep in mind that the order of parameters is very important to ld, so  test whatever you do on all platforms.

#### **LOCAL_LDLIBS**

LOCAL_LDLIBS allows you to specify additional libraries that are not  part of the build for your executable or library. Specify the libraries  you want in -lxxx format; they're passed directly to the link line.  However, keep in mind that there will be no dependency  generated for these libraries. It's most useful in simulator builds  where you want to use a library preinstalled on the host. The linker  (ld) is a particularly fussy beast, so it's sometimes necessary to pass  other flags here if you're doing something sneaky.  Some examples:

LOCAL_LDLIBS += -lcurses -lpthread
 LOCAL_LDLIBS += -Wl,-z,origin 

#### **LOCAL_NO_MANIFEST**

If your package doesn't have a manifest (AndroidManifest.xml), then  set LOCAL_NO_MANIFEST:=true. The common resources package does this.

#### **LOCAL_PACKAGE_NAME**

LOCAL_PACKAGE_NAME is the name of an app. For example, Dialer,  Contacts, etc. This will probably change or go away when we switch to an  ant-based build system for the apps.

#### **LOCAL_PATH**

The directory your Android.mk file is in. You can set it by putting the following as the first line in your Android.mk:

LOCAL_PATH := $(my-dir)

The my-dir macro uses the [ MAKEFILE_LIST](https://blog.csdn.net/class_brick/article/details/70859809#MAKEFILE_005fLIST-Variable) variable, so  you must call it before you include any other makefiles. Also, consider  that any subdirectories you inlcude might reset LOCAL_PATH, so do your  own stuff before you include them. This also  means that if you try to write several include lines that reference  LOCAL_PATH, it won't work, because those included makefiles might reset  LOCAL_PATH.

#### **LOCAL_POST_PROCESS_COMMAND**

For host executables, you can specify a command to run on the module  after it's been linked. You might have to go through some contortions to  get variables right because of early or late variable evaluation:

module := $(HOST_OUT_EXECUTABLES)/$(LOCAL_MODULE)
 LOCAL_POST_PROCESS_COMMAND := /Developer/Tools/Rez -d __DARWIN__ -t APPL\
        -d __WXMAC__ -o $(module) Carbon.r 

#### **LOCAL_PREBUILT_EXECUTABLES**

When including $(BUILD_PREBUILT) or $(BUILD_HOST_PREBUILT), set these  to executables that you want copied. They're located automatically into  the right bin directory.

#### **LOCAL_PREBUILT_LIBS**

When including $(BUILD_PREBUILT) or $(BUILD_HOST_PREBUILT), set these  to libraries that you want copied. They're located automatically into  the right lib directory.

#### **LOCAL_SHARED_LIBRARIES**

These are the libraries you directly link against. You don't need to  pass transitively included libraries. Specify the name without the  suffix:

LOCAL_SHARED_LIBRARIES := \
     libutils \
     libui \
     libaudio \
     libexpat \
     libsgl 

#### **LOCAL_SRC_FILES**

The build system looks at LOCAL_SRC_FILES to know what source files  to compile -- .cpp .c .y .l .java. For lex and yacc files, it knows how  to correctly do the intermediate .h and .c/.cpp files automatically. If  the files are in a subdirectory of the one  containing the Android.mk, prefix them with the directory name:

LOCAL_SRC_FILES := \
     file1.cpp \
     dir/file2.cpp 

#### **LOCAL_STATIC_LIBRARIES**

These are the static libraries that you want to include in your  module. Mostly, we use shared libraries, but there are a couple of  places, like executables in sbin and host executables where we use  static libraries instead.

LOCAL_STATIC_LIBRARIES := \
     libutils \
     libtinyxml 

#### **LOCAL_MODULE**

LOCAL_MODULE is the name of what's supposed to be generated from your  Android.mk. For exmample, for libkjs, the LOCAL_MODULE is "libkjs" (the  build system adds the appropriate suffix -- .so .dylib .dll). For app  modules, use LOCAL_PACKAGE_NAME instead of  LOCAL_MODULE. We're planning on switching to ant for the apps, so this  might become moot.

#### **LOCAL_MODULE_PATH**

Instructs the build system to put the module somewhere other than  what's normal for its type. If you override this, make sure you also set  LOCAL_UNSTRIPPED_PATH if it's an executable or a shared library so the  unstripped binary has somewhere to go. An error  will occur if you forget to.

See [Putting modules elsewhere](https://blog.csdn.net/class_brick/article/details/70859809#moving-modules) for more.

#### **LOCAL_MODULE_RELATIVE_PATH**

Instructs the build system to put the module in a subdirectory under  the directory that is normal for its type. If you set this you do not  need to set LOCAL_UNSTRIPPED_PATH, the unstripped binaries will also use  the relative path.

See [Putting modules elsewhere](https://blog.csdn.net/class_brick/article/details/70859809#moving-modules) for more.

#### **LOCAL_UNSTRIPPED_PATH**

Instructs the build system to put the unstripped version of the  module somewhere other than what's normal for its type. Usually, you  override this because you overrode LOCAL_MODULE_PATH for an executable  or a shared library. If you overrode LOCAL_MODULE_PATH,  but not LOCAL_UNSTRIPPED_PATH, an error will occur.

See [Putting modules elsewhere](https://blog.csdn.net/class_brick/article/details/70859809#moving-modules) for more.

#### **LOCAL_WHOLE_STATIC_LIBRARIES**

These are the static libraries that you want to include in your  module without allowing the linker to remove dead code from them. This  is mostly useful if you want to add a static library to a shared library  and have the static library's content exposed  from the shared library. 

LOCAL_WHOLE_STATIC_LIBRARIES := \
     libsqlite3_android

#### **LOCAL_YACCFLAGS**

Any flags to pass to invocations of yacc for your module. A known  limitation here is that the flags will be the same for all invocations  of YACC for your module. This can be fixed. If you ever need it to be,  just ask.

LOCAL_YACCFLAGS := -p kjsyy

## **Implementation Details**

You should never have to touch anything in the config directory  unless you're adding a new platform, new tools, or adding new features  to the build system. In general, please consult with the build system  owner(s) ([android-build-team](mailto:android-build-team))  before you go mucking around in here. That said, here are some notes on what's going on under the hood.

### **Environment Setup / buildspec.mk Versioning**

In order to make easier for people when the build system changes,  when it is necessary to make changes to buildspec.mk or to rerun the  environment setup scripts, they contain a version number in the variable  BUILD_ENV_SEQUENCE_NUMBER. If this variable does  not match what the build system expects, it fails printing an error  message explaining what happened. If you make a change that requires an  update, you need to update two places so this message will be printed.

· In config/envsetup.make, increment the CORRECT_BUILD_ENV_SEQUENCE_NUMBER definition.

· In buildspec.mk.default, update the BUILD_ENV_SEQUENCE_DUMBER definition to match the one in config/envsetup.make

The scripts automatically get the value from the build system, so they will trigger the warning as well.

### **Additional makefile variables**

You probably shouldn't use these variables. Please consult [ android-build-team](mailto:android-build-team) before using them. These are mostly there for workarounds for other issues, or things that aren't completely done right.

#### **LOCAL_ADDITIONAL_DEPENDENCIES**

If your module needs to depend on anything else that isn't actually  built in to it, you can add those make targets to  LOCAL_ADDITIONAL_DEPENDENCIES. Usually this is a workaround for some  other dependency that isn't created automatically.

#### **LOCAL_BUILT_MODULE**

When a module is built, the module is created in an intermediate  directory then copied to its final location. LOCAL_BUILT_MODULE is the  full path to the intermediate file. See LOCAL_INSTALLED_MODULE for the  path to the final installed location of the module.

#### **LOCAL_HOST**

Set by the host_xxx.make includes to tell base_rules.make and the  other includes that we're building for the host. Kenneth did this as  part of openbinder, and I would like to clean it up so the rules,  includes and definitions aren't duplicated for host and  target.

#### **LOCAL_INSTALLED_MODULE**

The fully qualified path name of the final location of the module.  See LOCAL_BUILT_MODULE for the location of the intermediate file that  the make rules should actually be constructing.

#### **LOCAL_REPLACE_VARS**

Used in some stuff remaining from the openbinder for building scripts with particular values set,

#### **LOCAL_SCRIPTS**

Used in some stuff remaining from the openbinder build system that we might find handy some day.

#### **LOCAL_MODULE_CLASS**

Which kind of module this is. This variable is used to construct  other variable names used to locate the modules. See base_rules.make and  envsetup.make.

#### **LOCAL_MODULE_NAME**

Set to the leaf name of the LOCAL_BUILT_MODULE. I'm not sure, but it  looks like it's just used in the WHO_AM_I variable to identify in the  pretty printing what's being built.

#### **LOCAL_MODULE_SUFFIX**

The suffix that will be appended to LOCAL_MODULE to form LOCAL_MODULE_NAME. For example, .so, .a, .dylib.

#### **LOCAL_STRIP_MODULE**

Calculated in base_rules.make to determine if this module should  actually be stripped or not, based on whether LOCAL_STRIPPABLE_MODULE is  set, and whether the combo is configured to ever strip modules. With  Iliyan's stripping tool, this might change.

#### **LOCAL_STRIPPABLE_MODULE**

Set by the include makefiles if that type of module is strippable. Executables and shared libraries are.

#### **LOCAL_SYSTEM_SHARED_LIBRARIES**

Used while building the base libraries: libc, libm, libdl. Usually it  should be set to "none," as it is in $(CLEAR_VARS). When building these  libraries, it's set to the ones they link against. For example, libc,  libstdc++ and libdl don't link against anything,  and libm links against libc. Normally, when the value is none, these  libraries are automatically linked in to executables and libraries, so  you don't need to specify them manually.