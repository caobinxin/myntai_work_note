00.框架

# 1. 资料准备

参考url: https://blog.csdn.net/helloworld717/article/details/89441132

参考url:http://emb.hqyj.com/Column/9794.html (华清一个ADC驱动编写实例)

# 2. 框架

## 2.1 概述

- iio 是专用于模数转换器（ADC）和数模转换器（DAC）的内核子系统。

- 加速度计，陀螺仪，电流/电压测量芯片，光传感器，压力传感器等都属于IIO系列器件。



IIO模型基于设备和通道架构：

```shell
1. 设备代表芯片本身。它是层次结构的顶级。
  
2.通道代表设备的单个采集线。设备可以具有一个或多个通道。例如，加速度计是具有 三个通道的装置，每个通道对应一个轴（X，Y和Z）。
```



IIO芯片是物理和硬件传感器/转换器。它作为字符设备（当支持触发缓冲时）暴露给用户空间，以及包含一组文件的sysfs目录条目，其中一些文件代表通道。单个通道用单个sysfs文件条目表示。

下面是从用户空间与IIO驱动程序交互的两种方式：

    /sys/bus/iio/iio:deviceX/:表示传感器及其通道
    /dev/iio:deviceX: 表示导出设备事件和数据缓冲区的字符设备
## 2.2 框架架构和布局

驱动程序使用IIO核心公开的一组工具和API来管理硬件并向IIO核心报告处理。 然后，IIO子系统通过sysfs接口和字符设备将整个底层机制抽象到用户空间，用户可以在其上执行系统调用。

IIO API分布在多个头文件中：

```c
#include <linux/iio/iio.h>    /* mandatory */
#include <linux/iio/sysfs.h>  /* mandatory since sysfs is used */
#include <linux/iio/events.h> /* For advanced users, to manage iio events */
#include <linux/iio/buffer.h> /* mandatory to use triggered buffers */
#include <linux/iio/trigger.h>/* Only if you implement trigger in your driver (rarely used)*/

```

### 2.2.1 iio数据结构

IIO设备在内核中表示为struct iio_dev结构体的一个实例，并由struct iio_info结构体描述。 所有重要的IIO结构都在include/linux/iio/iio.h中定义。

#### 2.2.1.1 iio_dev

该结构代表IIO设备，描述设备和驱动程序。 它告诉我们：
- 设备上有多少个通道？
- 设备可以在哪些模式下运行：单次，触发缓冲？
- 这个驱动程序可以使用哪些hooks钩子？
```c
struct iio_dev {
   [...]
   int modes;
   int currentmode;
   struct device dev;
   struct iio_buffer *buffer;
   int scan_bytes;
   const unsigned long *available_scan_masks;
   const unsigned long *active_scan_mask;
   bool scan_timestamp;
   struct iio_trigger *trig;
   struct iio_poll_func *pollfunc;
   struct iio_chan_spec const *channels;
   int num_channels;
   const char *name;
   const struct iio_info *info;
   const struct iio_buffer_setup_ops *setup_ops;
   struct cdev chrdev;

};

```

1. modes: 这表示设备支持的不同模式。 支持的模式有：

	1.INDIO_DIRECT_MODE表示设备提供的sysfs接口。
	2.INDIO_BUFFER_TRIGGERED表示设备支持硬件触发器。使用iio_triggered_buffer_setup（）函数设置触发缓冲区时，此模式会自动添加到设备中。
	3.INDIO_BUFFER_HARDWARE表示设备具有硬件缓冲区。
	4.INDIO_ALL_BUFFER_MODES是上述两者的联合。

2. currentmode: 这表示设备实际使用的模式

3. dev: 这表示IIO设备所依赖的struct设备（根据Linux设备型号）。

4. buffer: 这是您的数据缓冲区，在使用触发缓冲区模式时会推送到用户空间。

	使用iio_triggered_buffer_setup函数启用触发缓冲区支持时，它会自动分配并与您的设备关联。

5. scan_bytes: 这是捕获并馈送到缓冲区的字节数。 

	当从用户空间使用触发缓冲区时，缓冲区应至少为indio->scan_bytes字节大。

6. available_scan_masks: 这是允许的位掩码的可选数组。

使用触发缓冲器时，可以启用通道捕获并将其馈入IIO缓冲区。 如果您不想允许某些通道启用，则应仅使用允许的通道填充此数组。 以下是为加速度计（带有X，Y和Z通道）提供扫描掩码的示例：

```c
/*
 * Bitmasks 0x7 (0b111) and 0 (0b000) are allowed.
 * It means one can enable none or all of them.
 * one can't for example enable only channel X and Y
 */

static const unsigned long my_scan_masks[] = {0x7, 0};
indio_dev->available_scan_masks = my_scan_masks;

```

7. active_scan_mask: 这是启用通道的位掩码。 只有来自这些通道的数据能被推入缓冲区。例如，对于8通道ADC转换器，如果只启用第一个（0），第三个（2）和最后一个（7）通道，则位掩码将为0b10000101（0x85）。active_scan_mask将设置为0x85。然后，驱动程序可以使用for_each_set_bit宏遍历每个设置位，根据通道获取数据，并填充缓冲区。
8. scan_timestamp: 这告诉我们是否将捕获时间戳推入缓冲区。 如果为true，则将时间戳作为缓冲区的最后一个元素。时间戳大8字节（64位）。
9. trig: 这是当前设备触发器（支持缓冲模式时）。
10. pollfunc:这是在接收的触发器上运行的函数。
11. channels: 这表示通道规范结构，用于描述设备具有的每个通道
12. num_channels: 这表示通道中指定的通道数。
13. name: 这表示设备名称
14. info: 来自驱动程序的回调和持续信息
15. setup_ops: 启用/禁用缓冲区之前和之后调用的回调函数集。 这个结构在include / linux / iio / iio.h中定义，setup_ops: 如果未指定，则IIO内核使用drivers / iio / buffer /industrialio-triggered-buffer.c中定义的缺省 iio_triggered_buffer_setup_ops。

```c
/**
 * struct iio_buffer_setup_ops - buffer setup related callbacks
 * @preenable:      [DRIVER] function to run prior to marking buffer enabled
 * @postenable:     [DRIVER] function to run after marking buffer enabled
 * @predisable:     [DRIVER] function to run prior to marking buffer
 *          disabled
 * @postdisable:    [DRIVER] function to run after marking buffer disabled
 * @validate_scan_mask: [DRIVER] function callback to check whether a given
 *          scan mask is valid for the device.
 */
struct iio_buffer_setup_ops {                                                                                                                                                                                      
    int (*preenable)(struct iio_dev *);
    int (*postenable)(struct iio_dev *);
    int (*predisable)(struct iio_dev *);
    int (*postdisable)(struct iio_dev *);
    bool (*validate_scan_mask)(struct iio_dev *indio_dev,
                   const unsigned long *scan_mask);
};

```

```c
// 系统默认的
static const struct iio_buffer_setup_ops iio_triggered_buffer_setup_ops = {                                                                                                                                        
    .postenable = &iio_triggered_buffer_postenable,
    .predisable = &iio_triggered_buffer_predisable,
};
```



```c
// industrialio-triggered-buffer.c
int iio_triggered_buffer_setup(struct iio_dev *indio_dev,
    irqreturn_t (*h)(int irq, void *p),
    irqreturn_t (*thread)(int irq, void *p),
    const struct iio_buffer_setup_ops *setup_ops)
{
    struct iio_buffer *buffer;
    int ret;

    buffer = iio_kfifo_allocate();
    if (!buffer) {
        ret = -ENOMEM;
        goto error_ret;
    }   

    iio_device_attach_buffer(indio_dev, buffer);

    indio_dev->pollfunc = iio_alloc_pollfunc(h,
                         thread,
                         IRQF_ONESHOT,
                         indio_dev,
                         "%s_consumer%d",
                         indio_dev->name,
                         indio_dev->id);
    if (indio_dev->pollfunc == NULL) {
        ret = -ENOMEM;
        goto error_kfifo_free;
    }   

    /* Ring buffer functions - here trigger setup related */
    if (setup_ops)
        indio_dev->setup_ops = setup_ops; //使用我们自己的
    else
        indio_dev->setup_ops = &iio_triggered_buffer_setup_ops;// 在这里会被赋值

    /* Flag that polled ring buffering is possible */
    indio_dev->modes |= INDIO_BUFFER_TRIGGERED;

    return 0;

error_kfifo_free:
    iio_kfifo_free(indio_dev->buffer);
error_ret:
    return ret;
}                                                                                                                                                                                                                  
EXPORT_SYMBOL(iio_triggered_buffer_setup);
```

16. chrdev: 这是由IIO核心创建的关联字符设备。

##### iio_device_alloc()

```c
struct iio_dev * iio_device_alloc(int sizeof_priv) 
///struct iio_dev *devm_iio_device_alloc(struct device *dev, int sizeof_priv)
/* Resource-managed iio_device_alloc()*/
/*Managed iio_device_alloc. iio_dev allocated with this function is automatically freed on driver detach.
If an iio_dev allocated with this function needs to be freed separately, devm_iio_device_free() must be used. */

```

dev是为其分配iio_dev的设备，sizeof_priv是用于为任何私有结构分配的内存空间。 这样，传递每个设备（私有）数据结构非常简单。 如果分配失败，该函数返回NULL：

```c
struct iio_dev *indio_dev;
struct my_private_data *data;
indio_dev = iio_device_alloc(sizeof(*data));
if (!indio_dev)
          return -ENOMEM;
/*data is given the address of reserved momory for private data */
data = iio_priv(indio_dev);

```



##### iio_device_register()

在分配IIO设备存储器之后，下一步是填充不同的字段。 完成后，必须使用iio_device_register函数向IIO子系统注册设备：

在执行此功能后，设备将准备好接受来自用户空间的请求。

```c
int iio_device_register(struct iio_dev *indio_dev)
       //devm_iio_device_register(dev, indio_dev)
/* Resource-managed iio_device_register() */

```

##### iio_device_unregister()

```c
void iio_device_unregister(struct iio_dev *indio_dev)
// void devm_iio_device_unregister(struct device * dev, struct iio_dev * indio_dev)
　　一旦取消注册，iio_device_alloc分配的内存可以用iio_device_free释放：

void iio_device_free(struct iio_dev *iio_dev)
// void devm_iio_device_free(struct device * dev, struct iio_dev * iio_dev)

```

##### iio_priv()

给定IIO设备作为参数，可以通过以下方式检索私有数据：

```c
struct my_private_data *the_data = iio_priv(indio_dev);
```

#### 2.2.1.2 iio_info

```c
struct iio_info {
           struct module *driver_module;
            const struct attribute_group *attrs;
            int (*read_raw)(struct iio_dev *indio_dev,
               struct iio_chan_spec const *chan,
               int *val, int *val2, long mask);

            int (*write_raw)(struct iio_dev *indio_dev,

                struct iio_chan_spec const *chan,

                int val, int val2, long mask);
             [...]

};
```

1. driver_module: 这是用于确保chrdev正确拥有的模块结构，通常设置为THIS_MODULE。
2. attrs: 这表示设备属性。
3. read_raw: 这是用户读取设备sysfs文件属性时的回调运行。 mask参数是一个位掩码，它允许我们知道请求了哪种类型的值。channel参数让我们知道相关的通道。 它可以是采样频率，用于将原始值转换为可用值的比例，或原始值本身。

4. write_raw: 这是用于将值写入设备的回调。 例如，可以使用它来设置采样频率。

以下代码显示了如何设置struct iio_info结构：

```c
static const struct iio_info iio_dummy_info = {
    .driver_module = THIS_MODULE,
    .read_raw = &iio_dummy_read_raw,
    .write_raw = &iio_dummy_write_raw,
[...]

/*
 * Provide device type specific interface functions and
 * constant data. 提供设备类型特定的接口功能和常量数据。
 */
indio_dev->info = &iio_dummy_info;

```

#### 2.2.1.3 iio_chan_spec

通道代表单条采集线。 例如加速度计具有3个通道（X，Y，Z），因为每个轴代表单个采集线。 struct iio_chan_spec是表示和描述内核中单个通道的结构：

```c
struct iio_chan_spec {
    enum iio_chan_type  type;
    int         channel;
    int         channel2;                                                                                                                                                                                          
    unsigned long       address;
    int         scan_index;
    struct {
        char    sign;
        u8  realbits;
        u8  storagebits;
        u8  shift;
        u8  repeat;
        enum iio_endian endianness;
    } scan_type;
    long            info_mask_separate;
    long            info_mask_separate_available;
    long            info_mask_shared_by_type;
    long            info_mask_shared_by_type_available;
    long            info_mask_shared_by_dir;
    long            info_mask_shared_by_dir_available;
    long            info_mask_shared_by_all;
    long            info_mask_shared_by_all_available;
    const struct iio_event_spec *event_spec;
    unsigned int        num_event_specs;
    const struct iio_chan_spec_ext_info *ext_info;
    const char      *extend_name;
    const char      *datasheet_name;
    unsigned        modified:1;
    unsigned        indexed:1;
    unsigned        output:1;
    unsigned        differential:1;
};
```

1. type: 这指定了通道的测量类型。 在电压测量的情况下，它应该是IIO_VOLTAGE。 对于光传感器，它是IIO_LIGHT。对于加速度计，使用IIO_ACCEL。 所有可用类型都在include / uapi / linux / iio /types.h中定义，如enum iio_chan_type。 要为给定转换器编写驱动程序，请查看该文件以查看每个通道所属的类型。

```c
enum iio_chan_type {                 
    IIO_VOLTAGE,
    IIO_CURRENT,
    IIO_POWER,
    IIO_ACCEL,
    IIO_ANGL_VEL,
    IIO_MAGN,
    IIO_LIGHT,
    IIO_INTENSITY,
    IIO_PROXIMITY,
    IIO_TEMP,
    IIO_INCLI,
    IIO_ROT,
    IIO_ANGL,
    IIO_TIMESTAMP,
    IIO_CAPACITANCE,
    IIO_ALTVOLTAGE,
    IIO_CCT,
    IIO_PRESSURE,
    IIO_HUMIDITYRELATIVE,
    IIO_ACTIVITY,
    IIO_STEPS,
    IIO_ENERGY,
    IIO_DISTANCE,
    IIO_VELOCITY,
    IIO_CONCENTRATION,
    IIO_RESISTANCE,
    IIO_PH,
    IIO_UVINDEX,
    IIO_ELECTRICALCONDUCTIVITY,
    IIO_COUNT,
    IIO_INDEX,
    IIO_GRAVITY,
    IIO_POSITIONRELATIVE,
    IIO_PHASE,
};
```

2. channel: 这指定.indexed设置为1时的通道索引。
3. channel2: 这指定.modified设置为1时的通道修饰。
4. modified: 这指定是否将修饰符应用于此通道属性名称。 在这种情况下，修饰符设置在.channel2中。（例如，IIO_MOD_X，IIO_MOD_Y，IIO_MOD_Z是关于xyz轴的轴向传感器的修改器）。可用修饰符列表在内核IIO头中定义为枚举iio_modifier。 修饰符只会破坏sysfs中的通道属性名称，而不是值。

```c
enum iio_modifier {
    IIO_NO_MOD,
    IIO_MOD_X,
    IIO_MOD_Y,
    IIO_MOD_Z,
    IIO_MOD_X_AND_Y,
    IIO_MOD_X_AND_Z,
    IIO_MOD_Y_AND_Z,
    IIO_MOD_X_AND_Y_AND_Z,
    IIO_MOD_X_OR_Y,
    IIO_MOD_X_OR_Z,
    IIO_MOD_Y_OR_Z,
    IIO_MOD_X_OR_Y_OR_Z,
    IIO_MOD_LIGHT_BOTH,
    IIO_MOD_LIGHT_IR,
    IIO_MOD_ROOT_SUM_SQUARED_X_Y,
    IIO_MOD_SUM_SQUARED_X_Y_Z,
    IIO_MOD_LIGHT_CLEAR,
    IIO_MOD_LIGHT_RED,
    IIO_MOD_LIGHT_GREEN,
    IIO_MOD_LIGHT_BLUE,
    IIO_MOD_QUATERNION,
    IIO_MOD_TEMP_AMBIENT,
    IIO_MOD_TEMP_OBJECT,
    IIO_MOD_NORTH_MAGN,
    IIO_MOD_NORTH_TRUE,
    IIO_MOD_NORTH_MAGN_TILT_COMP,
    IIO_MOD_NORTH_TRUE_TILT_COMP,
    IIO_MOD_RUNNING,
    IIO_MOD_JOGGING,
    IIO_MOD_WALKING,
    IIO_MOD_STILL,
    IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z,
    IIO_MOD_I,
    IIO_MOD_Q,
    IIO_MOD_CO2,
    IIO_MOD_VOC,
    IIO_MOD_LIGHT_UV,
    IIO_MOD_LIGHT_DUV,
};
```

5. indexed: 这指定通道属性名称是否具有索引。 如果是，则在.channel字段中指定索引
6. scan_index and scan_type: 当使用缓冲区触发器时，这些字段用于标识缓冲区中的元素。scan_index设置缓冲区内捕获的通道的位置。 具有较低scan_index的通道将放置在具有较高索引的通道之前。将.scan_index设置为-1将阻止通道进行缓冲捕获（scan_elements目录中没有条目）。

7. 暴露给用户空间的通道sysfs属性以位掩码的形式指定。 根据共享信息，可以将属性设置为以下掩码之一：

info_mask_separate 将属性标记为特定于此通

info_mask_shared_by_type 将该属性标记为由相同类型的所有通道共享。 导出的信息由相同类型的所有通道共享。

info_mask_shared_by_dir 将属性标记为由同一方向的所有通道共享。 导出的信息由同一方向的所有通道共享。

info_mask_shared_by_all 将属性标记为所有通道共享，无论其类型或方向如何。 导出的信息由所有渠道共享。
用于枚举这些属性的位掩码都在types.h中定义：

```c
enum iio_chan_info_enum {
    IIO_CHAN_INFO_RAW = 0,
    IIO_CHAN_INFO_PROCESSED,
    IIO_CHAN_INFO_SCALE,
    IIO_CHAN_INFO_OFFSET,
    IIO_CHAN_INFO_CALIBSCALE,
    IIO_CHAN_INFO_CALIBBIAS,
    IIO_CHAN_INFO_PEAK,
    IIO_CHAN_INFO_PEAK_SCALE,
    IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW,
    IIO_CHAN_INFO_AVERAGE_RAW,
    IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY,
    IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY,
    IIO_CHAN_INFO_SAMP_FREQ,
    IIO_CHAN_INFO_FREQUENCY,
    IIO_CHAN_INFO_PHASE,
    IIO_CHAN_INFO_HARDWAREGAIN,
    IIO_CHAN_INFO_HYSTERESIS,
    IIO_CHAN_INFO_INT_TIME,
    IIO_CHAN_INFO_ENABLE,
    IIO_CHAN_INFO_CALIBHEIGHT,
    IIO_CHAN_INFO_CALIBWEIGHT,
    IIO_CHAN_INFO_DEBOUNCE_COUNT,
    IIO_CHAN_INFO_DEBOUNCE_TIME,
    IIO_CHAN_INFO_CALIBEMISSIVITY,
    IIO_CHAN_INFO_OVERSAMPLING_RATIO,
};
```

##### 通道属性的命名约定：

**Channel attribute naming conventions：通道属性命名约定**

属性的名称由IIO核心自动生成，具有以下模式：{direction} _ {type} _ {index} _ {modifier} _ {info_mask}：

###### direction:

direction方向对应于属性方向，

根据drivers / iio / industrialio-core.c中的struct    iio_direction结构：

```c
static const char * const iio_direction[] = {
   [0] = "in",
   [1] = "out", 
}; 
```

###### type:

根据char数组const iio_chan_type_name_spec: drivers/iio/industrialio-core.c +55

```c
static const char * const iio_chan_type_name_spec[] = {
    [IIO_VOLTAGE] = "voltage",
    [IIO_CURRENT] = "current",
    [IIO_POWER] = "power",
    [IIO_ACCEL] = "accel",
    [IIO_ANGL_VEL] = "anglvel",
    [IIO_MAGN] = "magn",
    [IIO_LIGHT] = "illuminance",
    [IIO_INTENSITY] = "intensity",
    [IIO_PROXIMITY] = "proximity",
    [IIO_TEMP] = "temp",
    [IIO_INCLI] = "incli",
    [IIO_ROT] = "rot",
    [IIO_ANGL] = "angl",
    [IIO_TIMESTAMP] = "timestamp",
    [IIO_CAPACITANCE] = "capacitance",
    [IIO_ALTVOLTAGE] = "altvoltage",
    [IIO_CCT] = "cct",
    [IIO_PRESSURE] = "pressure",
    [IIO_HUMIDITYRELATIVE] = "humidityrelative",
    [IIO_ACTIVITY] = "activity",
    [IIO_STEPS] = "steps",
    [IIO_ENERGY] = "energy",
    [IIO_DISTANCE] = "distance",
    [IIO_VELOCITY] = "velocity",
    [IIO_CONCENTRATION] = "concentration",
    [IIO_RESISTANCE] = "resistance",
    [IIO_PH] = "ph",
    [IIO_UVINDEX] = "uvindex",
    [IIO_ELECTRICALCONDUCTIVITY] = "electricalconductivity",
    [IIO_COUNT] = "count",
    [IIO_INDEX] = "index",
    [IIO_GRAVITY]  = "gravity",
    [IIO_POSITIONRELATIVE]  = "positionrelative",
    [IIO_PHASE] = "phase",
};
```

###### index:

index 索引模式取决于是否设置了通道.indexed字段。 如果设置，索引将从.channel字段中获取，以替换{index}模式。

###### modifier:

modifier 模式取决于通道所设置的.modified字段。

如果设置，修饰符将从.channel2字段中获取，{modifier}模式将根据char数组struct iio_modifier_names结构替换：

```c
static const char * const iio_modifier_names[] = {
    [IIO_MOD_X] = "x",
    [IIO_MOD_Y] = "y",
    [IIO_MOD_Z] = "z",
    [IIO_MOD_X_AND_Y] = "x&y",
    [IIO_MOD_X_AND_Z] = "x&z",
    [IIO_MOD_Y_AND_Z] = "y&z",
    [IIO_MOD_X_AND_Y_AND_Z] = "x&y&z",
    [IIO_MOD_X_OR_Y] = "x|y",
    [IIO_MOD_X_OR_Z] = "x|z",
    [IIO_MOD_Y_OR_Z] = "y|z",
    [IIO_MOD_X_OR_Y_OR_Z] = "x|y|z",
    [IIO_MOD_ROOT_SUM_SQUARED_X_Y] = "sqrt(x^2+y^2)",
    [IIO_MOD_SUM_SQUARED_X_Y_Z] = "x^2+y^2+z^2",
    [IIO_MOD_LIGHT_BOTH] = "both",
    [IIO_MOD_LIGHT_IR] = "ir",
    [IIO_MOD_LIGHT_CLEAR] = "clear",
    [IIO_MOD_LIGHT_RED] = "red",
    [IIO_MOD_LIGHT_GREEN] = "green",
    [IIO_MOD_LIGHT_BLUE] = "blue",
    [IIO_MOD_LIGHT_UV] = "uv",
    [IIO_MOD_LIGHT_DUV] = "duv",
    [IIO_MOD_QUATERNION] = "quaternion",
    [IIO_MOD_TEMP_AMBIENT] = "ambient",
    [IIO_MOD_TEMP_OBJECT] = "object",
    [IIO_MOD_NORTH_MAGN] = "from_north_magnetic",
    [IIO_MOD_NORTH_TRUE] = "from_north_true",
    [IIO_MOD_NORTH_MAGN_TILT_COMP] = "from_north_magnetic_tilt_comp",
    [IIO_MOD_NORTH_TRUE_TILT_COMP] = "from_north_true_tilt_comp",
    [IIO_MOD_RUNNING] = "running",
    [IIO_MOD_JOGGING] = "jogging",
    [IIO_MOD_WALKING] = "walking",
    [IIO_MOD_STILL] = "still",
    [IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z] = "sqrt(x^2+y^2+z^2)",
    [IIO_MOD_I] = "i",
    [IIO_MOD_Q] = "q",
    [IIO_MOD_CO2] = "co2",
    [IIO_MOD_VOC] = "voc",
};
```

###### info_mask:

info_mask取决于char数组iio_chan_info_postfix中的通道信息掩码,私有或共享索引值：

```c
/* relies on pairs of these shared then separate */
static const char * const iio_chan_info_postfix[] = {
    [IIO_CHAN_INFO_RAW] = "raw",
    [IIO_CHAN_INFO_PROCESSED] = "input",
    [IIO_CHAN_INFO_SCALE] = "scale",
    [IIO_CHAN_INFO_OFFSET] = "offset",
    [IIO_CHAN_INFO_CALIBSCALE] = "calibscale",
    [IIO_CHAN_INFO_CALIBBIAS] = "calibbias",
    [IIO_CHAN_INFO_PEAK] = "peak_raw",
    [IIO_CHAN_INFO_PEAK_SCALE] = "peak_scale",
    [IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW] = "quadrature_correction_raw",
    [IIO_CHAN_INFO_AVERAGE_RAW] = "mean_raw",
    [IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY]
    = "filter_low_pass_3db_frequency",
    [IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY]
    = "filter_high_pass_3db_frequency",
    [IIO_CHAN_INFO_SAMP_FREQ] = "sampling_frequency",
    [IIO_CHAN_INFO_FREQUENCY] = "frequency",
    [IIO_CHAN_INFO_PHASE] = "phase",
    [IIO_CHAN_INFO_HARDWAREGAIN] = "hardwaregain",
    [IIO_CHAN_INFO_HYSTERESIS] = "hysteresis",
    [IIO_CHAN_INFO_INT_TIME] = "integration_time",
    [IIO_CHAN_INFO_ENABLE] = "en",
    [IIO_CHAN_INFO_CALIBHEIGHT] = "calibheight",
    [IIO_CHAN_INFO_CALIBWEIGHT] = "calibweight",
    [IIO_CHAN_INFO_DEBOUNCE_COUNT] = "debounce_count",
    [IIO_CHAN_INFO_DEBOUNCE_TIME] = "debounce_time",
    [IIO_CHAN_INFO_CALIBEMISSIVITY] = "calibemissivity",
    [IIO_CHAN_INFO_OVERSAMPLING_RATIO] = "oversampling_ratio",
};
```

##### 通道区分：

**Distinguishing channels通道区分**

当每种通道类型有多个数据通道时，您可能会遇到麻烦。 困境将是：如何识别它们。 有两种解决方案：索引和修饰符。

###### 范例：in_voltage_raw 

使用索引：给定具有一个通道线的ADC器件，不需要索引。通道定义如下：

```c
static const struct iio_chan_spec adc_channels[] = {
                {
                        .type = IIO_VOLTAGE,
                        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),

               },
}
```

由前面描述的通道产生的属性名称将是in_voltage_raw。

/sys/bus/iio/iio:deviceX/in_voltage_raw

###### 范例：in_voltage0_raw

现在让我们看一下有4个甚至8个通道的转换器。 我们如何识别它们？ 解决方案是使用索引。 将.indexed字段设置为1将使用.channel值替换{index}模式来替换通道属性名称：

```c
  static const struct iio_chan_spec adc_channels[] = {
        {
                .type = IIO_VOLTAGE,
                .indexed = 1,
                .channel = 0,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),

        },

        {
                .type = IIO_VOLTAGE,
                .indexed = 1,
                .channel = 1,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
        },
        {
                .type = IIO_VOLTAGE,
                .indexed = 1,
                .channel = 2,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
        },
        {
                .type = IIO_VOLTAGE,
                .indexed = 1,
                .channel = 3,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
        },
}
```

生成的通道属性为：

```shell
 /sys/bus/iio/iio:deviceX/in_voltage0_raw
/sys/bus/iio/iio:deviceX/in_voltage1_raw
/sys/bus/iio/iio:deviceX/in_voltage2_raw
/sys/bus/iio/iio:deviceX/in_voltage3_raw
```

###### 范例：in_intensity_ir_raw

使用修饰符：给定一个带有两个通道的光传感器 - 一个用于红外光，一个用于红外和可见光，没有索引或修改器，属性名称将为in_intensity_raw。 在这里使用索引可能容易出错，因为使用in_intensity0_ir_raw和in_intensity1_ir_raw是没有意义的(0,1 上层并不知道该节点什么功能)。 使用修饰符将有助于提供有意义的属性名称。 通道的定义如下：

```c
static const struct iio_chan_spec mylight_channels[] = {

        {
                .type = IIO_INTENSITY,
                .modified = 1,
                .channel2 = IIO_MOD_LIGHT_IR,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
                .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),
        },
        {
                .type = IIO_INTENSITY,
                .modified = 1,
                .channel2 = IIO_MOD_LIGHT_BOTH,
                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
                .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),
        },
        {
                .type = IIO_LIGHT,
                .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),
                .info_mask_shared =BIT(IIO_CHAN_INFO_SAMP_FREQ),

        },
       }
```

属性结果：

```shell
/sys/bus/iio/iio:deviceX/in_intensity_ir_raw 用于测量IR强度的通道

/sys/bus/iio/iio:deviceX/in_intensity_both_raw用于测量红外和可见光的通道

/sys/bus/iio/iio:deviceX/in_illuminance_input用于处理后的数据

/sys/bus/iio/iio:deviceX/sampling_frequency 用于采样频率，由所有人共享
```
这也适用于加速度计，我们将在案例研究中进一步了解。 

#### 2.2.1.4 enum iio_endian

字节序字段应为以下之一：

```c
enum iio_endian {
                         IIO_CPU,
                         IIO_BE,
                         IIO_LE,

};
```



#### 2.2.1.5 总结

现在，让我们总结一下我们到目前为止在虚拟IIO驱动程序中讨论过的内容。

让我们总结一下迄今为止我们在一个简单的虚拟驱动器中看到的内容，它将暴露出四个电压通道。 我们将忽略read（）或write（）函数：

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/platform_device.h>
#include <linux/interrupt.h>
#include <linux/of.h>
#include <linux/iio/iio.h>
#include <linux/iio/sysfs.h>
#include <linux/iio/events.h>
#include <linux/iio/buffer.h>


#define FAKE_VOLTAGE_CHANNEL(num)                  \
   {                                               \
         .type = IIO_VOLTAGE,                      \
         .indexed = 1,                             \
         .channel = (num),                         \
         .address = (num),                         \
         .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),   \
         .info_mask_shared_by_type =BIT(IIO_CHAN_INFO_SCALE) \

   }


struct my_private_data {
    int foo;
    int bar;
    struct mutex lock;
};

static int fake_read_raw(struct iio_dev *indio_dev,
                   struct iio_chan_spec const *channel, int *val,
                   int *val2, long mask)
{
    return 0;
}

static int fake_write_raw(struct iio_dev *indio_dev,
                   struct iio_chan_spec const *chan,
                   int val, int val2, long mask)
{
    return 0;
}

static const struct iio_chan_spec fake_channels[] = {
   FAKE_VOLTAGE_CHANNEL(0),
   FAKE_VOLTAGE_CHANNEL(1), 
   FAKE_VOLTAGE_CHANNEL(2),
   FAKE_VOLTAGE_CHANNEL(3),

};

static const struct of_device_id iio_dummy_ids[] = {
    { .compatible = "packt,iio-dummy-random", },
    { /* sentinel */ }
};

static const struct iio_info fake_iio_info = {
   .read_raw = fake_read_raw,
   .write_raw        = fake_write_raw,
   .driver_module = THIS_MODULE,
};

static int my_pdrv_probe (struct platform_device *pdev)
{
    struct iio_dev *indio_dev;
    struct my_private_data *data;
   indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*data));

   if (!indio_dev) {
         dev_err(&pdev->dev, "iio allocation failed!\n");
         return -ENOMEM;
   }

   data = iio_priv(indio_dev);
   mutex_init(&data->lock);
   indio_dev->dev.parent = &pdev->dev;
   indio_dev->info = &fake_iio_info;
   indio_dev->name = KBUILD_MODNAME;
   indio_dev->modes = INDIO_DIRECT_MODE;
   indio_dev->channels = fake_channels;
   indio_dev->num_channels = ARRAY_SIZE(fake_channels);
   indio_dev->available_scan_masks = 0xF;
    iio_device_register(indio_dev);
    platform_set_drvdata(pdev, indio_dev);
    return 0;
}
static void my_pdrv_remove(struct platform_device *pdev)
{
    struct iio_dev *indio_dev = platform_get_drvdata(pdev);
    iio_device_unregister(indio_dev);
}
static struct platform_driver mypdrv = {
    .probe      = my_pdrv_probe,
    .remove     = my_pdrv_remove,
    .driver     = {
        .name     = "iio-dummy-random",
        .of_match_table = of_match_ptr(iio_dummy_ids),  
        .owner    = THIS_MODULE,
    },
};
module_platform_driver(mypdrv);
MODULE_AUTHOR("John Madieu <john.madieu@gmail.com>");
MODULE_LICENSE("GPL");

```

加载上述模块后, 我们将有以下输出, 显示我们的设备确实对应于我们已注册的平台设备:

```c
 ~# ls -l /sys/bus/iio/devices/
lrwxrwxrwx 1 root root 0 Jul 31 20:26 iio:device0 -> ../../../devices/platform/iio-dummy-random.0/iio:device0

lrwxrwxrwx 1 root root 0 Jul 31 20:23 iio_sysfs_trigger -> ../../../devices/iio_sysfs_trigger
```

下面的列表显示了此设备的通道及其名称, 这些通道与我们在驱动程序中描述的内容完全对应:

```c
 ~# ls /sys/bus/iio/devices/iio\:device0/
dev in_voltage2_raw name uevent
in_voltage0_raw in_voltage3_raw power
in_voltage1_raw in_voltage_scale subsystem
~# cat /sys/bus/iio/devices/iio:device0/name
iio_dummy_random
```

### 2.2.2 **触发缓冲支持**

Triggered buffer support触发缓冲支持
  在许多数据分析应用中，能够基于某些外部信号（触发器）捕获数据是比较有用的。 这些触发器可能是：
    数据就绪信号
    连接到某个外部系统的IRQ线路（GPIO或其他）
    处理器周期性中断
    用户空间在sysfs中读/写特定文件
  IIO设备驱动程序与触发器完全无关。 触发器可以初始化一个或多个设备上的数据捕获。 这些触发器用于填充缓冲区，然后作为字符设备暴露给用户空间。
可以开发一个自己的触发驱动程序，但这超出了本书的范围。 我们将尝试仅关注现有的。 这些是：

**iio-trig-interrupt:**这为使用任何IRQ作为IIO触发器提供了支持。 在旧的内核版本中，它曾经是iio-trig-gpio。 启用此触发模式的内核选项是CONFIG_IIO_INTERRUPT_TRIGGER。 如果构建为模块，则该模块将被称为iio-trig-interrupt。
**iio-trig-hrtimer:**这提供了一个基于频率的IIO触发器，使用HRT作为中断源（因为内核v4.5）。 在较旧的内核版本中，它曾经是iio-trig-rtc。 负责此触发模式的内核选项是IIO_HRTIMER_TRIGGER。 如果构建为模块，则该模块将被称为iio-trig-hrtimer。
**iio-trig-sysfs:**这允许我们使用sysfs条目来触发数据捕获。 CONFIG_IIO_SYSFS_TRIGGER是添加此触发模式支持的内核选项。

**iio-trig-bfin-timer**:这允许我们使用blackfin定时器作为IIO触发器（仍然在分段中）。

IIO公开的API，帮助我们：
  声明任何给定数量的触发器
  选择将其数据推入缓冲区的通道
  当您的IIO设备提供触发缓冲区的支持时，您必须设置iio_dev.pollfunc，它在触发器触发时执行。 此处理程序负责通过indio_dev-> active_scan_mask查找已启用的通道，检索其数据，并使用iio_push_to_buffers_with_timestamp函数将它们提供给indio_dev-> buffer。 因此，缓冲区和触发器需要在IIO子系统中连接。
IIO内核提供了一组辅助函数来设置触发缓冲区，可以在drivers / iio / industrialio-triggered-buffer.c中找到。

#### 支持触发缓冲区步骤

驱动程序中支持触发缓冲区的步骤:

1. 如果需要，填写iio_buffer_setup_ops结构：

```c
const struct iio_buffer_setup_ops sensor_buffer_setup_ops = { 
  .preenable    = my_sensor_buffer_preenable, 
  .postenable   = my_sensor_buffer_postenable, 
  .postdisable  = my_sensor_buffer_postdisable, 
  .predisable   = my_sensor_buffer_predisable, 
};

```

2. 写下与触发器关联的上半部分。 在99％的情况下，只需提供与捕获相关的时间戳：

```c
irqreturn_t sensor_iio_pollfunc(int irq, void *p) 
{ 
    pf->timestamp = iio_get_time_ns((struct indio_dev *)p); 
    return IRQ_WAKE_THREAD; 
}
```

3. 写入触发器下半部分，它将从每个启用的通道获取数据，并将它们提供给缓冲区：

```c
irqreturn_t sensor_trigger_handler(int irq, void *p) 
{ 
    u16 buf[8]; 
    int bit, i = 0; 
    struct iio_poll_func *pf = p; 
    struct iio_dev *indio_dev = pf->indio_dev; 
 
    /* one can use lock here to protect the buffer */ 
    /* mutex_lock(&my_mutex); */ 
 
    /* read data for each active channel */ 
    for_each_set_bit(bit, indio_dev->active_scan_mask, 
                     indio_dev->masklength) 
        buf[i++] = sensor_get_data(bit) 
 
    /* 
     * If iio_dev.scan_timestamp = true, the capture timestamp 
     * will be pushed and stored too, as the last element in the 
     * sample data buffer before pushing it to the device buffers. 
     */ 
    iio_push_to_buffers_with_timestamp(indio_dev, buf, timestamp); 
 
    /* Please unlock any lock */ 
    /* mutex_unlock(&my_mutex); */ 
 
    /* Notify trigger */ 
    iio_trigger_notify_done(indio_dev->trig); 
    return IRQ_HANDLED; 
}

```

4. 最后，在probe函数中，必须在使用iio_device_register（）注册设备之前设置缓冲区本身：

```c
iio_triggered_buffer_setup(indio_dev, sensor_iio_polfunc/*上半部*/,
	sensor_trigger_handler/*下半部*/,
	sensor_buffer_setup_ops/*启用/禁用缓冲区之前和之后调用的回调函数集。*/);
```

#### sys文件接口和触发缓冲互斥

sys文件接口和触发缓冲互斥(不能同时进行，不然会有意想不到的情况发生)

这里的神奇函数是iio_triggered_buffer_setup。 这也将为您的设备提供INDIO_DIRECT_MODE功能。 当触发器（从用户空间）连接到您的设备时，您无法知道何时触发捕获。
  当连续缓冲捕获处于活动状态时，应该阻止（通过返回错误）驱动程序执行sysfs每通道数据捕获（由read_raw（）挂钩执行）以避免未确定的行为，因为触发器处理程序和read_raw（ ）hook会尝试同时访问设备(**sysfs文件接口和触发缓冲不能同时工作**)。 用于检查是否实际使用缓冲模式的函数是iio_buffer_enabled();

```c
// 读sysfs 中的接口文件事，会调用这个函数
static int my_read_raw(struct iio_dev *indio_dev, 
                     const struct iio_chan_spec *chan, 
                     int *val, int *val2, long mask) 
{ 
      [...] 
      switch (mask) { 
      case IIO_CHAN_INFO_RAW: 
            if (iio_buffer_enabled(indio_dev)) 
                  return -EBUSY; // 在这里通过返回错误，来避免两种机制同时使用设备
      [...]        
}
```

iio_buffer_enabled（）函数只是确定是否为给定的IIO设备启用了缓冲区。

#### 注意事项：

在使用触发缓冲 中的一些重要事项：

#####  iio_buffer_setup_ops

/*启用/禁用缓冲区之前和之后调用的回调函数集。*/

```c
struct iio_buffer_setup_ops {    
    int (*preenable)(struct iio_dev *);
    int (*postenable)(struct iio_dev *); 
    int (*predisable)(struct iio_dev *);
    int (*postdisable)(struct iio_dev *);
    bool (*validate_scan_mask)(struct iio_dev *indio_dev,
                   const unsigned long *scan_mask);
};
```

iio_buffer_setup_ops提供缓冲区设置函数，以便在缓冲区配置序列的固定步骤（在启用/禁用之前/之后）调用。 如果未指定，则IIO内核将为您的设备提供默认的iio_triggered_buffer_setup_ops。

##### sensor_iio_pollfunc

sensor_iio_pollfunc是触发器的上半部分。 与每个上半部分一样，它在中断上下文中运行，并且必须尽可能少地处理。 
在99％的情况下，您只需提供与捕获相关的时间戳。 再次，可以使用默认的IIO iio_pollfunc_store_time函数。

##### sensor_trigger_handler

sensor_trigger_handler是下半部分，它在内核线程中运行，允许我们进行任何处理，包括甚至获取互斥或睡眠。 重处理应该在这里进行。 它通常从设备读取数据并将其与上半部分中记录的时间戳一起存储在内部缓冲区中，并将其推送到IIO设备缓冲区。

注意：触发缓冲必须使用触发器。 它告诉驱动程序何时从设备读取样本并将其放入缓冲区。 **触发缓冲对于编写IIO设备驱动程序不是必需的**。 通过读取通道的原始属性，也可以通过sysf使用单次捕获，这只会执行单次转换（对于正在读取的通道属性）。 缓冲模式允许连续转换，从而在单次捕获多个通道。

#### **IIO trigger and sysfs (user space)用户空间触发器和sysfs**

sysfs中有两个与触发器相关的位置：
  /sys/bus/iio/devices/triggerY/:一旦IIO触发器注册到IIO核心并且对应于索引为Y的触发器，就会创建该目录。目录中至少有一个属性：
  name:这是可以在以后用于与设备关联的触发器名称
  另一个可能是采样频率或其他，和触发器类型相关
  **/sys/bus/iio/devices/iio:deviceX/trigger/*如果您的设备支持触发缓冲区，将自动创建目录。 通过在current_trigger文件中写入触发器的名称，可以将触发器与我们的设备相关联。**

#### **Sysfs trigger interface  Sysfs触发器接口**

通过CONFIG_IIO_SYSFS_TRIGGER = y config选项在内核中启用sysfs触发器，这将导致自动创建/ sys / bus / iio / devices / iio_sysfs_trigger /文件夹，并可用于sysfs触发器管理。 目录中将有两个文件add_trigger和remove_trigger。 它的驱动程序在drivers / iio / trigger / iio-trig-sysfs.c中。


add_trigger file

  这用于创建新的sysfs触发器。 您可以通过将正值（将用作触发器ID）写入该文件来创建新触发器。 它将创建新的sysfs触发器，可在/ sys / bus / iio / devices / triggerX中访问，其中X是触发器编号。
  例如：# echo 2 > add_trigger
  这将创建一个新的sysfs触发器，可在/ sys / bus / iio / devices / trigger2中访问。 如果系统中已存在具有指定ID的触发器，则将返回无效的参数消息。 sysfs触发器名称模式为sysfstrig {ID}。 命令echo 2> add_trigger将创建名为sysfstrig2的trigger / sys / bus / iio / devices / trigger2：

```shell
$ cat /sys/bus/iio/devices/trigger2/name
 sysfstrig2

```

每个sysfs触发器至少包含一个文件：trigger_now。 将1写入该文件将指示其current_trigger中具有相应触发器名称的所有设备开始捕获，并将数据推送到其各自的缓冲区中。 每个设备缓冲区必须设置其大小，并且必须启用（echo 1> / sys / bus / iio / devices / iio：deviceX / buffer / enable）。

remove_trigger file

要删除触发器，请使用以下命令：

```shell
echo 2 > remove_trigger
```

使用触发器绑定设备
将设备与给定触发器相关联包括将触发器的名称写入设备触发器目录下可用的current_trigger文件。 例如，假设我们需要将设备与具有索引2的触发器绑定：

```shell
# set trigger2 as current trigger for device0
#echo sysfstrig2 >    /sys/bus/iio/devices/iio:device0/trigger/current_trigger
```

要从设备分离触发器，应该将空字符串写入设备触发器目录的current_trigger文件，如下所示：

```shell
#echo "" > iio:device0/trigger/current_trigger
```

我们将在本章中进一步看到一个处理数据捕获的sysfs触发器的实际示例。

#### **The interrupt trigger interface中断触发器接口**

```c
static struct resource iio_irq_trigger_resources[] = { 
    [0] = { 
        .start = IRQ_NR_FOR_YOUR_IRQ, 
        .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE, 
    	}, 
}; 
 
static struct platform_device iio_irq_trigger = { 
    .name = "iio_interrupt_trigger", 
    .num_resources = ARRAY_SIZE(iio_irq_trigger_resources), 
    .resource = iio_irq_trigger_resources, 
}; 
platform_device_register(&iio_irq_trigger);

```

声明我们的IRQ触发器，它将加载IRQ触发器独立模块。 如果其探测功能成功，则会有一个与触发器对应的目录。 IRQ触发器名称的格式为irqtrigX，其中X对应于刚刚传递的虚拟IRQ，您将在/ proc / interrupt中看到：

```shell
$ cd /sys/bus/iio/devices/trigger0/
 $ cat name

```

正如我们对其他触发器所做的那样，您只需将该触发器分配给设备current_trigger文件即可将该触发器分配给您的设备。

```shell
# echo "irqtrig85" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger

```

现在，每次触发中断时，都会捕获设备数据。
注意：IRQ触发器驱动程序还不支持DT，这就是我们使用board init文件的原因。 但是这没关系; 由于驱动程序需要资源，我们可以使用DT而无需更改任何代码。

以下是声明IRQ触发器接口的设备树节点的示例：

```shell
	mylabel: my_trigger@0{ 
    	compatible = "iio_interrupt_trigger"; 
    	interrupt-parent = <&gpio4>; 
    	interrupts = <30 0x0>; 
};
```

该示例假设IRQ线是属于GPIO控制器节点gpio4的GPIO＃30。 这包括使用GPIO作为中断源，这样无论何时GPIO变为给定状态，都会引发中断，从而触发捕获。

#### **hrtimer触发器接口（4.5内核以下可能不支持）**

hrtimer触发器依赖于configfs文件系统（请参阅内核源代码中的Documentation / iio / 
iio_configfs.txt），可以通过CONFIG_IIO_CONFIGFS配置选项启用它，并挂载在我们的系统上（通常位于/ 
config目录下）：

```c
# mkdir /config
# mount -t configfs none /config

```

现在，加载模块iio-trig-hrtimer将创建在/ config / iio下可访问的IIO组，允许用户在/ config / iio / triggers / hrtimer下创建hrtimer触发器。
如：

```shell
 # create a hrtimer trigger
  $ mkdir /config/iio/triggers/hrtimer/my_trigger_name
  # remove the trigger
  $ rmdir /config/iio/triggers/hrtimer/my_trigger_name
```

每个hrtimer触发器在触发器目录中包含单个sampling_frequency属性。 在使用hrtimer触发器的数据捕获一节中的章节中进一步提供了完整且有效的示例。

#### **IIO buffers IIO缓冲区**

IIO缓冲区提供连续数据捕获，可同时读取多个数据通道。 可以通过/ dev / iio：设备字符设备节点从用户空间访问缓冲区。 在触发器处理程序中，用于填充缓冲区的函数是iio_push_to_buffers_with_timestamp。 负责为您的设备分配触发缓冲区的函数是iio_triggered_buffer_setup（）。


#### IIO缓冲sysfs接口

  IIO缓冲区在/ sys / bus / iio / iio下有一个关联的属性目录：deviceX / buffer / *。 以下是一些现有属性：
  length: 缓冲区可以存储的数据样本总数（容量）。 这是缓冲区包含的扫描数。
  enable: 这将激活缓冲区捕获，启动缓冲区捕获。
  watermark: 自内核版本v4.2起，此属性已可用。 它是一个正数，指定阻塞读取应等待的扫描元素数。 例如，如果使用轮询，它将阻塞，直到达到水印。 只有当水印大于请求的读取量时才有意义。 它不会影响非阻塞读取。 可以在超时时阻止轮询并在超时到期后读取可用样本，因此具有最大延迟保证。

#### IIO缓冲区设置

  将要读取数据并将其推入缓冲区的通道称为扫描元素。 可以从用户空间通过/ sys / bus / iio / iio：deviceX / scan_elements / *目录访问它们的配置，其中包含以下属性：
  en （实际上是属性名称的后缀）用于启用通道。 当且仅当其属性为非零时，触发捕获将包含此通道的数据样本。 例如，in_voltage0_en，in_voltage1_en等。
  type 描述了缓冲区内的扫描元素数据存储，因此描述了从用户空间读取它的形式。 例如，in_voltage0_type。 格式为[be | le]：
  [s|u]bits/storagebitsXrepeat[>>shift].
    be或le指定字节序（大或小）
     s或u指定符号（带符号（2的补码）或无符号）。
    bits 是有效数据位的数量。
    storagebits ：是此通道在缓冲区中占用的位数。 也就是说，一个值可以用12位（位）真正编码，但在缓冲区中占用16位（存储位）。 因此，必须将数据向右移动四次以获得实际值。 此参数取决于设备，应参考其数据表。
    shift：表示在屏蔽掉未使用的位之前应该移位数据值的次数。 并不总是需要此参数。 如果有效位（位）的数量等于存储位的数量，则移位将为0.还可以在器件数据手册中找到该参数。
    repeat 指定位/存储位重复的数量。 当repeat元素为0或1时，则省略重复值。

  解释这一部分的最好方法是通过内核文档的摘录，可以在这里找到：https：//www.kernel.org/doc/html/latest/driver-api/iio/buffers.html。 例如，用于3轴加速度计的驱动程序，具有12位分辨率，其中数据存储在两个8位寄存器中，如下所示：

```shell
7   6   5   4   3   2   1   0 
+---+---+---+---+---+---+---+---+ 
|D3 |D2 |D1 |D0 | X | X | X | X | (LOW byte, address 0x06) 
+---+---+---+---+---+---+---+---+ 
  7   6   5   4   3   2   1   0 
+---+---+---+---+---+---+---+---+ 
|D11|D10|D9 |D8 |D7 |D6 |D5 |D4 | (HIGH byte, address 0x07) 
+---+---+---+---+---+---+---+---+ 

```

每个轴将具有以下扫描元素类型：

```shell
$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_y_type
 	le:s12/16>>4

```

人们应该将其解释为16位大小的小端符号数据，需要在屏蔽12个有效数据位之前将其右移4位。

struct iio_chan_spec中负责确定如何将通道的值存储到缓冲区中的元素是scant_type。

```c
struct iio_chan_spec { 
        [...] 
        struct { 
            char sign; /* Should be 'u' or 's' as explained above */ 
            u8 realbits; 
            u8 storagebits; 
            u8 shift; 
            u8 repeat; 
            enum iio_endian endianness; 
        } scan_type; 
        [...] 
};
```

这个结构绝对匹配[be | le]：[s|u]bits/storagebitsXrepeat[>>shift], ，这是上一节中描述的模式。 让我们看看结构的每个成员：
    sign表示数据的符号，并匹配模式中的[s | u]
    realbits对应于模式中的位
    storagebits与模式中的相同名称匹配
    shift对应于模式的移位，重复相同
    iio_indian表示字节序，并匹配模式中的[be | le]
  此时，可以编写与前面解释的类型相对应的IIO通道结构：

```c
struct struct iio_chan_spec accel_channels[] = { 
        { 
                .type = IIO_ACCEL, 
                .modified = 1, 
                .channel2 = IIO_MOD_X, 
                /* other stuff here */ 
                .scan_index = 0, 
                .scan_type = { 
                        .sign = 's', 
                        .realbits = 12, 
                        .storagebits = 16, 
                        .shift = 4, 
                        .endianness = IIO_LE, 
                }, 
        } 
      /* similar for Y (with channel2 = IIO_MOD_Y, scan_index = 1) 
       * and Z (with channel2 = IIO_MOD_Z, scan_index = 2) axis 
       */ 
}
```

#### 实例 bma220 驱动分析

让我们仔细看看BOSH的数字三轴加速度传感器BMA220。 这是一个SPI / I2C兼容器件，具有8位大小的寄存器，以及片上运动触发中断控制器，实际上可以感应倾斜，运动和冲击振动。 其数据表可从以下网址获得：http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF，其驱动程序自内核v4.8（CONFIG_BMA200）开始引入。 让我们一起来看看：
  首先，我们使用struct iio_chan_spec声明我们的IIO通道。 一旦使用了触发缓冲区，我们就需要填充.scan_index和.scan_type字段：

```c
#define BMA220_DATA_SHIFT 2 
#define BMA220_DEVICE_NAME "bma220" 
#define BMA220_SCALE_AVAILABLE "0.623 1.248 2.491 4.983" 
 
#define BMA220_ACCEL_CHANNEL(index, reg, axis) {           \ 
   .type = IIO_ACCEL,                                      \ 
   .address = reg,                                         \ 
   .modified = 1,                                          \ 
   .channel2 = IIO_MOD_##axis,                             \ 
   .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),           \ 
   .info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),   \ 
   .scan_index = index,                                    \ 
   .scan_type = {                                          \ 
         .sign = 's',                                      \ 
         .realbits = 6,                                    \ 
         .storagebits = 8,                                 \ 
         .shift = BMA220_DATA_SHIFT,                       \ 
         .endianness = IIO_CPU,                            \ 
   },                                                      \ 
} 
 
static const struct iio_chan_spec bma220_channels[] = { 
   BMA220_ACCEL_CHANNEL(0, BMA220_REG_ACCEL_X, X), 
   BMA220_ACCEL_CHANNEL(1, BMA220_REG_ACCEL_Y, Y), 
   BMA220_ACCEL_CHANNEL(2, BMA220_REG_ACCEL_Z, Z), 
};

```

.info_mask_separate = BIT（IIO_CHAN_INFO_RAW）表示每个通道都有一个* _raw sysfs条目（属性），而.info_mask_shared_by_type =   BIT（IIO_CHAN_INFO_SCALE）表示所有相同类型的通道只有一个* _scale sysfs条目：

```shell
  jma@jma:~$ ls -l /sys/bus/iio/devices/iio:device0/
    (...)

# without modifier, a channel name would have in_accel_raw (bad)
-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_scale
-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_x_raw
-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_y_raw
-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_z_raw
(...)

```

读取in_accel_scale会调用read_raw（）挂钩，并将掩码设置为IIO_CHAN_INFO_SCALE。 读取in_accel_x_raw会调用read_raw（）挂钩，并将掩码设置为IIO_CHAN_INFO_RAW。 因此，实际值是raw_value * scale。
  .scan_type所说的是每个通道返回的值是8位大小（将占用缓冲区中的8位），但有用的有效负载仅占用6位，并且数据必须在屏蔽之前右移2次 出未使用的位。 任何扫描元素类型将如下所示：

```shell
$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_x_type
le:s6/8>>2

```

以下是我们的pollfunc（实际上是下半部分），它从设备读取样本并将读取值推送到缓冲区（iio_push_to_buffers_with_timestamp（））。 完成后，我们通知核心（iio_trigger_notify_done（））：

```c
static irqreturn_t bma220_trigger_handler(int irq, void *p) 
{ 
   int ret; 
   struct iio_poll_func *pf = p; 
   struct iio_dev *indio_dev = pf->indio_dev; 
   struct bma220_data *data = iio_priv(indio_dev); 
   struct spi_device *spi = data->spi_device; 
 
   mutex_lock(&data->lock); 
   data->tx_buf[0] = BMA220_REG_ACCEL_X | BMA220_READ_MASK; 
   ret = spi_write_then_read(spi, data->tx_buf, 1, data->buffer, 
                       ARRAY_SIZE(bma220_channels) - 1); 
   if (ret < 0) 
         goto err; 
 
   iio_push_to_buffers_with_timestamp(indio_dev, data->buffer, 
                              pf->timestamp); 
err: 
   mutex_unlock(&data->lock); 
   iio_trigger_notify_done(indio_dev->trig); 
 
   return IRQ_HANDLED; 
}

```

以下是读取功能。 它是一个钩子，每次读取设备的sysfs条目时都会调用它：

```c
static int bma220_read_raw(struct iio_dev *indio_dev, 
                  struct iio_chan_spec const *chan, 
                  int *val, int *val2, long mask) 
{ 
   int ret; 
   u8 range_idx; 
   struct bma220_data *data = iio_priv(indio_dev); 
 
   switch (mask) { 
   case IIO_CHAN_INFO_RAW: 
           /* If buffer mode enabled, do not process single-channel read */ 
           if (iio_buffer_enabled(indio_dev)) 
                   return -EBUSY; 
           /* Else we read the channel */ 
           ret = bma220_read_reg(data->spi_device, chan->address); 
           if (ret < 0) 
                   return -EINVAL; 
           *val = sign_extend32(ret >> BMA220_DATA_SHIFT, 5); 
           return IIO_VAL_INT; 
   case IIO_CHAN_INFO_SCALE: 
           ret = bma220_read_reg(data->spi_device, BMA220_REG_RANGE); 
           if (ret < 0) 
                   return ret; 
           range_idx = ret & BMA220_RANGE_MASK; 
           *val = bma220_scale_table[range_idx][0]; 
           *val2 = bma220_scale_table[range_idx][1]; 
           return IIO_VAL_INT_PLUS_MICRO; 
   } 
 
   return -EINVAL; 
}

```

当读取原始sysfs文件时，调用挂钩，在mask参数中给定IIO_CHAN_INFO_RAW，并在 chan参数中调用相应的通道。 * val和val2实际上是输出参数。 必须使用原始值设置它们（从设备读取）。 在* scale sysfs文件上执行的任何读取都将使用掩码参数中的IIO_CHAN_INFO_SCALE调用挂钩，依此类推每个属性掩码。
  写入功能也是如此，用于将值写入设备。 您的驱动程序有80％的可能性不需要写入功能。 此写挂钩允许用户更改设备的比例：

```c
static int bma220_write_raw(struct iio_dev *indio_dev, 
                   struct iio_chan_spec const *chan, 
                   int val, int val2, long mask) 
{ 
   int i; 
   int ret; 
   int index = -1; 
   struct bma220_data *data = iio_priv(indio_dev); 
 
   switch (mask) { 
   case IIO_CHAN_INFO_SCALE: 
         for (i = 0; i < ARRAY_SIZE(bma220_scale_table); i++) 
               if (val == bma220_scale_table[i][0] && 
                   val2 == bma220_scale_table[i][1]) { 
                     index = i; 
                     break; 
               } 
         if (index < 0) 
               return -EINVAL; 
 
         mutex_lock(&data->lock); 
         data->tx_buf[0] = BMA220_REG_RANGE; 
         data->tx_buf[1] = index; 
         ret = spi_write(data->spi_device, data->tx_buf, 
                     sizeof(data->tx_buf)); 
         if (ret < 0) 
               dev_err(&data->spi_device->dev, 
                     "failed to set measurement range\n"); 
         mutex_unlock(&data->lock); 
 
         return 0; 
   } 
 
   return -EINVAL; 
}

```

只要将值写入设备，就会调用此函数。 经常更改的参数是比例。 一个例子可能是：

```shell
echo <desired-scale> > /sys/bus/iio/devices/iio;devices0/in_accel_scale.
```

现在，它来填充一个结构iio_info结构，给我们的iio_device：

```c
static const struct iio_info bma220_info = { 
   .driver_module    = THIS_MODULE, 
   .read_raw         = bma220_read_raw, 
   .write_raw        = bma220_write_raw, /* Only if your driver need it */ 
};

```

在probe函数中，我们分配并设置了一个struct iio_dev IIO设备。 私人数据的内存也被保留：

```c
/* 
 * We provide only two mask possibility, allowing to select none or every 
 * channels. 
 */ 
static const unsigned long bma220_accel_scan_masks[] = { 
   BIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z), 
   0 
}; 
 
static int bma220_probe(struct spi_device *spi) 
{ 
   int ret; 
   struct iio_dev *indio_dev; 
   struct bma220_data *data; 
 
   indio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*data)); 
   if (!indio_dev) { 
         dev_err(&spi->dev, "iio allocation failed!\n"); 
         return -ENOMEM; 
   } 
 
   data = iio_priv(indio_dev); 
   data->spi_device = spi; 
   spi_set_drvdata(spi, indio_dev); 
   mutex_init(&data->lock); 
 
   indio_dev->dev.parent = &spi->dev; 
   indio_dev->info = &bma220_info; 
   indio_dev->name = BMA220_DEVICE_NAME; 
   indio_dev->modes = INDIO_DIRECT_MODE; 
   indio_dev->channels = bma220_channels; 
   indio_dev->num_channels = ARRAY_SIZE(bma220_channels); 
   indio_dev->available_scan_masks = bma220_accel_scan_masks; 
 
   ret = bma220_init(data->spi_device); 
   if (ret < 0) 
         return ret; 
 
   /* this call will enable trigger buffer support for the device */ 
   ret = iio_triggered_buffer_setup(indio_dev, iio_pollfunc_store_time, 
                            bma220_trigger_handler, NULL); 
   if (ret < 0) { 
         dev_err(&spi->dev, "iio triggered buffer setup failed\n"); 
         goto err_suspend; 
   } 
 
   ret = iio_device_register(indio_dev); 
   if (ret < 0) { 
         dev_err(&spi->dev, "iio_device_register failed\n"); 
         iio_triggered_buffer_cleanup(indio_dev); 
         goto err_suspend; 
   } 
 
   return 0; 
 
err_suspend: 
   return bma220_deinit(spi); 
}
```

可以通过CONFIG_BMA220内核选项启用此驱动程序。 也就是说，这只能从内核中的v4.8开始提供。 可以在较旧的内核版本上使用的最接近的设备是BMA180，可以使用CONFIG_BMA180选项启用它。