####  	1. 前言 

 	这里的Generic PM，是蜗蜗自己起的名字，指Linux系统中那些常规的电源管理手段，包括关机（Power off）、待机（Standby  or  Hibernate）、重启（Reboot）等。这些手段是在嵌入式Linux普及之前的PC或者服务器时代使用的。在那个计算机科学的蛮荒时代，人类在摩尔定律的刺激下，孜孜追求的是计算机的计算能力、处理性能，因此并不特别关心Power消耗。 

 	在这种背景下发展出来的Linux电源管理机制，都是粗放的、静态的、被动的，具体请参考下面的介绍。 

####  	2. Generic PM在Linux操作系统中的表现形式 

 	Linux操作系统中，和Generic PM有关的操作如下面图片： 

 	[![Generic PM在Linux操作系统中的表现形式](http://www.wowotech.net/content/uploadfile/201405/824cd514b1a594c9d14bbd07b9e8f73920140513012405.gif)](http://www.wowotech.net/content/uploadfile/201405/10b0c99c144a460195be14336f4a70a720140513012339.gif)  

 	该图片截取自蜗蜗使用的“Linux ubuntu 2.6.32-38”系统，共有3部分组成： 

 	第1部分是系统关机、重启等操作的界面，共包含Hibernate、Restart、Shutdown三个操作选项； 

 	2、3部分是“电源管理属性”设置，所谓的电源管理属性，可以配置系统在不同供电模式下（如AC Power、Battery等，由于蜗蜗的机器是PC机，因此就没有电池供电的选项），处于Inactive状态多久后，系统关闭Display，或者进入Sleep状态。 

 	本文将会围绕上面提到的各个名词，讲述它们的意义、在内核中的实现方式。开始之前，先解释一下这些词汇的意义。 

>  		Shutdown，很好理解，就是关机的意思。同时意味着不再使用计算机。 	
>
>  		Restart，也很好理解，就是重启系统的意思。重启的过程，不再使用计算机。 	
>
>  		Hibernate，可翻译为冬眠。 	

> >  			听到“冬眠”这个词，您是否眼前一亮？蜗蜗在“[Linux电源管理(1)_整体架构](http://www.wowotech.net/pm_architecture.html)”中解释电源管理的概念的时候，提到过，动物冬眠就是大自然所设计的电源管理方式的一种。在动物界，冬眠是指动物们（通常针对温血动物）通过降低体温的方式而进入的类似昏睡的生理状态，在这种状态下，需要消耗的能量较少，从而可以达到省电（能量）的目的。  		
>
> >  			而在计算机界，设计师们也借用了“冬眠”的概念，在不需要使用计算机时，将它当前的所有现场（执行的程序、显示器显示的图像、正在播放的声音等）保存到一些断电不会丢失的存储器中（如硬盘中），然后将计算机关闭。重新开启后，系统会从存储器中将关闭前的现场读取出来并恢复，此时从使用者的角度看，计算机就像没有关闭过一样。 		
> >
> >  			 如果把计算机界的“冬眠”搬到动物界，会是这样的场景：一只恐龙，迈着八字步，吃着香蕉，晃晃悠悠的走在树林中。然后，无聊的孙猴子来了，喊了一声“定！”，恐龙就定在那里了。再然后，一万年过去了，无聊的孙猴子又来了，喊了一声“动！”，恐龙继续迈着八字步，吃着香蕉，就像什么事情都没有发生一样。 		
>
>  		 Sleep，睡眠。这个词也是从生物界学来的。想象一下“睡眠”和“冬眠”的区别？“睡眠”睡的轻，随时都可以醒来。在计算机中，Hibernate需要把现场保存到断电不丢失的存储器中，并在醒来的时候读回来，这些可能需要较长的时间（因为断电不丢失存储器的访问速度都比较慢）。如果想快点，就把现场保存在内存中就可以了，这就是Sleep。不过这是要付出代价的，内存要保持供电，这就要消耗能量，鱼与熊掌不可兼得啊！ 	
>
>  		Auto Sleep，查看上面图片第3个部分，可以设置系统“处于Inactive状态多久后，自动进入Sleep状态”。比如我正在写这篇文章，然后被老婆喊去跪搓衣板了，一跪两个小时。这两个小时内，计算机不再被使用，如果不进入Sleep状态，将会消耗很多能量。为了避免这无谓的消耗，可以让系统在符合条件时（如20分钟不使用），自动睡下去。 	
>
>  		Auto put display to Sleep，原理类似，只是操作的对象是Display（显示器等）。 	

 	  

 	注：  

 	不知读者有没有注意到，蜗蜗在解释上面的词汇时，一直在用红色字体强调“计算机不再使用”。这就是Generic PM和Runtime PM的本质区别，即，在使用者的主观意愿上，是否需要暂停使用计算机（哪怕短短的一段时间）。  

 	这也是Generic  PM在传统的计算机操作系统中被广泛使用的原因，因为那个时候对计算机的使用大多是主动方式。而对当前的移动互联来说，就非常不合时宜了，因为人们需要移动设备实时在线、实时接收被动事件（如来电），也就不可能主观地暂停使用（哪怕短短的一段时间）。这种最终需求的差异，会导致在软件设计上有很大的差别，正因为如此，Runtime  PM的出现和尽快成熟，才显得格外重要。  

####  	3. Generic PM的软件架构 

 	在介绍完Generic PM的基本概念后，我们来看一下它在Linux内核中的整体实现，并抽象出简单的软件架构，以便再后续的文章中，对Generic PM的主要组成部分进行更为细致的分析。具体如下： 

 	[![Generic PM Architecture](http://www.wowotech.net/content/uploadfile/201405/8009b47a9e67759ebd4f1e1044a7bba120140514034350.gif)](http://www.wowotech.net/content/uploadfile/201405/84f0e5d0dcb8b687224b39d1f400482620140514034349.gif)  

 	根据上面的描述可知，Generic PM主要处理关机、重启、冬眠（Hibernate）、睡眠（Sleep，在Kernel中也称作Suspend）。在内核中，大致可以分为三个软件层次： 

>  		API Layer，用于向用户空间提供接口，其中关机和重启的接口形式是系统调用（在新的内核中，关机接口还有一种新方式，具体讲到的时候再说），Hibernate和Suspend的接口形式是sysfs。 	
>
>  		PM Core，位于kernel/power/目录下，主要处理和硬件无关的核心逻辑。 	
>
>  		PM Driver，分为两个部分，一是体系结构无关的Driver，提供Driver框架（Framework）。另一部分是具体的体系结构相关的Driver，这也是电源管理驱动开发需要涉及到的内容（图中红色边框的模块）。 	
>
>  		另外，电源管理是一个系统级的模块，因而会涉及到设备模型、进程管理等等方方面面的内容，我们可以在后续具体的分析过程中，细细品味。 	