在内存管理(MM)的各种机制介绍之前，首先需要对ＭＭ的初始化过程有所了解，以下介绍的内容是以分段和分页机制为基础的，因此，读者应该先温习前几讲相关的内容。因为在嵌入式操作系统的开发中，内存的初始化是重点关注的内容之一，因此本讲对内存的初始化给予详细的讲解。

# 1. 启用分页机制

当linux启动时，首先运行在实模式下，随后就要转到保护模式下运行。因为在第二章段机制中，我们已经介绍了linux对段的设置，在此我们主要讨论与分页机制相关的问题。

linux内核代码的入口点在　arch/i386/kernel/head.S 中　startup_32

### 1. 页表的初始化：

```c
/*
 * The page tables are initialized to only 8MB here - the final page
 * tables are set up later depending on memory size.
 */
.org 0x2000
ENTRY(pg0)                                                                                                                                            

.org 0x3000
ENTRY(pg1)
    
    
/*
 * empty_zero_page must immediately follow the page tables ! (The
 * initialization loop counts until empty_zero_page)                                                                                                  
 */

.org 0x4000
ENTRY(empty_zero_page)   
    
 //------------------------------------
 /*
 * Initialize page tables
 */
#define INIT_PAGE_TABLES \
    movl $pg0 - __PAGE_OFFSET, %edi; \
    /* "007" doesn't mean with license to kill, but PRESENT+RW+USER */ \
    movl $007, %eax; \
2:  stosl; \
    add $0x1000, %eax; \
    cmp $empty_zero_page - __PAGE_OFFSET, %edi; \
    jne 2b;
```

内核的这段代码执行时，因为页机制还没有启用，还没有进入保护模式，因此指令寄存器EIP中的地址还是物理地址，但因为pg0中存放的是虚拟地址(想想gcc编译内核以后形成的符号地址是虚拟地址)，因此"$pg0 - __PAGE_OFFSET" 获得pg0的物理地址，可见pg0存放在相对于内核代码起点为0x2000的地方，即物理地址为0x00102000, 而pg1的物理地址则为0x00103000。 （内核的img，被搬移物理地址1M的地方）。　pg0 和 pg1 这两个页表中的页项则依次被设置为0x007 0x1007 0x2007 等。其中最低的三位均为1, 表示这两个页为用户页，可写，且页的内容