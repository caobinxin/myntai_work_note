在内存管理(MM)的各种机制介绍之前，首先需要对ＭＭ的初始化过程有所了解，以下介绍的内容是以分段和分页机制为基础的，因此，读者应该先温习前几讲相关的内容。因为在嵌入式操作系统的开发中，内存的初始化是重点关注的内容之一，因此本讲对内存的初始化给予详细的讲解。

# 1. 启用分页机制

当linux启动时，首先运行在实模式下，随后就要转到保护模式下运行。因为在第二章段机制中，我们已经介绍了linux对段的设置，在此我们主要讨论与分页机制相关的问题。

linux内核代码的入口点在　arch/i386/kernel/head.S 中　startup_32

## 1. 页表的初始化：

```c
/*
 * The page tables are initialized to only 8MB here - the final page
 * tables are set up later depending on memory size.
 */
.org 0x2000
ENTRY(pg0)                                                                                                                                            

.org 0x3000
ENTRY(pg1)
    
    
/*
 * empty_zero_page must immediately follow the page tables ! (The
 * initialization loop counts until empty_zero_page)                                                                                                  
 */

.org 0x4000
ENTRY(empty_zero_page)   
    
 //------------------------------------
 /*
 * Initialize page tables
 */
#define INIT_PAGE_TABLES \
    movl $pg0 - __PAGE_OFFSET, %edi; \
    /* "007" doesn't mean with license to kill, but PRESENT+RW+USER */ \
    movl $007, %eax; \
2:  stosl; \ 
/*将　eax中的值，自动保存在　ES:EDI指向的地址中，　若设置了EFLAGS中的方向位置位(即在STOSL指令前使用STD指令)则EDI自减4，否则(使用CLD指令)EDI自增4；*/

    add $0x1000, %eax; \
    cmp $empty_zero_page - __PAGE_OFFSET, %edi; \
    jne 2b;　/*不相等才跳转*/
```

内核的这段代码执行时，因为页机制还没有启用，还没有进入保护模式，因此指令寄存器EIP中的地址还是物理地址，但因为pg0中存放的是虚拟地址(想想gcc编译内核以后形成的符号地址是虚拟地址)，因此"$pg0 - __PAGE_OFFSET" 获得pg0的物理地址，可见pg0存放在相对于内核代码起点为0x2000的地方，即物理地址为0x00102000, 而pg1的物理地址则为0x00103000。 （内核的img，被搬移物理地址1M的地方）。　pg0 和 pg1 这两个页表中的页项则依次被设置为0x007 0x1007 0x2007 等。其中最低的三位均为1, 表示这两个页为用户页，可写，且页的内容中(参见图2.24)。　所映射的物理页的基地址则为　0x0、　0x1000、　0x2000等，也就是物理内存中的页面0 1 2 3 等等，共映射2k个页面，即8MB的存储空间。由此可以看出，linux内核对物理内存的最低要求为8MB.紧接着存放的是empty_zero_page页(即零页)，零页存放的是系统启动参数和命令行参数，具体内容参见第十三章。

## 2. 启用分页机制

```assembly
; arch/i386/kernel/head.S:385


/*
 * This is initialized to create an identity-mapping at 0-8M (for bootup
 * purposes) and another mapping of the 0-8M area at virtual address
 * PAGE_OFFSET.
 */
.org 0x1000
ENTRY(swapper_pg_dir)                                                                                                                                                                                              
    .long 0x00102007
    .long 0x00103007
    .fill BOOT_USER_PGD_PTRS-2,4,0
    /* default: 766 entries */
    .long 0x00102007
    .long 0x00103007
    /* default: 254 entries */
    .fill BOOT_KERNEL_PGD_PTRS-2,4,0



/*
 * Enable paging
 */
3:
    movl $swapper_pg_dir-__PAGE_OFFSET,%eax
    movl %eax,%cr3      /* set the page table pointer.. */
    movl %cr0,%eax
    orl $0x80000000,%eax
    movl %eax,%cr0      /* ..and set paging (PG) bit */
    jmp 1f          /* flush the prefetch-queue */
1:
    movl $1f,%eax
    jmp *%eax       /* make sure eip is relocated */
1:
    /* Set up the stack pointer */
    lss stack_start,%esp

```

​	我们先看这段代码的功能。这段代码就是把页目录 swapper_pg_dir 的物理地址装入控制器cr3，并把cr0中的最高位设置为1,这就开启了分页机制。

​	但是启动了分页机制，并不说明linux内核真正进入保护模式，因此此时，指令寄存器 EIP 中的地址还是物理地址，而不是虚拟地址。　"jmp 1f" 指令从逻辑上说不起什么作用，但是，从功能上说它起到丢弃　指令流水中内容的作用(这是intel 在i386技术资料中所建议的)，因为这是一个短跳转， EIP中还是物理地址。紧接着的mov 和　jmp　指令把第二个标号为1的地址装入　EAX 寄存器并跳转到那儿。在这两条指令执行的过程中，EIP　还是指向物理地址　"1MB + 某处"。因为编译程序使所有的符号地址都在虚拟内存空间中，因此，第二个标号1 的地址就在虚拟内存空间的某处((PAGE_OFFSET + 某处))，于是，jmp指令执行以后，EIP就指向虚拟内核空间的某个地方，这就使cpu转入了内核空间，从而完成了从实模式到保护模式的平稳过度。